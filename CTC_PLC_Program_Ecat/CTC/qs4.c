#define __IPMVAR_TEST_IPMs 1
#define __IPMVAR_CTC_EmptyAxis1_Axisnum (-1)
#define __IPMVAR_CTC_EmptyAxis1_Limit (-2)
#define __IPMVAR_CTC_EmptyAxis1_command (-3)
#define __IPMVAR_CTC_EmptyAxis1_WaitStart (-4)
#define __IPMVAR_CTC_EmptyAxis1_MSBRunning (-5)
#define __IPMVAR_CTC_EmptyAxis1_NewPosition (-6)
#define __IPMVAR_CTC_EmptyAxis1_Accel (-7)
#define __IPMVAR_CTC_EmptyAxis1_Decel (-8)
#define __IPMVAR_CTC_EmptyAxis1_Maxspeed (-9)
#define __IPMVAR_CTC_EmptyAxis1_Target (-10)
#define __IPMVAR_CTC_EmptyAxis1_State (-11)
#define __IPMVAR_CTC_EmptyAxis1_RegWrite (-12)
#define __IPMVAR_CTC_EmptyAxis1_OffsetHome (-13)
#define __IPMVAR_CTC_EmptyAxis1_Direction (-14)
#define __IPMVAR_CTC_EmptyAxis2_Axisnum (-1)
#define __IPMVAR_CTC_EmptyAxis2_Limit (-2)
#define __IPMVAR_CTC_EmptyAxis2_command (-3)
#define __IPMVAR_CTC_EmptyAxis2_WaitStart (-4)
#define __IPMVAR_CTC_EmptyAxis2_MSBRunning (-5)
#define __IPMVAR_CTC_EmptyAxis2_NewPosition (-6)
#define __IPMVAR_CTC_EmptyAxis2_Accel (-7)
#define __IPMVAR_CTC_EmptyAxis2_Decel (-8)
#define __IPMVAR_CTC_EmptyAxis2_Maxspeed (-9)
#define __IPMVAR_CTC_EmptyAxis2_Target (-10)
#define __IPMVAR_CTC_EmptyAxis2_State (-11)
#define __IPMVAR_CTC_EmptyAxis2_RegWrite (-12)
#define __IPMVAR_CTC_EmptyAxis2_OffsetHome (-13)
#define __IPMVAR_CTC_EmptyAxis2_Direction (-14)
#define __IPMVAR_CTC_EmptyAxis3_Axisnum (-1)
#define __IPMVAR_CTC_EmptyAxis3_Limit (-2)
#define __IPMVAR_CTC_EmptyAxis3_command (-3)
#define __IPMVAR_CTC_EmptyAxis3_WaitStart (-4)
#define __IPMVAR_CTC_EmptyAxis3_MSBRunning (-5)
#define __IPMVAR_CTC_EmptyAxis3_NewPosition (-6)
#define __IPMVAR_CTC_EmptyAxis3_Accel (-7)
#define __IPMVAR_CTC_EmptyAxis3_Decel (-8)
#define __IPMVAR_CTC_EmptyAxis3_Maxspeed (-9)
#define __IPMVAR_CTC_EmptyAxis3_Distance (-10)
#define __IPMVAR_CTC_EmptyAxis3_Target (-11)
#define __IPMVAR_CTC_EmptyAxis3_TravelDirection (-12)
#define __IPMVAR_CTC_EmptyAxis3_State (-13)
#define __IPMVAR_CTC_EmptyAxis3_RegWrite (-14)
#define __IPMVAR_CTC_EmptyAxis3_Direction (-15)
#define __IPMVAR_CTC_EmptyAxis3_In1 (-16)
#define __IPMVAR_CTC_EmptyAxis3_OffsetHome (-17)
#define __IPMVAR_CTC_Gripper_Axisnum (-1)
#define __IPMVAR_CTC_Gripper_Limit (-2)
#define __IPMVAR_CTC_Gripper_command (-3)
#define __IPMVAR_CTC_Gripper_WaitStart (-4)
#define __IPMVAR_CTC_Gripper_MSBRunning (-5)
#define __IPMVAR_CTC_Gripper_NewPosition (-6)
#define __IPMVAR_CTC_Gripper_Accel (-7)
#define __IPMVAR_CTC_Gripper_Decel (-8)
#define __IPMVAR_CTC_Gripper_Maxspeed (-9)
#define __IPMVAR_CTC_Gripper_Target (-10)
#define __IPMVAR_CTC_Gripper_State (-11)
#define __IPMVAR_CTC_Gripper_RegWrite (-12)
#define __IPMVAR_CTC_Gripper_OffsetHome (-13)
#define __IPMVAR_CTC_Gripper_Direction (-14)
#define __IPMVAR_CTC_ThetaAxis_Axisnum (-1)
#define __IPMVAR_CTC_ThetaAxis_Limit (-2)
#define __IPMVAR_CTC_ThetaAxis_command (-3)
#define __IPMVAR_CTC_ThetaAxis_WaitStart (-4)
#define __IPMVAR_CTC_ThetaAxis_MSBRunning (-5)
#define __IPMVAR_CTC_ThetaAxis_NewPosition (-6)
#define __IPMVAR_CTC_ThetaAxis_Accel (-7)
#define __IPMVAR_CTC_ThetaAxis_Decel (-8)
#define __IPMVAR_CTC_ThetaAxis_Maxspeed (-9)
#define __IPMVAR_CTC_ThetaAxis_Target (-10)
#define __IPMVAR_CTC_ThetaAxis_State (-11)
#define __IPMVAR_CTC_ThetaAxis_RegWrite (-12)
#define __IPMVAR_CTC_ThetaAxis_OffsetHome (-13)
#define __IPMVAR_CTC_ThetaAxis_Direction (-14)
#define __IPMVAR_CTC_TransferStation_Axisnum (-1)
#define __IPMVAR_CTC_TransferStation_Limit (-2)
#define __IPMVAR_CTC_TransferStation_command (-3)
#define __IPMVAR_CTC_TransferStation_WaitStart (-4)
#define __IPMVAR_CTC_TransferStation_MSBRunning (-5)
#define __IPMVAR_CTC_TransferStation_NewPosition (-6)
#define __IPMVAR_CTC_TransferStation_Accel (-7)
#define __IPMVAR_CTC_TransferStation_Decel (-8)
#define __IPMVAR_CTC_TransferStation_Maxspeed (-9)
#define __IPMVAR_CTC_TransferStation_Distance (-10)
#define __IPMVAR_CTC_TransferStation_Target (-11)
#define __IPMVAR_CTC_TransferStation_TravelDirection (-12)
#define __IPMVAR_CTC_TransferStation_State (-13)
#define __IPMVAR_CTC_TransferStation_RegWrite (-14)
#define __IPMVAR_CTC_TransferStation_Direction (-15)
#define __IPMVAR_CTC_TransferStation_In1 (-16)
#define __IPMVAR_CTC_TransferStation_OffsetHome (-17)
#define __IPMVAR_CTC_XAxis_speed (-1)
#define __IPMVAR_CTC_XAxis_command (-2)
#define __IPMVAR_CTC_XAxis_YTarget (-3)
#define __IPMVAR_CTC_XAxis_ZTarget (-4)
#define __IPMVAR_CTC_XAxis_XTarget (-5)
#define __IPMVAR_CTC_XAxis_Accel (-6)
#define __IPMVAR_CTC_XAxis_Decel (-7)
#define __IPMVAR_CTC_XAxis_RegWrite (-8)
#define __IPMVAR_CTC_XAxis_Axisnum (-9)
#define __IPMVAR_CTC_XAxis_Limit (-10)
#define __IPMVAR_CTC_XAxis_WaitStart (-11)
#define __IPMVAR_CTC_XAxis_MSBRunning (-12)
#define __IPMVAR_CTC_XAxis_NewPosition (-13)
#define __IPMVAR_CTC_XAxis_Maxspeed (-14)
#define __IPMVAR_CTC_XAxis_Target (-15)
#define __IPMVAR_CTC_XAxis_State (-16)
#define __IPMVAR_CTC_XAxis_OffsetHome (-17)
#define __IPMVAR_CTC_XAxis_Direction (-18)
#define __IPMVAR_CTC_YAxis_Axisnum (-1)
#define __IPMVAR_CTC_YAxis_Limit (-2)
#define __IPMVAR_CTC_YAxis_command (-3)
#define __IPMVAR_CTC_YAxis_WaitStart (-4)
#define __IPMVAR_CTC_YAxis_MSBRunning (-5)
#define __IPMVAR_CTC_YAxis_NewPosition (-6)
#define __IPMVAR_CTC_YAxis_Accel (-7)
#define __IPMVAR_CTC_YAxis_Decel (-8)
#define __IPMVAR_CTC_YAxis_Maxspeed (-9)
#define __IPMVAR_CTC_YAxis_Target (-10)
#define __IPMVAR_CTC_YAxis_State (-11)
#define __IPMVAR_CTC_YAxis_RegWrite (-12)
#define __IPMVAR_CTC_YAxis_OffsetHome (-13)
#define __IPMVAR_CTC_YAxis_Direction (-14)
#define __IPMVAR_CTC_ZAxis_Axisnum (-1)
#define __IPMVAR_CTC_ZAxis_Limit (-2)
#define __IPMVAR_CTC_ZAxis_command (-3)
#define __IPMVAR_CTC_ZAxis_WaitStart (-4)
#define __IPMVAR_CTC_ZAxis_MSBRunning (-5)
#define __IPMVAR_CTC_ZAxis_NewPosition (-6)
#define __IPMVAR_CTC_ZAxis_Accel (-7)
#define __IPMVAR_CTC_ZAxis_Decel (-8)
#define __IPMVAR_CTC_ZAxis_Maxspeed (-9)
#define __IPMVAR_CTC_ZAxis_Target (-10)
#define __IPMVAR_CTC_ZAxis_State (-11)
#define __IPMVAR_CTC_ZAxis_RegWrite (-12)
#define __IPMVAR_CTC_ZAxis_OffsetHome (-13)
#define __IPMVAR_CTC_ZAxis_Direction (-14)

#define QB_RUNTIME
#ifndef QB_RUNTIME
#define QB_RUNTIME
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

static int __qb_initialized = 0;

#ifdef ABSTRACT_INTIME
#include "USER_CoreFunc.h"
#include "USER_variant.h"
#include "CoreFunc.c"
#pragma warning(push)
#pragma warning(disable: 4102)
#define NO_STRICT
#define WIN32_LEAN_AND_MEAN

#include <string.h>
#include <rt.h>
#include <netinet\in.h>

#define SOCKADDR_IN struct sockaddr_in
#define SOCKADDR struct sockaddr
#define IN_ADDR struct in_addr
#define CTC_MAX_RESOURCE_NAME 32
#define TX_THREAD RTHANDLE

typedef struct ctc_reslist
{
	void *freeStart;
	void *freeLast;
	int freeNum;
	void *usedStart;
	void *usedLast;
	int usedNum;
#ifdef ABSTRACT_LINUX
	pthread_mutex_t      *lock;
	pthread_mutex_t      mutex;
#endif
#ifdef ABSTRACT_THREADX
	TX_MUTEX lock;
#endif
#ifdef ABSTRACT_SYSBIOS
	Semaphore_Handle lock;
#endif
#ifdef ABSTRACT_KITHARA
	KSHandle lock;
#endif
#ifdef ABSTRACT_INTIME
	RTHANDLE lock;
#endif
} CTC_RESLIST;

typedef struct ctc_threadstruc
{
	// START COMMON HEADER
	struct ctc_threadstruc *prev;						// Pointer to previous resource same as this one and in same state, used or free
	struct ctc_threadstruc *next;						// Pointer to next resource same as this one and in same state, used or free
	char threadName[CTC_MAX_RESOURCE_NAME + 1];	// Name of this resource
	CTC_RESLIST *rlist;					// Pointer to resource list owned by this resource
	void *parameterlist;				// Pointer to parameter list
	int parameterlistMalloced;			// Parameter list flag, if malloced then free when thread done
	// END COMMON HEADER
	// resource specific information
	int stacksize;						// Size of stack in bytes
	void *stack_start;					// Pointer to start of stack storage
	int autoStart;						// If set then start the thread, else start but suspend prior to calling function
	int priorityLevel;					// Priority level to run thread at
	int preemptionLevel;				// Preemption level to run thread at
	SOCKADDR_IN ipAddr;					// If was a TCP server socket this contains connection information since was spawned
	void *Mailbox;						// Pointer to mailbox structure should caller decide to create own, can be used for other application
	// specifics also
	void(*function)(void *);	// If NULL then just suspend thread, else invoke
#ifdef ABSTRACT_SYSBIOS
	Task_Params taskParams;
	Error_Block eb;
#endif
#ifdef ABSTRACT_KITHARA
	KSHandle hCallback;
#endif
	TX_THREAD threadblk;				// ThreadX thread descriptor block
	TX_THREAD *threadptr;				// Pointer to Thread descriptor block
#ifdef ABSTRACT_LINUX
	pthread_attr_t attr;
#endif

} CTC_THREAD;

#ifndef TESTING_QB
// Set to highest priority
_inline unsigned int Hwi_disable() { int oldprio = GetRtThreadPriority(NULL_RTHANDLE); SetRtThreadPriority(NULL_RTHANDLE, 0); return (unsigned int)oldprio; }
_inline void Hwi_restore(unsigned int newprio) { SetRtThreadPriority(GetRtThreadHandles(THIS_THREAD), newprio); }
#endif

#define TX_AUTO_START 1
#define TX_NO_TIME_SLICE 0
#define TX_DONT_START -1
#define TX_WAIT_FOREVER -1
//#include "CTC_Abstract.h"

#define THREAD_PRIORITY_DEFAULT_SPAWN 140  // start as fastest and then lower it...
#define	ENTER_CRITICAL_REGION Task_disable()
#define	EXIT_CRITICAL_REGION Task_enable()
#define tx_time_get CTC_getMsTickCount
#define	TX_DISABLE	Task_disable();
#define	TX_RESTORE	Task_enable();
#define	TX_INTERRUPT_SAVE_AREA
#define TX_EVENT_FLAGS_GROUP CTC_MAILBOX *
#define TX_SUCCESS 0
#define MALLOC_DATA_SIZE		(0x100000)	  // about 1 Meg, set in C6000 linker options --heap (Basic Options)
#define TX_INHERIT 0
#define TX_NO_INHERIT -1
#define portDISABLE_INTERRUPTS Task_disable
#define portENABLE_INTERRUPTS Task_enable
#define rint  (int)round
//#define lround xllround
#define TX_NO_WAIT 0
#define TX_WAIT_FOREVER -1
#define CTC_DisableInterrupts	Task_disable
#define CTC_EnableInterrupts	Task_enable
#define CTC_DisableTasks()	__oldprio = Hwi_disable()
#define CTC_EnableTasks()	Hwi_restore(__oldprio)
#define CLOCK_MONOTONIC 0

#define Task_disable()  unsigned int __oldprio = Hwi_disable()

#define Task_enable() Hwi_restore(__oldprio)

#define TX_PREEMPTION_DISABLE Task_disable()
#define TX_PREEMPTION_RESTORE Task_enable()
#define TX_PREEMPTION_SAVE_AREA
#else
#include "CoreFunc.h"
#include "variant.h"
#endif

#define LOG_QB_APPLICATION 4550

#ifdef ABSTRACT_INTIME
// INTIME does not support Pre-emption at same task priority so just bump our priority by one
//#define PREEMPTION_TASK_DISABLE 	_tx_thread_create(NULL, NULL, NULL, 0, NULL, 3,	THREAD_PRIORITY_QB_TASK,THREAD_PRIORITY_QB_TASK-1, TX_NO_TIME_SLICE, TX_AUTO_START)	
#define PREEMPTION_TASK_DISABLE	SetRtThreadPriority(NULL_RTHANDLE, (THREAD_PRIORITY_QB_TASK-1))
#define PREEMPTION_TASK_RESTORE	SetRtThreadPriority(NULL_RTHANDLE, (THREAD_PRIORITY_QB_TASK))
#else
#define PREEMPTION_TASK_DISABLE 	_tx_thread_create(NULL, NULL, NULL, 0, NULL, 3,	THREAD_PRIORITY_QB_TASK,0, TX_NO_TIME_SLICE, TX_AUTO_START)	
#define PREEMPTION_TASK_RESTORE 	_tx_thread_create(NULL, NULL, NULL, 0, NULL, 3,	THREAD_PRIORITY_QB_TASK,THREAD_PRIORITY_QB_TASK, TX_NO_TIME_SLICE, TX_AUTO_START)	
#endif

#define THREADX_UNIQUE_ID 0x54485244


#ifndef QB_HDR_VERSION
#define QB_HDR_VERSION 100
#endif

#define QS4_NEWINIT
#define IPM_RPC

#define TASK_LL_STEP (0x000d)
#define TASK_LL_RUN (0x000e)
#define TASK_LL_BREAKPOINT (0x000f)

#define ____true			1
#define ____false			0
#define ____TRUE			1
#define ____FALSE			0
#define ____on				1
#define ____off				0
#define ____ON				1
#define ____OFF				0

#define ____PI				(3.14159265358979323846264338327950288419716939937)

#define ____BIT0			0x00000001
#define ____BIT1			0x00000002
#define ____BIT2			0x00000004
#define ____BIT3			0x00000008
#define ____BIT4			0x00000010
#define ____BIT5			0x00000020
#define ____BIT6			0x00000040
#define ____BIT7			0x00000080
#define ____BIT8			0x00000100
#define ____BIT9			0x00000200
#define ____BIT10			0x00000400
#define ____BIT11			0x00000800
#define ____BIT12			0x00001000
#define ____BIT13			0x00002000
#define ____BIT14			0x00004000
#define ____BIT15			0x00008000
#define ____BIT16			0x00010000
#define ____BIT17			0x00020000
#define ____BIT18			0x00040000
#define ____BIT19			0x00080000
#define ____BIT20			0x00100000
#define ____BIT21			0x00200000
#define ____BIT22			0x00400000
#define ____BIT23			0x00800000
#define ____BIT24			0x01000000
#define ____BIT25			0x02000000
#define ____BIT26			0x04000000
#define ____BIT27			0x08000000
#define ____BIT28			0x10000000
#define ____BIT29			0x20000000
#define ____BIT30			0x40000000
#define ____BIT31			0x80000000

#define ____NBIT0			~0x00000001
#define ____NBIT1			~0x00000002
#define ____NBIT2			~0x00000004
#define ____NBIT3			~0x00000008
#define ____NBIT4			~0x00000010
#define ____NBIT5			~0x00000020
#define ____NBIT6			~0x00000040
#define ____NBIT7			~0x00000080
#define ____NBIT8			~0x00000100
#define ____NBIT9			~0x00000200
#define ____NBIT10			~0x00000400
#define ____NBIT11			~0x00000800
#define ____NBIT12			~0x00001000
#define ____NBIT13			~0x00002000
#define ____NBIT14			~0x00004000
#define ____NBIT15			~0x00008000
#define ____NBIT16			~0x00010000
#define ____NBIT17			~0x00020000
#define ____NBIT18			~0x00040000
#define ____NBIT19			~0x00080000
#define ____NBIT20			~0x00100000
#define ____NBIT21			~0x00200000
#define ____NBIT22			~0x00400000
#define ____NBIT23			~0x00800000
#define ____NBIT24			~0x01000000
#define ____NBIT25			~0x02000000
#define ____NBIT26			~0x04000000
#define ____NBIT27			~0x08000000
#define ____NBIT28			~0x10000000
#define ____NBIT29			~0x20000000
#define ____NBIT30			~0x40000000
#define ____NBIT31			~0x80000000

// constants

#define CAPTURE_IDLE						0
#define CAPTURE_INIT						1
#define CAPTURE_ACTIVE						2
#define CAPTURE_WAITING						3

#define CAPTURE_DEPTH						500
#define IO_CAPTURES							4
#define DATA_CAPTURES						8

#define CAPTURE_NONE						(-1)
#define CAPTURE_OBJ							0
#define CAPTURE_REG							1
#define CAPTURE_AREG						2

#define N_ACTIVE_STRINGS					8

#define N_QS4_FILES							16
#define MAX_AXIS							48  // Use to be MAX_MSBS but in reality this simply issues stop commands to each axis.
												// We don't know how many prior program had so do all.  Program itself also issues
												// stop command for each we know of.  For now use 16 * 3 or enough for 3 EtherCAT networks.
static int __axisMap[MAX_AXIS];
// QS4 error codes

#define QS4_ERROR_STRLEN					501
#define QS4_ERROR_INVALID_INDIRECT			502
#define QS4_ERROR_INVALID_SYSTEM_VAR_OP		503

// QS4 special registers

#define	QS4_CAP_START						36812
#define	QS4_CAP_DEPTH						36813

// This was Quickstep register, changed KRH
#define LEGACY_CAPTURE

#ifndef LEGACY_CAPTURE
int capStart = CAPTURE_IDLE;
int capDepth = CAPTURE_DEPTH;
#endif
// #defined functions

#define Q4T(task)			((QS4INFO*)(task->qs4TaskLocal))

#define sign(a)				(((a)<0) ? -1 : (a)>0 ? 1 : 0)
#define sign2(a, b)			(((a)<0) ? (-(b)) : (a)>0 ? (b) : 0)

#define ____abs(a)			((a)>=0 ? (a) : (-(a)))
#define ____min(a,b)		(((a) < (b)) ? (a) : (b))
#define ____max(a,b)		(((a) > (b)) ? (a) : (b))
#define ____frac(a)			((a)-floor(a))
#define ____bit(a, n)		(((a) & (1<<(n))) == 0 ? 0 : 1)
#define ____len(a)			(strlen(a))
#define ____compare(a,b)	(strcmp(a,b))

#define	__IPM_CLEAR			RPC_clear_all_MSB
#define	__IPM_START			RPC_axis_start_MSB
#define	__IPM_STOP			RPC_axis_stop_MSB
#define	__IPM_LOAD			RPC_load_MSB

#define	QS4C_BLOCKSIZE		1000
#define MAX_QB_THREADPRIORITY 100

//--QS4CDEFS--//
#define QS_F1_Trigger	(_I(NULL,13201,0,0))
#define QSW_F1_Trigger(x)	(_IW(NULL,13201,0,0,(int)(x)))
#define QS_F32_Mode	(_I(NULL,13232,0,0))
#define QSW_F32_Mode(x)	(_IW(NULL,13232,0,0,(int)(x)))
#define QS_i	(_I(NULL,1,0,0))
#define QSW_i(x)	(_IW(NULL,1,0,0,(int)(x)))
#define QS_R10_Mode	(_I(NULL,10,0,0))
#define QSW_R10_Mode(x)	(_IW(NULL,10,0,0,(int)(x)))
#define QS_R12333_RestartEtherCAT	(_I(NULL,12333,0,0))
#define QSW_R12333_RestartEtherCAT(x)	(_IW(NULL,12333,0,0,(int)(x)))
#define QS_R13464_EtherCATStatus	(_I(NULL,13464,0,0))
#define QSW_R13464_EtherCATStatus(x)	(_IW(NULL,13464,0,0,(int)(x)))
#define QS_R20099_ModBusTCPWordSwap	(_I(NULL,20099,0,0))
#define QSW_R20099_ModBusTCPWordSwap(x)	(_IW(NULL,20099,0,0,(int)(x)))
#define QS_R36101_Temp	(_F(NULL,36101,0,0))
#define QSW_R36101_Temp(x)	(_FW(NULL,36101,0,0,(float)(x)))
#define QS_R36711_Ax1Fpos	(_F(NULL,36711,0,0))
#define QSW_R36711_Ax1Fpos(x)	(_FW(NULL,36711,0,0,(float)(x)))
#define QS_R36712_Ax1Fpos	(_F(NULL,36712,0,0))
#define QSW_R36712_Ax1Fpos(x)	(_FW(NULL,36712,0,0,(float)(x)))
#define QS_R36713_Ax1Fpos	(_F(NULL,36713,0,0))
#define QSW_R36713_Ax1Fpos(x)	(_FW(NULL,36713,0,0,(float)(x)))
#define QS_R36714_Ax1Fpos	(_F(NULL,36714,0,0))
#define QSW_R36714_Ax1Fpos(x)	(_FW(NULL,36714,0,0,(float)(x)))
#define QS_R500_RestartProgram	(_I(NULL,500,0,0))
#define QSW_R500_RestartProgram(x)	(_IW(NULL,500,0,0,(int)(x)))
#define QS_R9_Dwell	(_I(NULL,9,0,0))
#define QSW_R9_Dwell(x)	(_IW(NULL,9,0,0,(int)(x)))
#define QS_running1	(_I(NULL,20,0,0))
#define QSW_running1(x)	(_IW(NULL,20,0,0,(int)(x)))
#define QS_running10	(_I(NULL,29,0,0))
#define QSW_running10(x)	(_IW(NULL,29,0,0,(int)(x)))
#define QS_running2	(_I(NULL,21,0,0))
#define QSW_running2(x)	(_IW(NULL,21,0,0,(int)(x)))
#define QS_running3	(_I(NULL,22,0,0))
#define QSW_running3(x)	(_IW(NULL,22,0,0,(int)(x)))
#define QS_running4	(_I(NULL,23,0,0))
#define QSW_running4(x)	(_IW(NULL,23,0,0,(int)(x)))
#define QS_running5	(_I(NULL,24,0,0))
#define QSW_running5(x)	(_IW(NULL,24,0,0,(int)(x)))
#define QS_running6	(_I(NULL,25,0,0))
#define QSW_running6(x)	(_IW(NULL,25,0,0,(int)(x)))
#define QS_running7	(_I(NULL,26,0,0))
#define QSW_running7(x)	(_IW(NULL,26,0,0,(int)(x)))
#define QS_running8	(_I(NULL,27,0,0))
#define QSW_running8(x)	(_IW(NULL,27,0,0,(int)(x)))
#define QS_running9	(_I(NULL,28,0,0))
#define QSW_running9(x)	(_IW(NULL,28,0,0,(int)(x)))
#define QS_R36701_Speed	(_F(NULL,36701,0,0))
#define QSW_R36701_Speed(x)	(_FW(NULL,36701,0,0,(float)(x)))
#define QS_R36702_Accel	(_F(NULL,36702,0,0))
#define QSW_R36702_Accel(x)	(_FW(NULL,36702,0,0,(float)(x)))
#define QS_R36703_Decel	(_F(NULL,36703,0,0))
#define QSW_R36703_Decel(x)	(_FW(NULL,36703,0,0,(float)(x)))
#define QS_R36704_XTarget	(_F(NULL,36704,0,0))
#define QSW_R36704_XTarget(x)	(_FW(NULL,36704,0,0,(float)(x)))
#define QS_R36705_YTarget	(_F(NULL,36705,0,0))
#define QSW_R36705_YTarget(x)	(_FW(NULL,36705,0,0,(float)(x)))
#define QS_R36706_ZTarget	(_F(NULL,36706,0,0))
#define QSW_R36706_ZTarget(x)	(_FW(NULL,36706,0,0,(float)(x)))
#define QS_R501_Speed	(_I(NULL,501,0,0))
#define QSW_R501_Speed(x)	(_IW(NULL,501,0,0,(int)(x)))
#define QS_R502_Accel	(_I(NULL,502,0,0))
#define QSW_R502_Accel(x)	(_IW(NULL,502,0,0,(int)(x)))
#define QS_R503_Decel	(_I(NULL,503,0,0))
#define QSW_R503_Decel(x)	(_IW(NULL,503,0,0,(int)(x)))
#define QS_R504_Target	(_I(NULL,504,0,0))
#define QSW_R504_Target(x)	(_IW(NULL,504,0,0,(int)(x)))
#define QS_R505_HomeOffset	(_I(NULL,505,0,0))
#define QSW_R505_HomeOffset(x)	(_IW(NULL,505,0,0,(int)(x)))
#define QS_R509_X_fpos	(_I(NULL,509,0,0))
#define QSW_R509_X_fpos(x)	(_IW(NULL,509,0,0,(int)(x)))
#define QS_R510_XAxisCommands	(_I(NULL,510,0,0))
#define QSW_R510_XAxisCommands(x)	(_IW(NULL,510,0,0,(int)(x)))
#define QS_R511_Speed	(_I(NULL,511,0,0))
#define QSW_R511_Speed(x)	(_IW(NULL,511,0,0,(int)(x)))
#define QS_R512_Accel	(_I(NULL,512,0,0))
#define QSW_R512_Accel(x)	(_IW(NULL,512,0,0,(int)(x)))
#define QS_R513_Decel	(_I(NULL,513,0,0))
#define QSW_R513_Decel(x)	(_IW(NULL,513,0,0,(int)(x)))
#define QS_R514_Target	(_I(NULL,514,0,0))
#define QSW_R514_Target(x)	(_IW(NULL,514,0,0,(int)(x)))
#define QS_R515_HomeOffset	(_I(NULL,515,0,0))
#define QSW_R515_HomeOffset(x)	(_IW(NULL,515,0,0,(int)(x)))
#define QS_R519_Y_fpos	(_I(NULL,519,0,0))
#define QSW_R519_Y_fpos(x)	(_IW(NULL,519,0,0,(int)(x)))
#define QS_R520_YAxisCommands	(_I(NULL,520,0,0))
#define QSW_R520_YAxisCommands(x)	(_IW(NULL,520,0,0,(int)(x)))
#define QS_R521_Speed	(_I(NULL,521,0,0))
#define QSW_R521_Speed(x)	(_IW(NULL,521,0,0,(int)(x)))
#define QS_R522_Accel	(_I(NULL,522,0,0))
#define QSW_R522_Accel(x)	(_IW(NULL,522,0,0,(int)(x)))
#define QS_R523_Decel	(_I(NULL,523,0,0))
#define QSW_R523_Decel(x)	(_IW(NULL,523,0,0,(int)(x)))
#define QS_R524_Target	(_I(NULL,524,0,0))
#define QSW_R524_Target(x)	(_IW(NULL,524,0,0,(int)(x)))
#define QS_R525_HomeOffset	(_I(NULL,525,0,0))
#define QSW_R525_HomeOffset(x)	(_IW(NULL,525,0,0,(int)(x)))
#define QS_R529_Z_fpos	(_I(NULL,529,0,0))
#define QSW_R529_Z_fpos(x)	(_IW(NULL,529,0,0,(int)(x)))
#define QS_R530_ZAxisCommands	(_I(NULL,530,0,0))
#define QSW_R530_ZAxisCommands(x)	(_IW(NULL,530,0,0,(int)(x)))
#define QS_R531_Speed	(_I(NULL,531,0,0))
#define QSW_R531_Speed(x)	(_IW(NULL,531,0,0,(int)(x)))
#define QS_R532_Accel	(_I(NULL,532,0,0))
#define QSW_R532_Accel(x)	(_IW(NULL,532,0,0,(int)(x)))
#define QS_R533_Decel	(_I(NULL,533,0,0))
#define QSW_R533_Decel(x)	(_IW(NULL,533,0,0,(int)(x)))
#define QS_R534_Target	(_I(NULL,534,0,0))
#define QSW_R534_Target(x)	(_IW(NULL,534,0,0,(int)(x)))
#define QS_R535_HomeOffset	(_I(NULL,535,0,0))
#define QSW_R535_HomeOffset(x)	(_IW(NULL,535,0,0,(int)(x)))
#define QS_R539_fpos	(_I(NULL,539,0,0))
#define QSW_R539_fpos(x)	(_IW(NULL,539,0,0,(int)(x)))
#define QS_R540_ThetaCommands	(_I(NULL,540,0,0))
#define QSW_R540_ThetaCommands(x)	(_IW(NULL,540,0,0,(int)(x)))
#define QS_R541_Speed	(_I(NULL,541,0,0))
#define QSW_R541_Speed(x)	(_IW(NULL,541,0,0,(int)(x)))
#define QS_R542_Accel	(_I(NULL,542,0,0))
#define QSW_R542_Accel(x)	(_IW(NULL,542,0,0,(int)(x)))
#define QS_R543_Decel	(_I(NULL,543,0,0))
#define QSW_R543_Decel(x)	(_IW(NULL,543,0,0,(int)(x)))
#define QS_R544_Target	(_I(NULL,544,0,0))
#define QSW_R544_Target(x)	(_IW(NULL,544,0,0,(int)(x)))
#define QS_R545_HomeOffset	(_I(NULL,545,0,0))
#define QSW_R545_HomeOffset(x)	(_IW(NULL,545,0,0,(int)(x)))
#define QS_R549_fpos	(_I(NULL,549,0,0))
#define QSW_R549_fpos(x)	(_IW(NULL,549,0,0,(int)(x)))
#define QS_R550_GripperCommands	(_I(NULL,550,0,0))
#define QSW_R550_GripperCommands(x)	(_IW(NULL,550,0,0,(int)(x)))
#define QS_R551_Speed	(_I(NULL,551,0,0))
#define QSW_R551_Speed(x)	(_IW(NULL,551,0,0,(int)(x)))
#define QS_R552_Accel	(_I(NULL,552,0,0))
#define QSW_R552_Accel(x)	(_IW(NULL,552,0,0,(int)(x)))
#define QS_R553_Decel	(_I(NULL,553,0,0))
#define QSW_R553_Decel(x)	(_IW(NULL,553,0,0,(int)(x)))
#define QS_R554_Target	(_I(NULL,554,0,0))
#define QSW_R554_Target(x)	(_IW(NULL,554,0,0,(int)(x)))
#define QS_R555_HomeOffset	(_I(NULL,555,0,0))
#define QSW_R555_HomeOffset(x)	(_IW(NULL,555,0,0,(int)(x)))
#define QS_R559_fpos	(_I(NULL,559,0,0))
#define QSW_R559_fpos(x)	(_IW(NULL,559,0,0,(int)(x)))
#define QS_R560_GripperRotCommands	(_I(NULL,560,0,0))
#define QSW_R560_GripperRotCommands(x)	(_IW(NULL,560,0,0,(int)(x)))
#define QS_R561_Speed	(_I(NULL,561,0,0))
#define QSW_R561_Speed(x)	(_IW(NULL,561,0,0,(int)(x)))
#define QS_R562_Accel	(_I(NULL,562,0,0))
#define QSW_R562_Accel(x)	(_IW(NULL,562,0,0,(int)(x)))
#define QS_R563_Decel	(_I(NULL,563,0,0))
#define QSW_R563_Decel(x)	(_IW(NULL,563,0,0,(int)(x)))
#define QS_R564_Target	(_I(NULL,564,0,0))
#define QSW_R564_Target(x)	(_IW(NULL,564,0,0,(int)(x)))
#define QS_R565_HomeOffset	(_I(NULL,565,0,0))
#define QSW_R565_HomeOffset(x)	(_IW(NULL,565,0,0,(int)(x)))
#define QS_R569_fpos	(_I(NULL,569,0,0))
#define QSW_R569_fpos(x)	(_IW(NULL,569,0,0,(int)(x)))
#define QS_R570_Empty1Commands	(_I(NULL,570,0,0))
#define QSW_R570_Empty1Commands(x)	(_IW(NULL,570,0,0,(int)(x)))
#define QS_R571_Speed	(_I(NULL,571,0,0))
#define QSW_R571_Speed(x)	(_IW(NULL,571,0,0,(int)(x)))
#define QS_R572_Accel	(_I(NULL,572,0,0))
#define QSW_R572_Accel(x)	(_IW(NULL,572,0,0,(int)(x)))
#define QS_R573_Decel	(_I(NULL,573,0,0))
#define QSW_R573_Decel(x)	(_IW(NULL,573,0,0,(int)(x)))
#define QS_R574_Target	(_I(NULL,574,0,0))
#define QSW_R574_Target(x)	(_IW(NULL,574,0,0,(int)(x)))
#define QS_R575_HomeOffset	(_I(NULL,575,0,0))
#define QSW_R575_HomeOffset(x)	(_IW(NULL,575,0,0,(int)(x)))
#define QS_R579_fpos	(_I(NULL,579,0,0))
#define QSW_R579_fpos(x)	(_IW(NULL,579,0,0,(int)(x)))
#define QS_R580_Empty2Commands	(_I(NULL,580,0,0))
#define QSW_R580_Empty2Commands(x)	(_IW(NULL,580,0,0,(int)(x)))
#define QS_R581_Speed	(_I(NULL,581,0,0))
#define QSW_R581_Speed(x)	(_IW(NULL,581,0,0,(int)(x)))
#define QS_R582_Accel	(_I(NULL,582,0,0))
#define QSW_R582_Accel(x)	(_IW(NULL,582,0,0,(int)(x)))
#define QS_R583_Decel	(_I(NULL,583,0,0))
#define QSW_R583_Decel(x)	(_IW(NULL,583,0,0,(int)(x)))
#define QS_R584_Target	(_I(NULL,584,0,0))
#define QSW_R584_Target(x)	(_IW(NULL,584,0,0,(int)(x)))
#define QS_R585_HomeOffset	(_I(NULL,585,0,0))
#define QSW_R585_HomeOffset(x)	(_IW(NULL,585,0,0,(int)(x)))
#define QS_R589_fpos	(_I(NULL,589,0,0))
#define QSW_R589_fpos(x)	(_IW(NULL,589,0,0,(int)(x)))
#define QS_R590_TransferStationCommands	(_I(NULL,590,0,0))
#define QSW_R590_TransferStationCommands(x)	(_IW(NULL,590,0,0,(int)(x)))
#define QS_R591_Speed	(_I(NULL,591,0,0))
#define QSW_R591_Speed(x)	(_IW(NULL,591,0,0,(int)(x)))
#define QS_R592_Accel	(_I(NULL,592,0,0))
#define QSW_R592_Accel(x)	(_IW(NULL,592,0,0,(int)(x)))
#define QS_R593_Decel	(_I(NULL,593,0,0))
#define QSW_R593_Decel(x)	(_IW(NULL,593,0,0,(int)(x)))
#define QS_R594_Target	(_I(NULL,594,0,0))
#define QSW_R594_Target(x)	(_IW(NULL,594,0,0,(int)(x)))
#define QS_R595_HomeOffset	(_I(NULL,595,0,0))
#define QSW_R595_HomeOffset(x)	(_IW(NULL,595,0,0,(int)(x)))
#define QS_R599_fpos	(_I(NULL,599,0,0))
#define QSW_R599_fpos(x)	(_IW(NULL,599,0,0,(int)(x)))
#define QS_R600_Empty3Commands	(_I(NULL,600,0,0))
#define QSW_R600_Empty3Commands(x)	(_IW(NULL,600,0,0,(int)(x)))

// structures

typedef struct {
      int n;
      int offset;
      int param1;
	  int param2;
} QS4_BLOCKACCESS;

#define MAX_OPTIMIZED_BREAKPOINTS 16
typedef struct
{
	int type;  // 0 do not reference, 1 for breakpoint use
	char *line;
} OPTIMIZED_LINE_ENTRY;


typedef struct {
	OPTIMIZED_LINE_ENTRY *currentStep;			// added so can track execution of optimized QB
	OPTIMIZED_LINE_ENTRY *currentLineTable;   // Pointer to table of instructions for breakpoints
	int breakpoints[MAX_OPTIMIZED_BREAKPOINTS];  // breakpoint offsets
	int breakpointMask;			// each bit represents an active breakpoint
	int R36991;
	unsigned int doTTCount;
	unsigned int doTT[32];
	int firstPass;			    // set when first pass of a steps execution
	unsigned long tasktimer;
	unsigned long delaytimer;
	unsigned long timeouttimer;
	unsigned int timeoutBranch;
	int taskPriority;
	TASK *parentTask;
	unsigned char unused[4];  // used to keep structure same size (alignment)
	int taskThread_index;
	void *thrd;
	int waitFunction;	// set to 1 if waiting completion of a function
	char* stringspace[N_ACTIVE_STRINGS];
} QS4INFO;

typedef struct 
{
	int index;
	int threadExecuting;
	int QB_Active;
	int QB_Exited;
	int exitRetry;
	int function;
	int initialized;
	int threadCached;
#ifdef ABSTRACT_INTIME
	QB_TX_THREAD thread;
#else
	TX_THREAD thread;
#endif
	TASK *task;
	int stepStart;
	unsigned char *stack;
	QS4INFO qs4TaskLocal; 
} TASK_THREAD;

typedef struct {
	int regobj;
	int propnum;
	int type; 
	const char* name;
} QS4SYMBOL;

typedef struct {
	int pnum;
	double value;
} IPMPARAM;

//--QS4TABLES--//
double __aiScale[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
double __aiOffset[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
int __aiCT[] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
int __aiEtherCAT[] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
int __aiRS[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
double __aoScale[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
double __aoScaleI[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
double __aoOffset[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
double __aoEtherCAT[] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
short __aoCM[] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };

// globals

short __RUNTICK = 0;						// 'tick' enable
#ifdef ABSTRACT_INTIME
void *__qs4_control_mutex = NULL;
void *__qs4_task_mutex = NULL;
#else
TX_MUTEX __qs4_control_mutex;				// QS4 'tick' mutex
TX_MUTEX __qs4_task_mutex;
#endif
unsigned int evts[96];						// QS4 'Event' info
CTC_FILE files[N_QS4_FILES];				// QS4 open files
RESOURCE_INFO ccResource;
void *ccResourceHandle = NULL;
static int currentTaskPriorityLevel = 0;			// used to disable certain tasks from running
int IBLOCK[QS4C_BLOCKSIZE];
double DBLOCK[QS4C_BLOCKSIZE];

// function decls

int init_QS4();
void uninit_QS4();
RETVAL TEST_IPMs();
void raiseError(TASK* task, int ctc_errno);
int ccCode(void *handle, FILTERPARAMS *params, STDVAL value, RETVAL *status);
void stepDone(TASK *task);
int stepYield(TASK *task);
void lineYield(TASK *task, int lineTableOffset);
void stepCancelOtherTasks(TASK *task);
#ifdef QB_RUNTIME
TASK *CREATETASK(TASK *parentTask, int stepnum);
TASK *CREATEFUNCTION(TASK *parentTask, int stepnum);
#else
TASK *CREATETASK(int stepnum);
#endif
void process_ATABLE(STDVAL value, TASK* task);
int process_CTABLE(STDVAL value, TASK* task);
void process_INIT(TASK* task);
void taskStart(int taskThread_index);
void taskEnd(TASK* task);
#if QB_HDR_VERSION > 100
void pidControl();
void* getQS4ObjectTablePointer(int *size);
#ifdef ABSTRACT_INTIME
int getQS4ObjectIndirect(int write, int objnum, int propnum, int proptype, void *resultVal, void *blockaccess);	// INTIME
#else
int getQS4ObjectIndirect(int write, int objnum, int propnum, int proptype, void *resultVal, QS4_BLOCKACCESS *blockaccess);
#endif
int FOPEN(char* filename, char* mode);
void FCLOSE(int filenumber);
#endif
void __CANCEL_N(TASK* task, int r);
void __CANCEL_1(unsigned int th);
void __ENABLE_EVENT(int evtID, int endis);
void QS4ControlInit();
void processBoard(SlotMem_AIN *info);
void processTick();
#ifndef ABSTRACT_INTIME
int __main();
#endif
int _BR(TASK* task, int r, int x, int y);
void _BW(TASK* task, int r, int x, int y, int value);
int _I(TASK* task, int r, int x, int y);
void _IW(TASK* task, int r, int x, int y, int value);
int waitFunction(TASK *task);
static int _QB_Shutting_Down = 0;	// set to 1 during shutdown attempt

#ifndef ABSTRACT_INTIME
// QS4 PREAMBLE CODE
int main (void) { __main(); return init_QS4(); }
#else
void _systemCleanUp()
{
}
void __qb_main()
{
}
#ifdef ABSTRACT_INTIME
int qb_instance;
int qb_thread_count;
#endif
int qb_main(void) 
{	
//	printf("q_main called.\r\n");
#ifdef ABSTRACT_INTIME
	qb_instance = 0;
	qb_thread_count = 0;
#endif
	__qb_main(); 
	return init_QS4(); 
}
#endif
#ifdef QB_RUNTIME
void taskloop(unsigned long parameter);
#ifdef ABSTRACT_INTIME
#define THREAD_PRIORITY_QB_TASK 254
#else
#define THREAD_PRIORITY_QB_TASK 12
#endif
#define MAX_TASK_THREADS 96
//#define MAX_STACK_SIZE 8192
#ifdef ABSTRACT_INTIME
#define MAX_THREAD_STACK_SIZE 48000
#define MAX_QB_STACK_SIZE 12000
#else
#define MAX_THREAD_STACK_SIZE 12000
#define MAX_QB_STACK_SIZE 12000
#endif
TASK_THREAD TASK_THREADS[MAX_TASK_THREADS];

int taskLoop(SYSMODE state) 
{
	// start the first task
	TASK *t = CREATETASK(NULL, 1);
	// Start the thread
	_tx_thread_resume(&TASK_THREADS[Q4T(t)->taskThread_index].thread);
	return 0; 
}
#else
int taskLoop(SYSMODE state) 
{ 
	return 0; 
}
#endif

// Initial thread entry point for QB
void taskMonitor(unsigned long param)
{
TASK *task;
TASK_THREAD *thrd;
unsigned long parameter;
char name[20];

#ifdef ABSTRACT_INTIME
CTC_THREAD *ctc_thrd = (CTC_THREAD *)param;
param = (unsigned long)ctc_thrd->parameterlist;
#endif
	parameter = param;	thrd = &TASK_THREADS[parameter];
	thrd->threadExecuting = 1;		// notify we are running
	thrd->QB_Active = 1;
	thrd->QB_Exited = 0;
	thrd->exitRetry = 0;
//	printf("taskMonitor invoked.\r\n");
#ifdef ABSTRACT_INTIME
	PREEMPTION_TASK_DISABLE;
	sprintf(name,"QB_%04d",qb_instance);
	qb_instance++;
	qb_thread_count++;
	if (qb_instance == 99999)
	{
		qb_instance = 0;
	}
	PREEMPTION_TASK_RESTORE;
	CatalogRtHandle(NULL_RTHANDLE, GetRtThreadHandles(THIS_THREAD), name);
#endif
	while(thrd->QB_Active)		// QB_Active cleared when shutting down
	{
		task = thrd->task;
		if (task == NULL)
		{
			break;  // suspend probably didn't work...
		}
		// Branch to start of requested step
		if (thrd->function)
		{
			// This is a function call
			while(thrd->initialized == 0)
			{
				taskSetBranch(task,-1); // Yield
			};
		}
		if (_QB_Shutting_Down)
		{
//			printf("taskMonitor shutdown break 1.\r\n");
			break;
		}
//		printf("invoke taskloop.\r\n");
		taskloop(parameter);
//		printf("return from taskloop.\r\n");
		if (_QB_Shutting_Down)
		{
//			printf("taskMonitor shutdown break 2.\r\n");
			break;
		}
//		printf("taskMonitor no shutdown.\r\n");
		// Disable preemption
		PREEMPTION_TASK_DISABLE;

		thrd->initialized = 0;
		thrd->function = 0;
#ifndef ABSTRACT_INTIME
		char *foo = "CACHED Thread";
		TASK_THREADS[parameter].thread.tx_thread_name = foo;
#endif
		thrd->threadExecuting = 0;
		thrd->threadCached = 2;
		_tx_thread_suspend(&thrd->thread);
		// Enable preemption
		thrd->threadExecuting = 1;		// notify we are running
		thrd->threadCached = 1;
		PREEMPTION_TASK_RESTORE;

		if (_QB_Shutting_Down)
		{
			break;
		}

		// This task is done
	}
//	printf("taskMonitor disable pre.\r\n");
	PREEMPTION_TASK_DISABLE;
#ifdef ABSTRACT_INTIME
	qb_thread_count--;
#endif
	thrd->threadExecuting = 0;		// notify we are running
	thrd->QB_Active = 0;
	thrd->QB_Exited = 1;
	PREEMPTION_TASK_RESTORE;
//	printf("taskMonitor exiting.\r\n");
#ifdef ABSTRACT_INTIME
	UncatalogRtHandle(NULL_RTHANDLE, name);
#endif

}

void userCleanUp() 
{ 

//	printf("enter userCleanUp().\r\n");
	_QB_Shutting_Down = 1;

	uninit_QS4(); 
	// Wait till all threads stop
#ifdef ABSTRACT_INTIME
	int loopcnt = 100;
	while(qb_thread_count)
	{
		_tx_thread_sleep(100);
		loopcnt--;
		if (loopcnt == 0)
		{
			printf("userCleanUp timeout.\r\n");
			break;
		}
	}
#endif
	_QB_Shutting_Down = 0;  
//	printf("exit userCleanUp().\r\n");
} 

int init_QS4() {
	int i;
	RETVAL result;
	_QB_Shutting_Down = 0;  // Clear just in case reloading...
	for (i = 0;i!=MAX_AXIS;i++)
	{
		__axisMap[i] = i+1;  // Generate axis variable mapping access
	}
//	printf("enter init_QS4().\r\n");
	memset( &TASK_THREADS[0], 0, sizeof(TASK_THREADS));  // clear task structure prior to running
#ifdef ABSTRACT_INTIME
	__qs4_control_mutex = _txe_mutex_create("QS4_CONTROL_MUTEX", TX_NO_INHERIT);
	__qs4_task_mutex = _txe_mutex_create("QS4_CONTROL_MUTEX", TX_NO_INHERIT);
#else
	tx_mutex_create(&__qs4_control_mutex, "QS4_CONTROL_MUTEX", TX_NO_INHERIT);
	tx_mutex_create(&__qs4_task_mutex, "QS4_CONTROL_MUTEX", TX_NO_INHERIT);
#endif
	currentTaskPriorityLevel = 0;
	ccResource.type = RESOURCE_REGISTER;
	ccResource.start = 36990;
	ccResource.end = 36992;
	ccResource.mode = RESOURCE_READ | RESOURCE_WRITE;
	ccResourceHandle = addResourceFilter(&ccResource, ccCode);
	for (i=0; i<N_QS4_FILES; i++) files[i] = (CTC_FILE)-1;
	__qb_initialized = 1;
	result = TEST_IPMs();
	if ( result == SUCCESS)
	{
		return 0;
	}
//	printf("init_QS4(), TEST_IPMs() failed.\r\n");
	// motor boards failed so fault
	uninit_QS4();
	raiseError(NULL, result);
	return -1;
}
void uninit_QS4() {
	int i;
	TASK *tskptr;
//	printf("enter uninit_QS4().\r\n");
	if (__qb_initialized == 0)
	{
		return;  // we are being invoked prior to initialization
	}
	__qb_initialized = 0;

	if (_QB_Shutting_Down)
	{
//		printf("uninit_QS4() shutdown threads.\r\n");
		// must shutdown the threads...
		for (i = 0;i!=MAX_TASK_THREADS;i++)
		{
			// now must yield and check for all done...
			currentTaskPriorityLevel = 0;
			if (TASK_THREADS[i].threadCached == 0)
			{
				continue;	// Nothing to process
			}
			if (TASK_THREADS[i].QB_Exited == 1)
			{
#ifndef ABSTRACT_INTIME  // INTIME will set this when thread is done so no need for below
				// Have exited monitor but thread is probably in COMPLETED or TERMINATED state
				if (TASK_THREADS[i].thread.tx_thread_id == THREADX_UNIQUE_ID)
				{
					_tx_thread_create(&TASK_THREADS[i].thread, NULL, NULL, 0, NULL, 1, 
							THREAD_PRIORITY_QB_TASK,THREAD_PRIORITY_QB_TASK, TX_NO_TIME_SLICE, TX_AUTO_START);	// Command to terminate thread
					_tx_thread_create(&TASK_THREADS[i].thread, NULL, NULL, 0, NULL, 2, 
							THREAD_PRIORITY_QB_TASK,THREAD_PRIORITY_QB_TASK, TX_NO_TIME_SLICE, TX_AUTO_START);	// Command to delete thread

					if (TASK_THREADS[i].stack != NULL)
					{
						free(TASK_THREADS[i].stack);
						TASK_THREADS[i].stack = NULL;
					}

					// Thread is killed and ready to recreate
					TASK_THREADS[i].thread.tx_thread_id = 0;
					TASK_THREADS[i].threadCached = 0;
					TASK_THREADS[i].QB_Exited = 0;
					TASK_THREADS[i].QB_Active = 0;
					TASK_THREADS[i].threadExecuting = 0;		// notify we are running
				}
				i = 0;
#endif
				continue;	// Nothing to process
			}
#if 0
			if (TASK_THREADS[i].exitRetry > 3)
			{
				// Force the shutdown
				if (TASK_THREADS[i].thread.tx_thread_id == THREADX_UNIQUE_ID)
				{
					_tx_thread_create(&TASK_THREADS[i].thread, NULL, NULL, 0, NULL, 1, 
							THREAD_PRIORITY_QB_TASK,THREAD_PRIORITY_QB_TASK, TX_NO_TIME_SLICE, TX_AUTO_START);	// Command to terminate thread
//					tx_thread_sleep(2);
					_tx_thread_create(&TASK_THREADS[i].thread, NULL, NULL, 0, NULL, 2, 
							THREAD_PRIORITY_QB_TASK,THREAD_PRIORITY_QB_TASK, TX_NO_TIME_SLICE, TX_AUTO_START);	// Command to delete thread

					// Thread is killed and ready to recreate
					if (TASK_THREADS[i].stack != NULL)
					{
						free(TASK_THREADS[i].stack);
						TASK_THREADS[i].stack = NULL;
					}
				}
				TASK_THREADS[i].thread.tx_thread_id = 0;
				TASK_THREADS[i].threadCached = 0;
				TASK_THREADS[i].QB_Exited = 0;
			}
#endif
			else if (TASK_THREADS[i].QB_Active)
			{
				// Thread is executing so now must get it to stop running.
				TASK_THREADS[i].QB_Active = 0;	// Have it stop running
				tskptr = TASK_THREADS[i].task;
				if ((tskptr == (TASK *)NULL) || (tskptr == (TASK *)0xffffffff))
				{
					TASK_THREADS[i].task = NULL;
					// QB is not running so probably suspended
#if 0
					if (TASK_THREADS[i].threadExecuting)
					{
						// Executing but task pointer is null, this should not happen???
						if (TASK_THREADS[i].thread.tx_thread_id == THREADX_UNIQUE_ID)
						{
							_tx_thread_create(&TASK_THREADS[i].thread, NULL, NULL, 0, NULL, 1, 
									THREAD_PRIORITY_QB_TASK,THREAD_PRIORITY_QB_TASK, TX_NO_TIME_SLICE, TX_AUTO_START);	// Command to terminate thread
//							tx_thread_sleep(2);
							_tx_thread_create(&TASK_THREADS[i].thread, NULL, NULL, 0, NULL, 2, 
									THREAD_PRIORITY_QB_TASK,THREAD_PRIORITY_QB_TASK, TX_NO_TIME_SLICE, TX_AUTO_START);	// Command to delete thread

							// Thread is killed and ready to recreate
						}
						if (TASK_THREADS[i].stack != NULL)
						{
							free(TASK_THREADS[i].stack);
							TASK_THREADS[i].stack = NULL;
						}
						// Thread is killed and ready to recreate
						TASK_THREADS[i].thread.tx_thread_id = 0;
						TASK_THREADS[i].threadCached = 0;
						TASK_THREADS[i].QB_Exited = 0;
						TASK_THREADS[i].QB_Active = 0;
						TASK_THREADS[i].threadExecuting = 0;		// notify we are running
					}
					else
#endif
					{
						// Thread is suspended
						TASK_THREADS[i].exitRetry++;
#ifdef ABSTRACT_INTIME
							_tx_thread_resume(&TASK_THREADS[i].thread);
#else
						if (TASK_THREADS[i].thread.tx_thread_id == THREADX_UNIQUE_ID)
						{
							_tx_thread_resume(&TASK_THREADS[i].thread);
						}
						else
						{
							// Thread is killed since does not exist or was corrupted
							TASK_THREADS[i].thread.tx_thread_id = 0;
							TASK_THREADS[i].QB_Exited = 0;
							TASK_THREADS[i].threadCached = 0;
							TASK_THREADS[i].QB_Active = 0;
							TASK_THREADS[i].threadExecuting = 0;		// notify we are running
						}
#endif

					}
#ifdef ABSTRACT_INTIME
					_tx_thread_sleep(50);
#else
					tx_thread_sleep(50);
#endif
					i = 0;
					continue;
				}
				else
				{
					// Program is running
					if (tskptr->state != TASK_UNUSED)
					{
						tskptr->state = TASK_DONE;		// Request it to shutdown
						if (Q4T(tskptr))
						{
							Q4T(tskptr)->taskPriority = 0;   // must let everyone execute to kill
						}
#ifdef ABSTRACT_INTIME
							_tx_thread_resume(&TASK_THREADS[i].thread);
#else
						if (TASK_THREADS[i].thread.tx_thread_id == THREADX_UNIQUE_ID)
						{
							// Just in case it is stuck
							_tx_thread_resume(&TASK_THREADS[i].thread);
						}
#endif
#ifdef ABSTRACT_INTIME
						_tx_thread_sleep(50);
#else
						tx_thread_sleep(50);
#endif
						i = 0;
					}
				}
			}
			else if (TASK_THREADS[i].threadCached)
			{
#ifndef ABSTRACT_INTIME
				// There is a valid thread here
				if (TASK_THREADS[i].thread.tx_thread_id == THREADX_UNIQUE_ID)
				{
					_tx_thread_create(&TASK_THREADS[i].thread, NULL, NULL, 0, NULL, 1, 
							THREAD_PRIORITY_QB_TASK,THREAD_PRIORITY_QB_TASK, TX_NO_TIME_SLICE, TX_AUTO_START);	// Command to terminate thread
					_tx_thread_create(&TASK_THREADS[i].thread, NULL, NULL, 0, NULL, 2, 
							THREAD_PRIORITY_QB_TASK,THREAD_PRIORITY_QB_TASK, TX_NO_TIME_SLICE, TX_AUTO_START);	// Command to delete thread

					// Thread is killed and ready to recreate
					TASK_THREADS[i].thread.tx_thread_id = 0;
					if (TASK_THREADS[i].stack != NULL)
					{
						free(TASK_THREADS[i].stack);
						TASK_THREADS[i].stack = NULL;
					}
				}
#endif
				// Thread is killed and ready to recreate
				TASK_THREADS[i].thread.tx_thread_id = 0;
				TASK_THREADS[i].threadCached = 0;
				TASK_THREADS[i].QB_Exited = 0;
				TASK_THREADS[i].QB_Active = 0;
				TASK_THREADS[i].threadExecuting = 0;		// notify we are running
			}
		}
	}
	// now must yield and check for all done...
	currentTaskPriorityLevel = 0;
//	logEventPlus(EVENT_DEBUG_2, "wait for TASK_UNUSED", 0);
	logEvent(EVENT_DEBUG,LOG_QB_APPLICATION);

	if (ccResourceHandle)
	{
		removeResourceFilter(ccResourceHandle);
		for (i=0; i<N_QS4_FILES; i++) {
			if (files[i] != (CTC_FILE)-1)
				CTC_fclose(files[i]);
		}
	}
	__RUNTICK = 0;
#ifdef ABSTRACT_INTIME
	_tx_thread_sleep(350);
	
	if (__qs4_control_mutex)
	{
		_txe_mutex_delete(__qs4_control_mutex);
		__qs4_control_mutex = NULL;
	}
	if (__qs4_task_mutex)
	{
		_txe_mutex_delete(__qs4_task_mutex);
		__qs4_task_mutex = NULL;
	}
#else
	tx_thread_sleep(350);
	tx_mutex_delete(&__qs4_control_mutex);
	tx_mutex_delete(&__qs4_task_mutex);
#endif
	logEvent(EVENT_DEBUG,LOG_QB_APPLICATION+2);
//	printf("exit uninit_QS4().\r\n");

}

int FOPEN(char* filename, char* mode) {
	int i;
	CTC_FILE file;
	for (i=0; i<N_QS4_FILES; i++) {
		if (files[i] == (CTC_FILE)-1) {
			file = CTC_fopen(filename, mode);
			if (file == NULL) return -1;
			files[i] = file;
			return i;
		}
	}
	return -1;
}

void FCLOSE(int filenumber) {
	if (filenumber < 0) return;
	if (filenumber >= N_QS4_FILES) return;
	if (files[filenumber] == (CTC_FILE)-1) return;
	CTC_fclose(files[filenumber]);
	files[filenumber] = (CTC_FILE)-1;
}

void taskStart(int taskThread_index) {
	TASK *task;
#ifdef QB_RUNTIME
extern OPTIMIZED_LINE_ENTRY currentLine[];
#endif
//	task->qs4TaskLocal = malloc(sizeof(QS4INFO));
//	if (task->qs4TaskLocal == NULL)
//	{
//		return;
//	}
	// **** INVOKED with PREEMPTION disabled
	task = TASK_THREADS[taskThread_index].task;
	task->qs4TaskLocal = &TASK_THREADS[taskThread_index].qs4TaskLocal;
	memset(task->qs4TaskLocal, 0, sizeof(QS4INFO));  // clear it...
	Q4T(task)->taskThread_index = taskThread_index;		// link back to TASK_THREADS used
	Q4T(task)->thrd = &TASK_THREADS[taskThread_index];
	Q4T(task)->currentLineTable = currentLine;  // table for breakpoints
	Q4T(task)->tasktimer = systemTics();
	Q4T(task)->taskPriority = 0;  // ensure step is not locked
	int i;
	for (i=0; i<N_ACTIVE_STRINGS; i++)
	{
		Q4T(task)->stringspace[i] = (char*)malloc(VARIANT_MAX_STRING+1);
	}
}

void taskEnd(TASK* task) {
//	int i;
#if 0
    if (Q4T(task))
	{
		Q4T(task)->thrd = NULL;
		for (i=0; i<N_ACTIVE_STRINGS; i++)
		{
			if (Q4T(task)->stringspace[i])
			{
				free(Q4T(task)->stringspace[i]);
				Q4T(task)->stringspace[i] = NULL;
			}
		}
//		free(task->qs4TaskLocal);
	}
//	task->state = TASK_UNUSED;
	task->qs4TaskLocal = NULL;
#endif
//	logEventPlus(EVENT_DEBUG_2, "taskEnd", 0);
}

int waitFunction(TASK *task)
{
	// nonzero result causes branch (success to test)
	if (Q4T(task) == NULL)
	{
		return 0;
	}
	return !Q4T(task)->waitFunction & 0x0001;
}

int doTTDone(TASK* task) {
	int i;
	if (Q4T(task) == NULL)
	{
		return 0;
	}
	for (i=0; i<(int)(Q4T(task)->doTTCount); i++) {
		TASK* t = getTaskFromHandle(Q4T(task)->doTT[i]);
		if (t == NULL) continue;
		if (t->state == TASK_UNUSED) continue;
		return 0;
	}
	return 1;
}

int ccCode(void *handle, FILTERPARAMS *params, STDVAL value, RETVAL *status) {
	switch(params->resourceNum) {
		case 36990:
			if (params->mode == RESOURCE_WRITE) process_ATABLE(value, ((REGVINFO*)(params->option))->task);
			if (params->mode == RESOURCE_READ) { value = 1; }
			break;
		case 36991:
			if (params->mode == RESOURCE_READ) { value = process_CTABLE( ((QS4INFO*)(((REGVINFO*)(params->option))->task)->qs4TaskLocal)->R36991, ((REGVINFO*)(params->option))->task); break; }
			if (params->mode == RESOURCE_WRITE) { ((QS4INFO*)(((REGVINFO*)(params->option))->task)->qs4TaskLocal)->R36991 = value; break; }
			break;
		case 36992:
			value = -1;
			break;
	}
	return value;
}

void stepDone(TASK *task)
{
	int i;
	int state;
	// Disable preemption
	PREEMPTION_TASK_DISABLE;
	state = task->state;
	if ((state == TASK_SS_RUN) || (state == TASK_SS_STEP) || (state == TASK_LL_RUN) || (state == TASK_LL_STEP) || (state == TASK_LL_BREAKPOINT))
	{

		task->state = TASK_RUNSTEP;
	}
	task->state = 16;  // TASK_STOPPING, clear local registers
	killTask(task);  // kill the task and request our 'taskEnd' function get invoked...
    if (Q4T(task))
	{
		for (i=0; i<N_ACTIVE_STRINGS; i++)
		{
			if (Q4T(task)->stringspace[i])
			{
				free(Q4T(task)->stringspace[i]);
				Q4T(task)->stringspace[i] = NULL;
			}
		}
		// We are done with this entry
		i = Q4T(task)->taskThread_index;
		// See if parentTask pointer is valid
		if (Q4T(task)->parentTask)
		{
			// Tell parent do not have to wait any longer
			Q4T(Q4T(task)->parentTask)->waitFunction = 0;
			Q4T(task)->parentTask = NULL;  // ensure cleared, KRH.
		}
		else
		{
			// No parent task?
		}
	}
	else
	{
		// Error, this should never happen
		i = -1;
	}

	int j;
	// Must remove our reference from any child tasks
	for (j = 0;j!=MAX_TASK_THREADS;j++)
	{
		if (i == j)
		{
			continue;  //skip ourselves
		}
		if (TASK_THREADS[j].qs4TaskLocal.parentTask == task)
		{
			TASK_THREADS[j].qs4TaskLocal.parentTask = NULL;  // remove entry of parent task since it is DONE
		}
	}
	task->qs4TaskLocal = NULL;
	task->taskHandle = 0;
	task->userCStorage = NULL;	    
	task->state = TASK_UNUSED;
	if (i>=0)
	{
		// Kill ourselves
		TASK_THREADS[i].task = NULL;
	}
	// Disable preemption
	PREEMPTION_TASK_RESTORE;
}

int stepYield(TASK *task)
{

	while (1)
	{
#ifdef ABSTRACT_INTIME
		// Release COMM mutex
//		taskSetBranch(task,-3);
#endif
		if (_QB_Shutting_Down)
		{
			task->state = TASK_DONE;
			stepDone(task);
			return 1;	// exit
		}
		switch(task->state)
		{
			case TASK_LL_STEP:
			case TASK_LL_RUN:
			case TASK_LL_BREAKPOINT:  // breakpoint reached
				return 0;
			case TASK_STOPPED:
				while (task->state == TASK_STOPPED)
				{
					taskSetBranch(task,-1);	// stubbed to yield thread so did not need a new support library with this release...
				}
				if ((task->state == TASK_SS_RUN) || (task->state == TASK_RUNSTEP) || (task->state == TASK_LL_RUN))
				{
#ifdef ABSTRACT_INTIME
					if (task->state == TASK_RUNSTEP)
					{
						// Acquire COMM mutex
//						taskSetBranch(task,-2);
					}
#endif
					return 0;	// execute a step
				}
				break;
			case TASK_SS_STEP:
			case TASK_SS_RUN:
				task->state = TASK_SS_STEP;   // in single step mode
				while (task->state == TASK_SS_STEP)
				{
					taskSetBranch(task,-1);	// stubbed to yield thread so did not need a new support library with this release...
				}
				if ((task->state == TASK_SS_RUN) || (task->state == TASK_RUNSTEP) || (task->state == TASK_LL_RUN))
				{
					return 0;	// execute a step
				}
				break;
			case TASK_DONE:
				// we are to terminate this thread
				stepDone(task);
				return 1;	// request exiting the thread
			case 16:  // TASK_STOPPING
				// Should never occur
				return 1;
			default:
				if (Q4T(task)->taskPriority == MAX_QB_THREADPRIORITY)
				{
					// If at maximum priority then do not yield
#ifdef ABSTRACT_INTIME
					// Acquire COMM mutex
//					taskSetBranch(task,-2);
#endif
					return 0;
				}
				taskSetBranch(task,-1);  // yield for comm and other threads to run
				// hang until our priority is such that we can run
				while (Q4T(task)->taskPriority < currentTaskPriorityLevel) 
				{
					taskSetBranch(task,-1);	// stubbed to yield thread so did not need a new support library with this release...
				}
				if (task->state == TASK_DONE)
				{
					stepDone(task);
					return 1;
				}
#ifdef ABSTRACT_INTIME
				// Acquire COMM mutex
//				taskSetBranch(task,-2);
#endif
				return 0;
		}
	}
}

// invoked between lines
void lineYield(TASK *task, int lineTableOffset)
{
//	int cyclenum;
	int q, mask;
	int loop = 1;
	while(loop)
	{
		switch(task->state)
		{
			case TASK_LL_RUN:
			case TASK_LL_STEP:
			case TASK_LL_BREAKPOINT:  // hit breakpoint
				if (task->state != TASK_LL_BREAKPOINT)  // keep it so user can see we hit a breakpoint until cleared
				{
					task->state = TASK_LL_STEP;   // in single step mode
				}
				while ((task->state == TASK_LL_STEP) || (task->state == TASK_LL_BREAKPOINT))
				{
					taskSetBranch(task,-1);	// stubbed to yield thread so did not need a new support library with this release...
				}
				loop = 0;  // exit
				break;
			default:
				// check for breakpoints
				if (Q4T(task)->breakpointMask)
				{
					// check for breakpoints
					for (q = 0;q!= MAX_OPTIMIZED_BREAKPOINTS;q++)
					{
						mask = 1<<q;
						if (Q4T(task)->breakpointMask & mask)
						{
							// found a breakpoint
							if (Q4T(task)->breakpoints[q] == lineTableOffset)
							{
								// have a match so stop execution
								task->state = TASK_LL_BREAKPOINT;
								break;
							}
						}
					}
					if (q == MAX_OPTIMIZED_BREAKPOINTS)
					{
						loop = 0;  // done, no match...
					}
				}
				else
				{
					loop = 0;  // exit
				}
				break;
		}
	}
}


void ITOA(int val, char *buf) {
	char *p,*first;

	p = buf;

	if (val < 0) { *p++ = '-'; val = -val; }

	first = p;
	do { *p++ = (char) ((val % 10) + '0'); val /= 10; } while (val > 0);
	*p-- = '\0';
  
	do { char temp = *p; *p = *first; *first = temp; p--; first++; } while (first < p);
}

int _IIR(int r) { return (r < 36001) || (r > 36900); }
int _IAI(int r) { return (r >= 8501) && (r <= 8756); }
int _IAO(int r) { return (r >= 8001) && (r <= 8256); }

double readAI(int r) {
	INT32 result = 0;
	if (__aiCT[r-8501] < 0) return 0.0;
	if (__aiEtherCAT[r-8501] == 1)
	{
		// EtherCAT
		regRead((UINT16)r, &result);
		return ((double)result) * __aiScale[r-8501] + __aiOffset[r-8501];
	}
	switch (__aiRS[r-8501]) {
		case 0:  // RAW, EtherCAT
			regRead((UINT16)r, &result);
			return ((double)result) * __aiScale[r-8501] + __aiOffset[r-8501];
		case 1:  // NA
			regRead((UINT16)r, &result);
			return ((double)result) * __aiScale[r-8501] * 0.000001 + __aiOffset[r-8501];
		case 6:
			regRead((UINT16)r, &result);
			result -= 4000;
			return ((double)result) * __aiScale[r-8501] * 0.0000625 + __aiOffset[r-8501];
		case 11:
		case 12:
		case 13:
			regRead((UINT16)r, &result);
			return ((double)result) * __aiScale[r-8501] * 0.1 + __aiOffset[r-8501];
	}
	return 0.0;
};

double readAO(int r) {
	INT32 result = 0;
	if (__aoCM[r-8001] < 0) return 0;
	if (__aoEtherCAT[r-8001] == 1)
	{
		// EtherCAT
		regRead((UINT16)r, &result);
		return ((double)result) * __aoScaleI[r-8001] + __aoOffset[r-8001];
	}
	if (__aoCM[r-8001]) {
		// 5300
		regRead((UINT16)r, &result);
		result -= 4000;
		return ((double)result) * __aoScaleI[r-8001] * 0.0000625 + __aoOffset[r-8001];
	}
	else 
	{
		// 5300
		regRead((UINT16)r, &result);
		return ((double)result) * __aoScaleI[r-8001] * 0.000001 + __aoOffset[r-8001];
	}
}

void writeAO(int r, double v) {
	if (__aoCM[r-8001] < 0) return;
	if (__aoEtherCAT[r-8001] == 1)
	{
		// EtherCAT
		v -= __aoOffset[r-8001];
		v *= __aoScale[r-8001];
		regWrite((UINT16)r, (int)v);
	}
	else if (__aoCM[r-8001]) {
		// 5300
		v -= __aoOffset[r-8001];
		v *= __aoScale[r-8001] * 16000.0;
		regWrite((UINT16)r, ((int)v) + 4000);
	}
	else 
	{
		// 5300
		v -= __aoOffset[r-8001];
		v *= __aoScale[r-8001] * 1000000.0;
		regWrite((UINT16)r, (int)v);
	}
}

int readCAP() {
#ifdef LEGACY_CAPTURE
	INT32 result = 0;
	regRead((UINT16)(QS4_CAP_START), &result);
	return result;
#else
	return capStart;
#endif
}

int readCAPDEPTH() {
#ifdef LEGACY_CAPTURE
	INT32 result = 0;
	regRead((UINT16)(QS4_CAP_DEPTH), &result);
	return result;
#else
	return capDepth;
#endif
}

void writeCAP(int value) {
#ifdef LEGACY_CAPTURE
	regWrite((UINT16)(QS4_CAP_START), value);
#else
	capStart = value;
#endif
}

void writeCAPDEPTH(int value) {
#ifdef LEGACY_CAPTURE
	regWrite((UINT16)(QS4_CAP_DEPTH), value);
#else
	capDepth = value;
#endif
}

int RSYSVAR(TASK* task, int r, int index) {
	INT32 result = 0;
	switch (r) {
		case -1: return (int)(systemTics() - Q4T(task)->tasktimer);
		case -2: return (int)(systemTics() - Q4T(task)->delaytimer);
		case -3: { regRead((UINT16)(index+2000), &result); return result; }
		case -4: { regRead((UINT16)(index+1000), &result); return result; }
		case -5: { regRead((UINT16)(index), &result); return result; }
		case -6: { return readCAP(); }
		case -7: { return _BR(NULL, 36823, index, 0) > 0; }
		case -8: { return _I(NULL, 36824, index, 0); }
		case -9: return (int)(systemTics() - Q4T(task)->timeouttimer);   // KRH added
		case -10: return currentTaskPriorityLevel;   // KRH added
		case -11: return Q4T(task)->taskPriority;   // KRH added
		case -12: // Task handle
			if (Q4T(task)) 
			{
				if (TASK_THREADS[Q4T(task)->taskThread_index].task)
				{
					return TASK_THREADS[Q4T(task)->taskThread_index].task->taskHandle; 
				}
				else
				{
					return 0;
				}
			} 
			else 
			{
				return 0;
			}   // KRH added
		case -13:  // $AXISMAP
			if ((index > MAX_AXIS) || (index < 1))
			{
				return -1;
			}
			return __axisMap[index-1];
		default: return 0;
	}
}

void WSYSVAR(TASK* task, int r, int index, int value) {
	INT32 result = 0;
	switch (r) {
		case -1: Q4T(task)->tasktimer = systemTics() + (unsigned long)value; break;
		case -2: Q4T(task)->delaytimer = systemTics() + (unsigned long)value; break;
		case -3: break;
		case -4: { regWrite((UINT16)(index+1000), value!=0); break; }
		case -5: { regWrite((UINT16)(index), value); break; }
		case -6: { result = readCAP(); if (result == CAPTURE_WAITING && value != 0) writeCAP(CAPTURE_INIT); break; }
		case -7: { _BW(NULL, 36823, index, 0, value); break; }
		case -8: { if (value < 0 || value > 255) break; _IW(NULL, 36824, index, 0, value); break; }
		case -9: Q4T(task)->timeouttimer = systemTics() + (unsigned long)value; break;  // KRH added
		case -10: 
			// we are changing priority level allowed to run
			if ((value >= 0) && (value <= MAX_QB_THREADPRIORITY))
			{
				currentTaskPriorityLevel = value;
			}
			break;   // KRH added
		case -11: 
			if (value == -1) 
			{ 
				taskSetBranch(task,-1);  // Yield to let other tasks and communications run
			}
			else
			{
				if ((value >= 0) && (value <= MAX_QB_THREADPRIORITY))
				{
					Q4T(task)->taskPriority = value;  // KRH added
				}
			}
			break;
		case -13:  // $AXISMAP
			if ((index > MAX_AXIS) || (index < 1))
			{
				return -1;
			}
			__axisMap[index-1] = value;
			break;

		default: break;
	}
}

// Create a task and spawn it...
TASK* CREATETASK(TASK *parentTask, int stepnum) {
TASK *task;
int i;
TASK *tskptr;
int state;
//int tasknum;

	if (_QB_Shutting_Down)
	{
		return NULL;
	}
	// Disable preemption
	PREEMPTION_TASK_DISABLE;
#ifdef ABSTRACT_INTIME
	_txe_mutex_get(__qs4_task_mutex, TX_WAIT_FOREVER);
#else
	_txe_mutex_get(&__qs4_task_mutex, TX_WAIT_FOREVER);
#endif
	// First see if there is a cached thread
	for (i = 0;i!=MAX_TASK_THREADS;i++)
	{
		if ((TASK_THREADS[i].QB_Active) && (TASK_THREADS[i].threadCached == 2) && (TASK_THREADS[i].threadExecuting == 0) && (TASK_THREADS[i].task == NULL))
		{
#ifdef ABSTRACT_INTIME
			if (taskSetBranch(&TASK_THREADS[i].thread, -4) != 0)  // Make sure it is self suspended!  Old runtime will always return 0 if not implemented.
			{
				continue;  // Can not use if not suspended yet
			}
#endif
			tskptr = TASK_THREADS[i].task;
			if (tskptr == NULL)
			{
				TASK_THREADS[i].index = i;
				TASK_THREADS[i].task = (TASK *)0xffffffff;	// block it from use
				break;
			}
		}
	}
	// See if found an active slot
	if (i == MAX_TASK_THREADS)
	{
		// No active slot so will have to create a thread

		// find available task slot
		for (i = 0;i!=MAX_TASK_THREADS;i++)
		{
			if (TASK_THREADS[i].threadCached == 0)
			{
				tskptr = TASK_THREADS[i].task;
				if (tskptr == NULL)
				{
					TASK_THREADS[i].threadCached = 1;	// lock it for ourselves
					TASK_THREADS[i].index = i;
					TASK_THREADS[i].task = (TASK *)0xffffffff;	// block it from use
					break;
				}
			}
		}
	}

	if (i == MAX_TASK_THREADS)
	{
#ifdef ABSTRACT_INTIME
	_txe_mutex_put(__qs4_task_mutex);
#else
	_txe_mutex_put(&__qs4_task_mutex);
#endif
		// no slots available
		PREEMPTION_TASK_RESTORE;
		return NULL;
	}

#ifndef ABSTRACT_INTIME
	// Initialize the task structure
	if (TASK_THREADS[i].stack == NULL)
	{
		TASK_THREADS[i].stack = (unsigned char *)malloc(MAX_QB_STACK_SIZE);
		if (TASK_THREADS[i].stack == NULL)
		{
			TASK_THREADS[i].task = NULL;
			TASK_THREADS[i].threadCached = 0;
			_txe_mutex_put(&__qs4_task_mutex);
			PREEMPTION_TASK_RESTORE;
			return NULL;
		}
	}
#endif

	task = createTask(stepnum-1);
	if (task == NULL)
	{
		// no more available
#ifndef ABSTRACT_INTIME
		if (TASK_THREADS[i].stack != NULL)
		{
			free(TASK_THREADS[i].stack);
		}
#endif
		TASK_THREADS[i].stack = NULL;
		TASK_THREADS[i].task = NULL;
		TASK_THREADS[i].threadCached = 0;
#ifdef ABSTRACT_INTIME
	_txe_mutex_put(__qs4_task_mutex);
#else
	_txe_mutex_put(&__qs4_task_mutex);
#endif
		PREEMPTION_TASK_RESTORE;
		return NULL;
	}
	TASK_THREADS[i].stepStart = stepnum;
	TASK_THREADS[i].task = task;

	taskStart(i);

	if (Q4T(task) == NULL)
	{
		// This is bad!!!
		TASK_THREADS[i].task = NULL;
		TASK_THREADS[i].threadCached = 0;
#ifdef ABSTRACT_INTIME
		_txe_mutex_put(__qs4_task_mutex);
#else
		_txe_mutex_put(&__qs4_task_mutex);
#endif
		PREEMPTION_TASK_RESTORE;
		return NULL;
	}
	Q4T(task)->parentTask = parentTask;  // our parent task so can access their local variables
	if (parentTask != NULL)
	{
		state = parentTask->state;
		if ((state == TASK_STOPPED) || (state == TASK_SS_RUN) || (state == TASK_SS_STEP) || (state == TASK_LL_RUN) || (state == TASK_LL_STEP) || (state == TASK_LL_BREAKPOINT))
		{
			task->state = parentTask->state;   // If single stepping we do not want a function or begin task thread to run right away
		}
		else
		{
			task->state = TASK_START;
		}
		// Also copy any breakpoints that way if function can break in the middle of it
		Q4T(task)->breakpointMask = Q4T(parentTask)->breakpointMask;
		memcpy(Q4T(task)->breakpoints,Q4T(parentTask)->breakpoints,sizeof(Q4T(task)->breakpoints));
		// Assume priority of parent so CALL can run
		Q4T(task)->taskPriority = Q4T(parentTask)->taskPriority;
	}
	else
	{
		task->state = TASK_START;
	}
	task->step_num = 32000;
	TASK_THREADS[i].initialized = 0;
	TASK_THREADS[i].function = 0;

	if (_QB_Shutting_Down)
	{
#ifdef ABSTRACT_INTIME
		_txe_mutex_put(__qs4_task_mutex);
#else
		_txe_mutex_put(&__qs4_task_mutex);
#endif
		PREEMPTION_TASK_RESTORE;
		return NULL;
	}

	if (TASK_THREADS[i].threadCached == 1)
	{
//		TASK_THREADS[i].threadCached = 2;
#ifdef ABSTRACT_INTIME
		memset(&TASK_THREADS[i].thread, 0, sizeof(QB_TX_THREAD));
#else
		memset(&TASK_THREADS[i].thread, 0, sizeof(TX_THREAD));
#endif
#ifdef ABSTRACT_INTIME
		_txe_mutex_put(__qs4_task_mutex);
#else
		_txe_mutex_put(&__qs4_task_mutex);
#endif
		PREEMPTION_TASK_RESTORE;
		// Spawn the task thread
		if (_tx_thread_create(&TASK_THREADS[i].thread, "Task Thread", taskMonitor, i, &TASK_THREADS[i].stack[0], MAX_THREAD_STACK_SIZE, THREAD_PRIORITY_QB_TASK,THREAD_PRIORITY_QB_TASK, TX_NO_TIME_SLICE, TX_DONT_START) != TX_SUCCESS)
		{
			// Failed to start
			stepDone(task);
			TASK_THREADS[i].task = NULL;
			TASK_THREADS[i].function = 0;
			TASK_THREADS[i].threadCached = 0;
			return NULL;
		}
	}
	else
	{
#ifndef ABSTRACT_INTIME
		char *foo = "Task Thread";
		TASK_THREADS[i].thread.tx_thread_name = foo;
#endif
		// Task is suspended so resume execution and let it wait to be initialized
//		_tx_thread_resume(&TASK_THREADS[i].thread);
#ifdef ABSTRACT_INTIME
		_txe_mutex_put(__qs4_task_mutex);
#else
		_txe_mutex_put(&__qs4_task_mutex);
#endif
		PREEMPTION_TASK_RESTORE;
	}
	return task;
}

// Create a task and spawn it...
TASK* CREATEFUNCTION(TASK *parentTask, int stepnum) {
TASK *task;
int i;
TASK *tskptr;
int state;
//int tasknum;

	if (_QB_Shutting_Down)
	{
		return NULL;
	}
	// Disable preemption
	PREEMPTION_TASK_DISABLE;
#ifdef ABSTRACT_INTIME
	_txe_mutex_get(__qs4_task_mutex, TX_WAIT_FOREVER);
#else
	_txe_mutex_get(&__qs4_task_mutex, TX_WAIT_FOREVER);
#endif

	// First see if there is a cached thread
	for (i = 0;i!=MAX_TASK_THREADS;i++)
	{
		if ((TASK_THREADS[i].QB_Active) && (TASK_THREADS[i].threadCached == 2) && (TASK_THREADS[i].threadExecuting == 0) && (TASK_THREADS[i].task == NULL))
		{
#ifdef ABSTRACT_INTIME
			if (taskSetBranch(&TASK_THREADS[i].thread, -4) != 0)  // Make sure it is self suspended!  Old runtime will always return 0 if not implemented.
			{
				continue;  // Can not use if not suspended yet
			}
#endif
			tskptr = TASK_THREADS[i].task;
			if (tskptr == NULL)
			{
				TASK_THREADS[i].index = i;
				TASK_THREADS[i].task = (TASK *)0xffffffff;	// block it from use
				break;
			}
		}
	}
	// See if found an active slot
	if (i == MAX_TASK_THREADS)
	{
		// No active slot so will have to create a thread

		// find available task slot
		for (i = 0;i!=MAX_TASK_THREADS;i++)
		{
			if (TASK_THREADS[i].threadCached == 0)
			{
				tskptr = TASK_THREADS[i].task;
				if (tskptr == NULL)
				{
					TASK_THREADS[i].threadCached = 1;	// lock it for ourselves
					TASK_THREADS[i].index = i;
					TASK_THREADS[i].task = (TASK *)0xffffffff;	// block it from use
					break;
				}
			}
		}
	}

	if (i == MAX_TASK_THREADS)
	{
#ifdef ABSTRACT_INTIME
		_txe_mutex_put(__qs4_task_mutex);
#else
		_txe_mutex_put(&__qs4_task_mutex);
#endif
		// Enable preemption
		PREEMPTION_TASK_RESTORE;
		// no slots available
		return NULL;
	}
#ifndef ABSTRACT_INTIME
	// Initialize the task structure
	if (TASK_THREADS[i].stack == NULL)
	{
		TASK_THREADS[i].stack = (unsigned char *)malloc(MAX_QB_STACK_SIZE);
		if (TASK_THREADS[i].stack == NULL)
		{
			TASK_THREADS[i].task = NULL;
			TASK_THREADS[i].threadCached = 0;
#ifdef ABSTRACT_INTIME
			_txe_mutex_put(__qs4_task_mutex);
#else
			_txe_mutex_put(&__qs4_task_mutex);
#endif
			// Enable preemption
			PREEMPTION_TASK_RESTORE;
			return NULL;
		}
	}
#endif

	task = createTask(stepnum-1);
	if (task == NULL)
	{
		// no more available
#ifndef ABSTRACT_INTIME
		if (TASK_THREADS[i].stack != NULL)
		{
			free(TASK_THREADS[i].stack);
		}
#endif
		TASK_THREADS[i].stack = NULL;
		TASK_THREADS[i].task = NULL;
		TASK_THREADS[i].threadCached = 0;
#ifdef ABSTRACT_INTIME
		_txe_mutex_put(__qs4_task_mutex);
#else
		_txe_mutex_put(&__qs4_task_mutex);
#endif
		// Enable preemption
		PREEMPTION_TASK_RESTORE;
		return NULL;
	}
	TASK_THREADS[i].stepStart = stepnum;
	TASK_THREADS[i].task = task;

	taskStart(i);

	if (Q4T(task) == NULL)
	{
		// This is bad!!!
		TASK_THREADS[i].task = NULL;
		TASK_THREADS[i].threadCached = 0;
#ifdef ABSTRACT_INTIME
		_txe_mutex_put(__qs4_task_mutex);
#else
		_txe_mutex_put(&__qs4_task_mutex);
#endif
		// Enable preemption
		PREEMPTION_TASK_RESTORE;
		return NULL;
	}
	Q4T(task)->parentTask = parentTask;  // our parent task so can access their local variables
	if (parentTask != NULL)
	{
		state = parentTask->state;
		if ((state == TASK_STOPPED) || (state == TASK_SS_RUN) || (state == TASK_SS_STEP) || (state == TASK_LL_RUN) || (state == TASK_LL_STEP) || (state == TASK_LL_BREAKPOINT))
		{
			task->state = parentTask->state;   // If single stepping we do not want a function or begin task thread to run right away
		}
		else
		{
			task->state = TASK_START;
		}
		// Also copy any breakpoints that way if function can break in the middle of it
		Q4T(task)->breakpointMask = Q4T(parentTask)->breakpointMask;
		memcpy(Q4T(task)->breakpoints,Q4T(parentTask)->breakpoints,sizeof(Q4T(task)->breakpoints));
		// Assume priority of parent so CALL can run
		Q4T(task)->taskPriority = Q4T(parentTask)->taskPriority;
	}
	else
	{
		task->state = TASK_START;
	}
	task->step_num = 32000;
	TASK_THREADS[i].initialized = 0;
	TASK_THREADS[i].function = 1;

	if (_QB_Shutting_Down)
	{
#ifdef ABSTRACT_INTIME
		_txe_mutex_put(__qs4_task_mutex);
#else
		_txe_mutex_put(&__qs4_task_mutex);
#endif
		// Enable preemption
		PREEMPTION_TASK_RESTORE;
		return NULL;
	}

	if (TASK_THREADS[i].threadCached == 1)
	{
//		TASK_THREADS[i].threadCached = 2;
#ifdef ABSTRACT_INTIME
		memset(&TASK_THREADS[i].thread, 0, sizeof(QB_TX_THREAD));
#else
		memset(&TASK_THREADS[i].thread, 0, sizeof(TX_THREAD));
#endif
#ifdef ABSTRACT_INTIME
		_txe_mutex_put(__qs4_task_mutex);
#else
		_txe_mutex_put(&__qs4_task_mutex);
#endif
		// Enable preemption
		PREEMPTION_TASK_RESTORE;
		// Spawn the task thread
		if (_tx_thread_create(&TASK_THREADS[i].thread, "Function Thread", taskMonitor, i, &TASK_THREADS[i].stack[0], MAX_THREAD_STACK_SIZE, THREAD_PRIORITY_QB_TASK,THREAD_PRIORITY_QB_TASK, TX_NO_TIME_SLICE, TX_DONT_START) != TX_SUCCESS)
		{
			// Failed to start
			stepDone(task);
			TASK_THREADS[i].task = NULL;
			TASK_THREADS[i].function = 0;
			TASK_THREADS[i].threadCached = 0;
			return NULL;
		}
	}
	else
	{
		// Task is suspended so resume execution and let it wait to be initialized
		char *foo = "Function Thread";
		TASK_THREADS[i].thread.tx_thread_name = foo;
//		_tx_thread_resume(&TASK_THREADS[i].thread);
#ifdef ABSTRACT_INTIME
		_txe_mutex_put(__qs4_task_mutex);
#else
		_txe_mutex_put(&__qs4_task_mutex);
#endif
		// Enable preemption
		PREEMPTION_TASK_RESTORE;
	}
	return task;
}

void raiseError(TASK* task, int ctc_errno) {
	char cmd[128];
	CMDPARSER* cmdp = (CMDPARSER*)CTC_allocateCommandParser(0);
	if (cmdp == NULL) return;
	cmdp->task = task;
	sprintf(cmd, "set fault %d", ctc_errno);
	CTC_runCommandParser(cmdp, cmd);
	CTC_releaseCommandParser(cmdp);
}

void raiseUError(TASK* task, int ctc_errno) {
	raiseError(task, ctc_errno+1000);
}

char* STRCPY(TASK* task, char* dest, char* src) {
	if (strlen(src) <= VARIANT_MAX_STRING)
		return strcpy(dest, src);
	else {
		raiseError(task, QS4_ERROR_STRLEN);
		return dest;
	}
}

char* STRCAT(TASK* task, char* dest, char* src) {
	if ((strlen(src) + strlen(dest)) <= VARIANT_MAX_STRING)
		return strcat(dest, src);
	else {
		raiseError(task, QS4_ERROR_STRLEN);
		return dest;
	}
}

int STRFIND(char* src, char* search) {
	char* ptr = strstr(src,search);
	if (ptr == NULL) return -1;
	return ptr-src;
}

char* STRLEFT(char* dest, char* src, int len) {
	char* rptr = dest;
	char c;

	while ( (c = *src++) && len-- > 0) *dest++ = c;
	*dest = 0;
	return rptr;
}

char* STRMID(char* dest, char* src, int pos, int len) {
	char* rptr = dest;
	char c;

	int slen = (int)strlen(src);
	if (pos < slen) {
		src += pos;
		while ( (c = *src++) && len-- > 0) *dest++ = c;
	}
	*dest = 0;
	return rptr;
}

char* STRRIGHT(char* dest, char* src, int len) {
	char* rptr = dest;
	char c;

	int slen = (int)strlen(src);
	if (len > slen) len = slen;
	src += (slen-len);
	while ( (c = *src++) && len-- > 0) *dest++ = c;
	*dest = 0;
	return rptr;
}

char* STRPADL(TASK* task, char* dest, char* src, int len, char* pad) {
	char* rptr = dest;

	if (len > VARIANT_MAX_STRING) {
		raiseError(task, QS4_ERROR_STRLEN);
		return src;
	}

	if ((int)strlen(pad) == 1) {
		int c2p = len - (int)strlen(src);
		while (c2p > 0) {
			*dest++ = *pad;
			c2p--;
		}
		while (*src)
			*dest++ = *src++;
		*dest = 0;
	}
	return rptr;
}

char* STRPADR(TASK* task, char* dest, char* src, int len, char* pad) {
	char* rptr = dest;

	if (len > VARIANT_MAX_STRING) {
		raiseError(task, QS4_ERROR_STRLEN);
		return src;
	}

	if ((int)strlen(pad) == 1) {
		int c2p = len - (int)strlen(src);
		while (*src)
			*dest++ = *src++;
		while (c2p > 0) {
			*dest++ = *pad;
			c2p--;
		}
		*dest = 0;
	}
	return rptr;
}

char* STRTRIM(char* dest, char* src, char* trims) {
	char* rptr = dest;
	char c;

	int mode = 1;
	char* midc = dest;
	while ((c = *src++)) {
		if (mode) {
				if (strchr(trims, c)) continue;
				*dest++ = c;
				mode--;
		}
		else {
				*dest++ = c;
				if (strchr(trims, c)) continue;
		}
		midc = dest;
	}
	*midc = 0;
	return rptr;
}

int _BR(TASK* task, int r, int x, int y) {
	INT32 result = 0;
	VARIANT_STORAGE v;
	if (r<0) { return RSYSVAR(task, r, x) != 0; }
	if (_IAI(r)) { return readAI(r) != 0.0; }
	if (_IAO(r)) { return readAO(r) != 0.0; }
	if (_IIR(r)) { regRead((UINT16)r, &result); return result != 0; }
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_INTEGER;
	regVRead(task, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
	return v.data.iValue != 0;
}

void _BW(TASK* task, int r, int x, int y, int value) {
	VARIANT_STORAGE v;
	if (r<0) { WSYSVAR(task, r, x, value!=0); return; }
	if (_IAI(r)) return;
	if (_IAO(r)) { writeAO(r, value == 0 ? 0.0 : 1.0); return; }
	if (_IIR(r)) { regWrite((UINT16)r, value!=0); return; }
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_INTEGER;
	v.data.iValue = value!=0;
	regVWrite(task, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
}

int _I(TASK* task, int r, int x, int y) {
	INT32 result = 0;
	VARIANT_STORAGE v;
	if (r<0) { return RSYSVAR(task, r, x); }
	if (_IAI(r)) { return (int)readAI(r); }
	if (_IAO(r)) { return (int)readAO(r); }
	if (_IIR(r)) { regRead((UINT16)r, &result); return result; }
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_INTEGER;
	regVRead(task, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
	return v.data.iValue;
}

void _IW(TASK* task, int r, int x, int y, int value) {
	VARIANT_STORAGE v;
	if (r<0) { WSYSVAR(task, r, x, value); return; }
	if (_IAI(r)) return;
	if (_IAO(r)) { writeAO(r, (double)value); return; }
	if (_IIR(r)) { regWrite((UINT16)r, value); return; }
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_INTEGER;
	v.data.iValue = value;
	regVWrite(task, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
}

double _D(TASK* task, int r, int x, int y) {
	INT32 result = 0;
	VARIANT_STORAGE v;
	if (r<0) { return (double)RSYSVAR(task, r, x); }
	if (_IAI(r)) { return readAI(r); }
	if (_IAO(r)) { return readAO(r); }
	if (_IIR(r)) { regRead((UINT16)r, &result); return (double)result; }
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_DOUBLE;
	regVRead(task, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
	return v.data.dValue;
}

void _DW(TASK* task, int r, int x, int y, double value) {
	VARIANT_STORAGE v;
	if (r<0) { WSYSVAR(task, r, x, (int)value); return; }
	if (_IAI(r)) return;
	if (_IAO(r)) { writeAO(r, value); return; }
	if (_IIR(r)) { regWrite((UINT16)r, (int)value); return; }
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_DOUBLE;
	v.data.dValue = value;
	regVWrite(task, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
}

double _F(TASK* task, int r, int x, int y) {
	INT32 result = 0;
	VARIANT_STORAGE v;
	if (r<0) { return (double)RSYSVAR(task, r, x); }
	if (_IAI(r)) { return readAI(r); }
	if (_IAO(r)) { return readAO(r); }
	if (_IIR(r)) { regRead((UINT16)r, &result); return (double)result; }
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_FLOAT;
	regVRead(task, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
	return v.data.fValue;
}

void _FW(TASK* task, int r, int x, int y, float value) {
	VARIANT_STORAGE v;
	if (r<0) { WSYSVAR(task, r, x, (int)value); return; }
	if (_IAI(r)) return;
	if (_IAO(r)) { writeAO(r, value); return; }
	if (_IIR(r)) { regWrite((UINT16)r, (int)value); return; }
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_FLOAT;
	v.data.fValue = value;
	regVWrite(task, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
}


char* _SRQS4_I(TASK* task, int i, int ssi) {
	sprintf(Q4T(task)->stringspace[ssi], "%d", i);
	return Q4T(task)->stringspace[ssi];
}

char* _SRQS4_F(TASK* task, float f, int ssi) {
	sprintf(Q4T(task)->stringspace[ssi], "%f", f);
	return Q4T(task)->stringspace[ssi];
}

char* _SRQS4_D(TASK* task, double f, int ssi) {
	sprintf(Q4T(task)->stringspace[ssi], "%g", f);
	return Q4T(task)->stringspace[ssi];
}

char* _SRQS4_S(TASK* task, char *s, int ssi) {
	strcpy(Q4T(task)->stringspace[ssi], s);
	return Q4T(task)->stringspace[ssi];
}

char* _SR(TASK* task, int r, int x, int y, int ssi) {
	VARIANT_STORAGE v;
	if (r<0) {
		ITOA(RSYSVAR(task, r, x), Q4T(task)->stringspace[ssi]);
		return Q4T(task)->stringspace[ssi];
	}
	if (_IAI(r)) { return _SRQS4_D(task, readAI(r), ssi); }
	if (_IAO(r)) { return _SRQS4_D(task, readAO(r), ssi); }
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.slength = 0;
	v.type = VARIANT_STRING_PTR;
	v.data.psValue = Q4T(task)->stringspace[ssi];
	regVRead(task, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
	return Q4T(task)->stringspace[ssi];
}

void _SW(TASK* task, int r, int x, int y, char* value) {
	VARIANT_STORAGE v;
	if (r<0) {
		raiseError(task, QS4_ERROR_INVALID_SYSTEM_VAR_OP);
		return;
	}
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.slength = 0;
	v.type = VARIANT_STRING_PTR;
	v.data.psValue = value;
	regVWrite(task, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
}

int _A(TASK* task, int r, int x, int y) {
	VARIANT_STORAGE v;
	if (r<0) return 0;
	v.flags = 0;
	v.cmd = VARIANT_CMD_INDIRECTION;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_INTEGER;
	regVRead(task, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
	return v.data.iValue;
}

void _AW(TASK* task, int r, int x, int y, int value) {
	VARIANT_STORAGE v;
	if (value <= 0) {
	   raiseError(task, QS4_ERROR_INVALID_INDIRECT);
	   return;
	}
	v.flags = 0;
	v.cmd = VARIANT_CMD_INDIRECTION;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_INTEGER;
	v.data.iValue = value;
	regVWrite(task, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
}

int _IREAD(int r, int x, int y) {
	VARIANT_STORAGE v;
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_INTEGER;
	regVRead(NULL, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
	return v.data.iValue;
}

void _IWRITE(int r, int x, int y, int value) {
	VARIANT_STORAGE v;
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_INTEGER;
	v.data.iValue = value;
	regVWrite(NULL, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
}

double _DREAD(int r, int x, int y) {
	VARIANT_STORAGE v;
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_DOUBLE;
	regVRead(NULL, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
	return v.data.dValue;
}

void _DWRITE(int r, int x, int y, double value) {
	VARIANT_STORAGE v;
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_DOUBLE;
	v.data.dValue = value;
	regVWrite(NULL, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
}

float _FREAD(int r, int x, int y) {
	VARIANT_STORAGE v;
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_FLOAT;
	regVRead(NULL, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
	return v.data.fValue;
}

void _FWRITE(int r, int x, int y, float value) {
	VARIANT_STORAGE v;
	v.flags = 0;
	v.cmd = 0;
	v.precision = 6;
#if QB_HDR_VERSION > 100
	v.indexRow = x;
	v.indexCol = y;
	v.taskHandle = 0;
#else
	v.indexX = x;
	v.indexY = y;
	v.taskhandle = 0;
#endif
	v.type = VARIANT_FLOAT;
	v.data.fValue = value;
	regVWrite(NULL, (UINT16)r, (void*)&v, VARIANT_STORAGE_TYPE);
}


int __regNumber(int codedreg) {
	if ((codedreg & 0xFF000000) == 0) return codedreg;
	return 36822;
}

int __reg_index_1(int codedreg) {
	if ((codedreg & 0xFF000000) == 0) return 0;
	return ((codedreg & 0x00FF0000) << 8) | ((codedreg >> 8) & 0xFF);
}

int __reg_index_2(int codedreg) {
	if ((codedreg & 0xFF000000) == 0) return 0;
	if ((codedreg & 0xFF000000) == 0x02000000)
		codedreg = -(codedreg & 0xFF) - 1;
	else
		codedreg &= 0xFF;
	return codedreg;
}

double _DRX(short isPtr, void* data) {
	if (isPtr < 0) return 0;
	if (isPtr)
		return *((double*)data);
	return _D(NULL, __regNumber((int)data), __reg_index_1((int)data), __reg_index_2((int)data));
}

void _DWX(short isPtr, void* data, double value) {
	if (isPtr < 0) return;
	if (isPtr) {
		 *((double*)data) = value;
		 return;
	}
	_DW(NULL, __regNumber((int)data), __reg_index_1((int)data), __reg_index_2((int)data), value);
}

float _FRX(short isPtr, void* data) {
	if (isPtr < 0) return 0;
	if (isPtr)
		return *((float*)data);
	return (float)_F(NULL, __regNumber((int)data), __reg_index_1((int)data), __reg_index_2((int)data));
}

void _FWX(short isPtr, void* data, float value) {
	if (isPtr < 0) return;
	if (isPtr) {
		 *((float*)data) = value;
		 return;
	}
	_FW(NULL, __regNumber((int)data), __reg_index_1((int)data), __reg_index_2((int)data), value);
}


int __ISDONE_N(TASK* task, int r) {
	int i = 0;
	unsigned int th;
	while ((th = _I(task, r, i, 0))) {
		TASK* t = getTaskFromHandle(th);
		if (t != NULL) {
			if (t->state == TASK_UNUSED) continue;
			return 0;
		}
		i++;
	}
	return 1;
}

int __ISDONE_1(TASK* task, int r) {
	unsigned int th;
	th = _I(task, r, 0, 0);
	TASK* t = getTaskFromHandle(th);
	if (t != NULL) {
		if (t->state == TASK_UNUSED) return 1;
		return 0;
	}
	return 1;
}

void __CANCEL_N(TASK* task, int r) {
	int i = 0;
	unsigned int th;
	while ((th = _I(task, r, i, 0))) {
		TASK* t = getTaskFromHandle(th);
		if (t != NULL)
		{
//#ifdef QB_RUNTIME
			if ((t->state != TASK_UNUSED) && (t->state != TASK_DONE))
			{
				t->state = TASK_DONE;  // request task to finish...
			}
//#else
//			killTask(t);
//#endif
		}
		_IW(task, r, i, 0, 0);
		i++;
	}
}

void __CANCEL_1(unsigned int th) {
	TASK* t = getTaskFromHandle(th);
	if (t != NULL)
	{
//#ifdef QB_RUNTIME
		if ((t->state != TASK_UNUSED) && (t->state != TASK_DONE))
		{
			t->state = TASK_DONE;  // request task to finish...
		}
//#else
//		killTask(t);
//#endif
	}
}

void __ENABLE_EVENT(int evtID, int endis) {
	if (evts[evtID] == 0) return;
	TASK* t = getTaskFromHandle(evts[evtID]);
	if (t == NULL) return;
	_IW(t, 36010, 0, 0, endis);
}

void __START_EVENT(int evtID, int stepnum) {
#ifdef QB_RUNTIME
	TASK* t = CREATETASK(NULL, stepnum);
#else
	TASK* t = CREATETASK(stepnum);
#endif
	if (t == NULL) { evts[evtID] = 0; return; }
	evts[evtID] = t->taskHandle;
	__ENABLE_EVENT(evtID, 0);
		// Start the thread
	_tx_thread_resume(&TASK_THREADS[Q4T(t)->taskThread_index].thread);

}

//--QS4IPM--//
unsigned short __ipm_EmptyAxis1_sb_MaxonMotion_mopdata[] = { 
	0x0,0x53B,0x108,0x3,0x100,0xBB8,0x0,0x407,0x108,0x6,0x104,0x117,0x105,0xFFFF,0x108,0xE,0x100,0x0,0x0,0x105,0xE,0x108,0x13,0x100,0x12C,0x0,0x407,0x108,0x16,0x404,0x108,0x17,0x408,0x108,0x19,0x100,0x64,0x0,0x407,0x108,0x1F,0x100,0x0,0x0,0x105,0xFFFE,0x108,0x22,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x23,0x100,0x1,0x0,0x105,0xFFFC,0x108,0x24,0x100,0x1,0x0,0x105,0xFFFB,0x108,0x25,0x100,0x64,0x0,0x105,0xF,0x108,0x28,0x104,0xFFFC,0x100,0x0,0x0,0x200,0x302,0x90,0x0,0x108,0x2B,0x104,0xFFFD,0x100,0x1,0x0,0x200,0x104,0xFFFD,0x100,0xB,0x0,0x200,0x209,0x302,0x1D2,0x0,0x108,0x2C,0x104,0xFFFD,0x100,0x3,0x0,0x200,0x302,0x432,0x0,0x108,0x2D,0x104,0xFFFD,0x100,0x4,0x0,0x200,0x302,0x4E2,0x0,0x108,0x2E,0x104,0xFFFD,0x100,0x5,0x0,0x200,0x302,0x592,0x0,0x108,0x2F,0x104,0xFFFD,0x100,0x6,0x0,0x200,0x302,0x16E,0x0,0x108,0x30,0x104,0xFFFD,0x100,0x7,0x0,0x200,0x302,0x18C,0x0,0x108,0x31,0x104,0xFFFD,0x100,0x8,0x0,0x200,0x302,0x77C,0x0,0x108,0x32,0x104,0xFFFD,0x100,0x9,0x0,0x200,0x302,0x1AA,0x0,0x108,0x33,0x300,0xA6,0x0,0x108,0x36,0x405,0x108,0x37,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x38,0x300,0xA6,0x0,0x108,0x3B,0x404,0x108,0x3C,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x3D,0x300,0xA6,0x0,0x108,0x41,0x100,0x0,0x0,0x104,0xFFFA,0x0,0x10,0x108,0x42,0x100,0xA,0x0,0x407,0x108,0x43,0x300,0x364,0x0,0x108,0x4A,0x104,0xFFF9,0x100,0x0,0x0,0x204,0x302,0x1F2,0x0,0x108,0x4B,0x300,0x208,0x0,0x108,0x4E,0x104,0xFFF9,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF9,0x108,0x51,0x104,0xFFF8,0x100,0x0,0x0,0x204,0x302,0x228,0x0,0x108,0x52,0x300,0x23E,0x0,0x108,0x54,0x104,0xFFF8,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF8,0x108,0x57,0x104,0xFFF7,0x100,0x0,0x0,0x204,0x302,0x3D4,0x0,0x108,0x59,0x300,0x274,0x0,0x108,0x5A,0x104,0xFFF7,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF7,0x108,0x69,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0xFFF6,0x100,0x3E8,0x0,0x20F,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0x6D,0x100,0x1,0x0,0x105,0x52,0x108,0x6E,0x100,0x0,0x0,0x105,0xFFF5,0x108,0x6F,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x70,0x104,0xFFFD,0x100,0xB,0x0,0x200,0x302,0x274,0x0,0x108,0x71,0x300,0x2FE,0x0,0x108,0x75,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x76,0x100,0x5,0x0,0x407,0x108,0x77,0x104,0xB0,0x105,0xFFF5,0x108,0x78,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0x79,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x2FE,0x0,0x108,0x7A,0x300,0x3D4,0x0,0x108,0x80,0x100,0x0,0x0,0x105,0x52,0x108,0x82,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x83,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x84,0x104,0xFFF8,0x105,0xD,0x108,0x85,0x100,0x2,0x0,0x407,0x108,0x86,0x403,0x0,0x108,0x89,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x3BE,0x0,0x108,0x96,0x100,0xC8,0x0,0x407,0x108,0x98,0x100,0x0,0x0,0x105,0x52,0x108,0x99,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x9A,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x9B,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x9C,0x300,0xA6,0x0,0x108,0xA3,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x2A,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xA4,0x100,0x64,0x0,0x407,0x108,0xA5,0x100,0x1,0x0,0x105,0x52,0x108,0xA8,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xA9,0x100,0x5,0x0,0x407,0x108,0xAA,0x104,0xB0,0x105,0xFFF5,0x108,0xAB,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0xAC,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x47C,0x0,0x108,0xAD,0x300,0x364,0x0,0x108,0xB1,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x2B,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xB2,0x100,0x64,0x0,0x407,0x108,0xB3,0x100,0x1,0x0,0x105,0x52,0x108,0xB6,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xB7,0x100,0x5,0x0,0x407,0x108,0xB8,0x104,0xB0,0x105,0xFFF5,0x108,0xB9,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0xBA,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x52C,0x0,0x108,0xBB,0x300,0x364,0x0,0x108,0xC4,0x100,0x0,0x0,0x105,0xE,0x108,0xC5,0x100,0x21,0x0,0x105,0x10,0x108,0xCA,0x100,0xFA,0x0,0x105,0x118,0x108,0xCC,0x100,0x17,0x0,0x105,0x121,0x108,0xCD,0x100,0xA,0x0,0x105,0x11F,0x108,0xCE,0x100,0x5,0x0,0x105,0x120,0x108,0xCF,0x100,0x8,0x0,0x105,0xE,0x108,0xD0,0x100,0x0,0x0,0x100,0xA,0x0,0x100,0xA,0x0,0x0,0x1,0x108,0xD4,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xD5,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x60E,0x0,0x108,0xD9,0x100,0x0,0x0,0x105,0xE,0x108,0xE2,0x100,0x64,0x0,0x407,0x108,0xE5,0x104,0xFFF7,0x100,0xD40,0x3,0x20F,0x104,0xFFF3,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xE7,0x100,0x0,0x0,0x105,0xFFF5,0x108,0xE9,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xEA,0x100,0x5,0x0,0x407,0x108,0xEB,0x104,0xB0,0x105,0xFFF5,0x108,0xEC,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x692,0x0,0x108,0xED,0x100,0xFA,0x0,0x407,0x108,0xEF,0x408,0x108,0xF3,0x100,0x0,0x0,0x105,0xFFFD,0x108,0xF4,0x100,0x0,0x0,0x105,0xFFF4,0x108,0xF5,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0xF6,0x300,0xA6,0x0,0x108,0xF9,0x100,0x0,0x0,0x105,0xE,0x108,0xFA,0x100,0xC8,0x0,0x407,0x108,0xFC,0x100,0x2,0x0,0x407,0x108,0xFD,0x403,0x0,0x108,0xFE,0x305,0x0,0x0,0x108,0xFF,0x100,0x14D,0x0,0x105,0x10,0x108,0x101,0x300,0x6E8,0x0,0x108,0x109,0x104,0x117,0x100,0x2,0x0,0x203,0x302,0x364,0x0,0x108,0x10B,0x100,0x3,0x0,0x280,0x108,0x10C,0x100,0x3,0x0,0x105,0x116,0x108,0x10D,0x40A,0x1,0x0,0x108,0x10F,0x104,0x117,0x100,0x1,0x0,0x200,0x302,0x7E8,0x0,0x108,0x112,0x406,0x1,0x108,0x113,0x100,0x1,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x116,0x406,0x1,0x108,0x117,0x100,0x5,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x11B,0x100,0x8,0x0,0x105,0xFFF4,0x108,0x11C,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F3,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x11F,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x850,0x0,0x108,0x120,0x300,0x830,0x0,0x108,0x123,0x406,0x0,0x108,0x124,0x100,0x64,0x0,0x407,0x108,0x125,0x300,0x364,0x0,0x108,0x128,0x100,0x1,0x0,0x105,0xFFF2,0x108,0x12A,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x100,0x4240,0xF,0x104,0xFFF2,0x20E,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0x12B,0x100,0xA,0x0,0x407,0x108,0x12E,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x12F,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x205,0x302,0x916,0x0,0x108,0x130,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x210,0x204,0x302,0x916,0x0,0x108,0x131,0x300,0x8C0,0x0,0x108,0x134,0x104,0xFFF8,0x105,0xD,0x108,0x135,0x100,0xA,0x0,0x407,0x108,0x136,0x403,0x0,0x108,0x137,0x100,0x1F4,0x0,0x407,0x108,0x139,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x24,0x210,0x100,0x1,0x0,0x104,0xFFF2,0x210,0x20E,0x20C,0x0,0x4,0x108,0x13B,0x305,0x0,0x0,0x108,0x13C,0x100,0x1F4,0x0,0x407,0x108,0x13D,0x408,0x108,0x13E,0x100,0xA,0x0,0x407,0x108,0x13F,0x300,0x99E,0x0,0x108,0x143,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0xFFF3,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0x146,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x147,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x9CE,0x0,0x108,0x148,0x100,0x1F4,0x0,0x407,0x108,0x149,0x305,0x0,0x0,0x108,0x14A,0x100,0x7D0,0x0,0x407,0x108,0x14B,0x408,0x108,0x14E,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x14F,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x150,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x151,0x300,0xA6,0x0,0x108,0x1A0,0x401,0xFFFF,0x0,0x401,0xFFFF,0x0000
 };
unsigned short * __ipm_EmptyAxis1_sbdata[] = { 
	__ipm_EmptyAxis1_sb_MaxonMotion_mopdata,NULL
 };
unsigned short __ipm_EmptyAxis2_sb_MaxonMotion_mopdata[] = { 
	0x0,0x53B,0x108,0x3,0x100,0xBB8,0x0,0x407,0x108,0x6,0x104,0x117,0x105,0xFFFF,0x108,0xE,0x100,0x0,0x0,0x105,0xE,0x108,0x13,0x100,0x12C,0x0,0x407,0x108,0x16,0x404,0x108,0x17,0x408,0x108,0x19,0x100,0x64,0x0,0x407,0x108,0x1F,0x100,0x0,0x0,0x105,0xFFFE,0x108,0x22,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x23,0x100,0x1,0x0,0x105,0xFFFC,0x108,0x24,0x100,0x1,0x0,0x105,0xFFFB,0x108,0x25,0x100,0x64,0x0,0x105,0xF,0x108,0x28,0x104,0xFFFC,0x100,0x0,0x0,0x200,0x302,0x90,0x0,0x108,0x2B,0x104,0xFFFD,0x100,0x1,0x0,0x200,0x104,0xFFFD,0x100,0xB,0x0,0x200,0x209,0x302,0x1D2,0x0,0x108,0x2C,0x104,0xFFFD,0x100,0x3,0x0,0x200,0x302,0x432,0x0,0x108,0x2D,0x104,0xFFFD,0x100,0x4,0x0,0x200,0x302,0x4E2,0x0,0x108,0x2E,0x104,0xFFFD,0x100,0x5,0x0,0x200,0x302,0x592,0x0,0x108,0x2F,0x104,0xFFFD,0x100,0x6,0x0,0x200,0x302,0x16E,0x0,0x108,0x30,0x104,0xFFFD,0x100,0x7,0x0,0x200,0x302,0x18C,0x0,0x108,0x31,0x104,0xFFFD,0x100,0x8,0x0,0x200,0x302,0x77C,0x0,0x108,0x32,0x104,0xFFFD,0x100,0x9,0x0,0x200,0x302,0x1AA,0x0,0x108,0x33,0x300,0xA6,0x0,0x108,0x36,0x405,0x108,0x37,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x38,0x300,0xA6,0x0,0x108,0x3B,0x404,0x108,0x3C,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x3D,0x300,0xA6,0x0,0x108,0x41,0x100,0x0,0x0,0x104,0xFFFA,0x0,0x10,0x108,0x42,0x100,0xA,0x0,0x407,0x108,0x43,0x300,0x364,0x0,0x108,0x4A,0x104,0xFFF9,0x100,0x0,0x0,0x204,0x302,0x1F2,0x0,0x108,0x4B,0x300,0x208,0x0,0x108,0x4E,0x104,0xFFF9,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF9,0x108,0x51,0x104,0xFFF8,0x100,0x0,0x0,0x204,0x302,0x228,0x0,0x108,0x52,0x300,0x23E,0x0,0x108,0x54,0x104,0xFFF8,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF8,0x108,0x57,0x104,0xFFF7,0x100,0x0,0x0,0x204,0x302,0x3D4,0x0,0x108,0x59,0x300,0x274,0x0,0x108,0x5A,0x104,0xFFF7,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF7,0x108,0x69,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0xFFF6,0x100,0x3E8,0x0,0x20F,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0x6D,0x100,0x1,0x0,0x105,0x52,0x108,0x6E,0x100,0x0,0x0,0x105,0xFFF5,0x108,0x6F,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x70,0x104,0xFFFD,0x100,0xB,0x0,0x200,0x302,0x274,0x0,0x108,0x71,0x300,0x2FE,0x0,0x108,0x75,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x76,0x100,0x5,0x0,0x407,0x108,0x77,0x104,0xB0,0x105,0xFFF5,0x108,0x78,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0x79,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x2FE,0x0,0x108,0x7A,0x300,0x3D4,0x0,0x108,0x80,0x100,0x0,0x0,0x105,0x52,0x108,0x82,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x83,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x84,0x104,0xFFF8,0x105,0xD,0x108,0x85,0x100,0x2,0x0,0x407,0x108,0x86,0x403,0x0,0x108,0x89,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x3BE,0x0,0x108,0x96,0x100,0xC8,0x0,0x407,0x108,0x98,0x100,0x0,0x0,0x105,0x52,0x108,0x99,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x9A,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x9B,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x9C,0x300,0xA6,0x0,0x108,0xA3,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x2A,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xA4,0x100,0x64,0x0,0x407,0x108,0xA5,0x100,0x1,0x0,0x105,0x52,0x108,0xA8,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xA9,0x100,0x5,0x0,0x407,0x108,0xAA,0x104,0xB0,0x105,0xFFF5,0x108,0xAB,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0xAC,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x47C,0x0,0x108,0xAD,0x300,0x364,0x0,0x108,0xB1,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x2B,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xB2,0x100,0x64,0x0,0x407,0x108,0xB3,0x100,0x1,0x0,0x105,0x52,0x108,0xB6,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xB7,0x100,0x5,0x0,0x407,0x108,0xB8,0x104,0xB0,0x105,0xFFF5,0x108,0xB9,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0xBA,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x52C,0x0,0x108,0xBB,0x300,0x364,0x0,0x108,0xC4,0x100,0x0,0x0,0x105,0xE,0x108,0xC5,0x100,0x21,0x0,0x105,0x10,0x108,0xCA,0x100,0xFA,0x0,0x105,0x118,0x108,0xCC,0x100,0x17,0x0,0x105,0x121,0x108,0xCD,0x100,0xA,0x0,0x105,0x11F,0x108,0xCE,0x100,0x5,0x0,0x105,0x120,0x108,0xCF,0x100,0x8,0x0,0x105,0xE,0x108,0xD0,0x100,0x0,0x0,0x100,0xA,0x0,0x100,0xA,0x0,0x0,0x1,0x108,0xD4,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xD5,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x60E,0x0,0x108,0xD9,0x100,0x0,0x0,0x105,0xE,0x108,0xE2,0x100,0x64,0x0,0x407,0x108,0xE5,0x104,0xFFF7,0x100,0xD40,0x3,0x20F,0x104,0xFFF3,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xE7,0x100,0x0,0x0,0x105,0xFFF5,0x108,0xE9,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xEA,0x100,0x5,0x0,0x407,0x108,0xEB,0x104,0xB0,0x105,0xFFF5,0x108,0xEC,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x692,0x0,0x108,0xED,0x100,0xFA,0x0,0x407,0x108,0xEF,0x408,0x108,0xF3,0x100,0x0,0x0,0x105,0xFFFD,0x108,0xF4,0x100,0x0,0x0,0x105,0xFFF4,0x108,0xF5,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0xF6,0x300,0xA6,0x0,0x108,0xF9,0x100,0x0,0x0,0x105,0xE,0x108,0xFA,0x100,0xC8,0x0,0x407,0x108,0xFC,0x100,0x2,0x0,0x407,0x108,0xFD,0x403,0x0,0x108,0xFE,0x305,0x0,0x0,0x108,0xFF,0x100,0x14D,0x0,0x105,0x10,0x108,0x101,0x300,0x6E8,0x0,0x108,0x109,0x104,0x117,0x100,0x2,0x0,0x203,0x302,0x364,0x0,0x108,0x10B,0x100,0x3,0x0,0x280,0x108,0x10C,0x100,0x3,0x0,0x105,0x116,0x108,0x10D,0x40A,0x1,0x0,0x108,0x10F,0x104,0x117,0x100,0x1,0x0,0x200,0x302,0x7E8,0x0,0x108,0x112,0x406,0x1,0x108,0x113,0x100,0x1,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x116,0x406,0x1,0x108,0x117,0x100,0x5,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x11B,0x100,0x8,0x0,0x105,0xFFF4,0x108,0x11C,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F3,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x11F,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x850,0x0,0x108,0x120,0x300,0x830,0x0,0x108,0x123,0x406,0x0,0x108,0x124,0x100,0x64,0x0,0x407,0x108,0x125,0x300,0x364,0x0,0x108,0x128,0x100,0x1,0x0,0x105,0xFFF2,0x108,0x12A,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x100,0x4240,0xF,0x104,0xFFF2,0x20E,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0x12B,0x100,0xA,0x0,0x407,0x108,0x12E,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x12F,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x205,0x302,0x916,0x0,0x108,0x130,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x210,0x204,0x302,0x916,0x0,0x108,0x131,0x300,0x8C0,0x0,0x108,0x134,0x104,0xFFF8,0x105,0xD,0x108,0x135,0x100,0xA,0x0,0x407,0x108,0x136,0x403,0x0,0x108,0x137,0x100,0x1F4,0x0,0x407,0x108,0x139,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x24,0x210,0x100,0x1,0x0,0x104,0xFFF2,0x210,0x20E,0x20C,0x0,0x4,0x108,0x13B,0x305,0x0,0x0,0x108,0x13C,0x100,0x1F4,0x0,0x407,0x108,0x13D,0x408,0x108,0x13E,0x100,0xA,0x0,0x407,0x108,0x13F,0x300,0x99E,0x0,0x108,0x143,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0xFFF3,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0x146,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x147,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x9CE,0x0,0x108,0x148,0x100,0x1F4,0x0,0x407,0x108,0x149,0x305,0x0,0x0,0x108,0x14A,0x100,0x7D0,0x0,0x407,0x108,0x14B,0x408,0x108,0x14E,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x14F,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x150,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x151,0x300,0xA6,0x0,0x108,0x1A0,0x401,0xFFFF,0x0,0x401,0xFFFF,0x0000
 };
unsigned short * __ipm_EmptyAxis2_sbdata[] = { 
	__ipm_EmptyAxis2_sb_MaxonMotion_mopdata,NULL
 };
unsigned short __ipm_EmptyAxis3_sb_StepperMotion_mopdata[] = { 
	0x0,0x5E7,0x108,0x4,0x100,0x12C,0x0,0x407,0x108,0x6,0x100,0x8,0x0,0x105,0xFFFF,0x108,0x9,0x404,0x108,0xA,0x408,0x108,0xC,0x100,0x64,0x0,0x407,0x108,0x12,0x100,0x0,0x0,0x105,0xFFFE,0x108,0x15,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x16,0x100,0x1,0x0,0x105,0xFFFC,0x108,0x17,0x100,0x1,0x0,0x105,0xFFFB,0x108,0x1B,0x104,0xFFFC,0x100,0x0,0x0,0x200,0x302,0x6A,0x0,0x108,0x1E,0x104,0xFFFD,0x100,0x1,0x0,0x200,0x104,0xFFFD,0x100,0x2,0x0,0x200,0x209,0x302,0x1AC,0x0,0x108,0x1F,0x104,0xFFFD,0x100,0x3,0x0,0x200,0x302,0x4AE,0x0,0x108,0x20,0x104,0xFFFD,0x100,0x4,0x0,0x200,0x302,0x56A,0x0,0x108,0x21,0x104,0xFFFD,0x100,0x5,0x0,0x200,0x302,0x626,0x0,0x108,0x22,0x104,0xFFFD,0x100,0x6,0x0,0x200,0x302,0x148,0x0,0x108,0x23,0x104,0xFFFD,0x100,0x7,0x0,0x200,0x302,0x166,0x0,0x108,0x24,0x104,0xFFFD,0x100,0x8,0x0,0x200,0x302,0x8F4,0x0,0x108,0x25,0x104,0xFFFD,0x100,0x9,0x0,0x200,0x302,0x184,0x0,0x108,0x26,0x300,0x80,0x0,0x108,0x29,0x405,0x108,0x2A,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x2B,0x300,0x80,0x0,0x108,0x2E,0x404,0x108,0x2F,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x30,0x300,0x80,0x0,0x108,0x34,0x100,0x0,0x0,0x104,0xFFFA,0x0,0x10,0x108,0x35,0x100,0xA,0x0,0x407,0x108,0x36,0x300,0x3D2,0x0,0x108,0x3D,0x104,0xFFF9,0x100,0x0,0x0,0x204,0x302,0x1CC,0x0,0x108,0x3E,0x300,0x1E2,0x0,0x108,0x41,0x104,0xFFF9,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF9,0x108,0x44,0x104,0xFFF8,0x100,0x0,0x0,0x204,0x302,0x202,0x0,0x108,0x45,0x300,0x218,0x0,0x108,0x47,0x104,0xFFF8,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF8,0x108,0x4A,0x104,0xFFF7,0x100,0x0,0x0,0x204,0x302,0x44A,0x0,0x108,0x4C,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x105,0xFFF7,0x108,0x4D,0x300,0x262,0x0,0x108,0x4E,0x104,0xFFF7,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF7,0x108,0x51,0x104,0xFFF5,0x100,0x3E8,0x0,0x20F,0x105,0xFFF6,0x108,0x57,0x104,0xFFF6,0x104,0x1E,0x20D,0x105,0xFFF4,0x108,0x59,0x104,0xFFFD,0x100,0x1,0x0,0x200,0x302,0x2A8,0x0,0x108,0x5A,0x300,0x2F2,0x0,0x108,0x5E,0x104,0xFFF7,0x104,0xFFF6,0x104,0xFFF9,0x104,0xFFF8,0x0,0x3,0x108,0x5F,0x100,0x64,0x0,0x407,0x108,0x60,0x100,0x1,0x0,0x105,0x52,0x108,0x61,0x100,0x0,0x0,0x105,0xFFF3,0x108,0x62,0x300,0x32A,0x0,0x108,0x65,0x104,0xFFF7,0x104,0xFFF6,0x100,0x1,0x0,0x210,0x20E,0x104,0xFFF9,0x104,0xFFF8,0x0,0x3,0x108,0x66,0x100,0x14,0x0,0x407,0x108,0x67,0x300,0x390,0x0,0x108,0x6A,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x3D2,0x0,0x108,0x6B,0x100,0x5,0x0,0x407,0x108,0x6C,0x104,0xB0,0x105,0xFFF3,0x108,0x6D,0x104,0xFFF3,0x100,0x1,0x0,0x210,0x200,0x302,0x3E0,0x0,0x108,0x6E,0x104,0xFFF3,0x100,0x2,0x0,0x201,0x302,0x32A,0x0,0x108,0x6F,0x300,0x44A,0x0,0x108,0x72,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x3D2,0x0,0x108,0x74,0x100,0x5,0x0,0x407,0x108,0x75,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x390,0x0,0x108,0x76,0x300,0x44A,0x0,0x108,0x7C,0x100,0x0,0x0,0x105,0x52,0x108,0x7E,0x100,0x0,0x0,0x105,0xFFF2,0x108,0x7F,0x104,0xFFFF,0x100,0x1,0x0,0x20C,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF2,0x108,0x80,0x104,0xFFF8,0x105,0xD,0x108,0x81,0x100,0x2,0x0,0x407,0x108,0x82,0x403,0x0,0x108,0x85,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x434,0x0,0x108,0x92,0x305,0x0,0x0,0x108,0x93,0x100,0x0,0x0,0x105,0x52,0x108,0x94,0x100,0x0,0x0,0x105,0xFFF2,0x108,0x95,0x104,0xFFFF,0x100,0x1,0x0,0x20C,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF2,0x108,0x96,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x97,0x300,0x80,0x0,0x108,0x9E,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x105,0xFFF7,0x108,0x9F,0x104,0xFFF7,0x104,0x2A,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xA0,0x100,0x64,0x0,0x407,0x108,0xA1,0x100,0x1,0x0,0x105,0x52,0x108,0xA4,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x3D2,0x0,0x108,0xA5,0x100,0x5,0x0,0x407,0x108,0xA6,0x104,0xB0,0x105,0xFFF3,0x108,0xA7,0x104,0xFFF3,0x100,0x1,0x0,0x210,0x200,0x302,0x3E0,0x0,0x108,0xA8,0x104,0xFFF3,0x100,0x2,0x0,0x201,0x302,0x504,0x0,0x108,0xA9,0x300,0x3D2,0x0,0x108,0xAC,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x105,0xFFF7,0x108,0xAD,0x104,0xFFF7,0x104,0x2B,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xAE,0x100,0x64,0x0,0x407,0x108,0xAF,0x100,0x1,0x0,0x105,0x52,0x108,0xB2,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x3D2,0x0,0x108,0xB3,0x100,0x5,0x0,0x407,0x108,0xB4,0x104,0xB0,0x105,0xFFF3,0x108,0xB5,0x104,0xFFF3,0x100,0x1,0x0,0x210,0x200,0x302,0x3E0,0x0,0x108,0xB6,0x104,0xFFF3,0x100,0x2,0x0,0x201,0x302,0x5C0,0x0,0x108,0xB7,0x300,0x3D2,0x0,0x108,0xC0,0x100,0x1,0x0,0x210,0x105,0xFFF1,0x108,0xC1,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x100,0x4240,0xF,0x104,0xFFF1,0x20E,0x104,0xFFF9,0x100,0x2710,0x0,0x20F,0x104,0xFFF8,0x100,0x2710,0x0,0x20F,0x0,0x3,0x108,0xC2,0x100,0xA,0x0,0x407,0x108,0xC5,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x8C0,0x0,0x108,0xC6,0x100,0x7E1,0x0,0x106,0x0,0xFFF0,0x108,0xC7,0x104,0xFFF0,0x100,0x1,0x0,0x200,0x302,0x6C0,0x0,0x108,0xC8,0x300,0x67A,0x0,0x108,0xCB,0x104,0xFFF8,0x105,0xD,0x108,0xCC,0x100,0xA,0x0,0x407,0x108,0xCD,0x403,0x0,0x108,0xCE,0x305,0x0,0x0,0x108,0xCF,0x100,0x1F4,0x0,0x407,0x108,0xD0,0x104,0xFFF7,0x100,0xA,0x0,0x20F,0x100,0x3E8,0x0,0x20F,0x100,0x4240,0xF,0x104,0xFFF1,0x20E,0x210,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x4,0x108,0xD3,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x8C0,0x0,0x108,0xD4,0x100,0x7E1,0x0,0x106,0x0,0xFFF0,0x108,0xD5,0x104,0xFFF0,0x100,0x0,0x0,0x200,0x302,0x77E,0x0,0x108,0xD6,0x300,0x738,0x0,0x108,0xD9,0x104,0xFFF8,0x105,0xD,0x108,0xDA,0x100,0xA,0x0,0x407,0x108,0xDB,0x403,0x0,0x108,0xDC,0x305,0x0,0x0,0x108,0xDD,0x100,0x1F4,0x0,0x407,0x108,0xDE,0x408,0x108,0xDF,0x408,0x108,0xE0,0x100,0xA,0x0,0x407,0x108,0xE1,0x300,0x7D6,0x0,0x108,0xE4,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0xFFEF,0x100,0x3E8,0x0,0x20F,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xE7,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x8C0,0x0,0x108,0xE8,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x80E,0x0,0x108,0xE9,0x100,0x1F4,0x0,0x407,0x108,0xEA,0x305,0x0,0x0,0x108,0xEB,0x100,0x7D0,0x0,0x407,0x108,0xEC,0x408,0x108,0xED,0x408,0x108,0xF1,0x100,0xC8,0x0,0x407,0x108,0xF5,0x100,0x0,0x0,0x105,0xFFFD,0x108,0xF6,0x100,0x0,0x0,0x105,0xFFF2,0x108,0xF7,0x104,0xFFFF,0x100,0x1,0x0,0x20C,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF2,0x108,0xF8,0x300,0x80,0x0,0x108,0xFB,0x100,0xC8,0x0,0x407,0x108,0xFD,0x100,0x2,0x0,0x407,0x108,0xFE,0x403,0x0,0x108,0xFF,0x305,0x0,0x0,0x108,0x100,0x300,0x874,0x0,0x108,0x108,0x104,0x117,0x100,0x2,0x0,0x203,0x302,0x3D2,0x0,0x108,0x10A,0x100,0x3,0x0,0x280,0x108,0x10B,0x100,0x3,0x0,0x105,0x116,0x108,0x10C,0x40A,0x1,0x0,0x108,0x10E,0x104,0x117,0x100,0x1,0x0,0x200,0x302,0x960,0x0,0x108,0x111,0x406,0x1,0x108,0x112,0x100,0x1,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x115,0x406,0x1,0x108,0x116,0x100,0x5,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x11A,0x100,0x8,0x0,0x105,0xFFF2,0x108,0x11B,0x104,0xFFFF,0x100,0x1,0x0,0x20C,0x100,0xA,0x0,0x20E,0x100,0x1F3,0x0,0x20C,0x107,0x0,0xFFF2,0x108,0x11E,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x9D0,0x0,0x108,0x11F,0x300,0x9B0,0x0,0x108,0x122,0x406,0x0,0x108,0x123,0x100,0x64,0x0,0x407,0x108,0x124,0x300,0x3D2,0x0,0x108,0x127,0x100,0x1,0x0,0x105,0xFFF1,0x108,0x129,0x104,0xFFF7,0x100,0x4240,0xF,0x104,0xFFF1,0x20E,0x104,0xFFF9,0x104,0xFFF8,0x0,0x3,0x108,0x12A,0x100,0xA,0x0,0x407,0x108,0x12D,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x3D2,0x0,0x108,0x12E,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x205,0x302,0xA7E,0x0,0x108,0x12F,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x210,0x204,0x302,0xA7E,0x0,0x108,0x130,0x300,0xA28,0x0,0x108,0x133,0x104,0xFFF8,0x105,0xD,0x108,0x134,0x100,0xA,0x0,0x407,0x108,0x135,0x403,0x0,0x108,0x136,0x100,0x1F4,0x0,0x407,0x108,0x138,0x104,0xFFF7,0x104,0x24,0x210,0x100,0x1,0x0,0x104,0xFFF1,0x210,0x20E,0x20C,0x0,0x4,0x108,0x13A,0x305,0x0,0x0,0x108,0x13B,0x100,0x1F4,0x0,0x407,0x108,0x13C,0x408,0x108,0x13D,0x100,0xA,0x0,0x407,0x108,0x13E,0x300,0x7D6,0x0,0x108,0x142,0x104,0xFFF7,0x100,0x2,0x0,0x20E,0x104,0xFFEF,0x104,0xFFF9,0x104,0xFFF8,0x0,0x3,0x108,0x145,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x3D2,0x0,0x108,0x146,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x80E,0x0,0x108,0x147,0x100,0x1F4,0x0,0x407,0x108,0x148,0x305,0x0,0x0,0x108,0x149,0x100,0x7D0,0x0,0x407,0x108,0x14A,0x408,0x108,0x14D,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x14E,0x100,0x0,0x0,0x105,0xFFF2,0x108,0x14F,0x104,0xFFFF,0x100,0x1,0x0,0x20C,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF2,0x108,0x150,0x300,0x80,0x0,0x108,0x18E,0x401,0xFFFF,0x0,0x401,0xFFFF,0x0000
 };
unsigned short * __ipm_EmptyAxis3_sbdata[] = { 
	__ipm_EmptyAxis3_sb_StepperMotion_mopdata,NULL
 };
unsigned short __ipm_Gripper_sb_MaxonMotion_mopdata[] = { 
	0x0,0x53B,0x108,0x3,0x100,0xBB8,0x0,0x407,0x108,0x6,0x104,0x117,0x105,0xFFFF,0x108,0xE,0x100,0x0,0x0,0x105,0xE,0x108,0x13,0x100,0x12C,0x0,0x407,0x108,0x16,0x404,0x108,0x17,0x408,0x108,0x19,0x100,0x64,0x0,0x407,0x108,0x1F,0x100,0x0,0x0,0x105,0xFFFE,0x108,0x22,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x23,0x100,0x1,0x0,0x105,0xFFFC,0x108,0x24,0x100,0x1,0x0,0x105,0xFFFB,0x108,0x25,0x100,0x64,0x0,0x105,0xF,0x108,0x28,0x104,0xFFFC,0x100,0x0,0x0,0x200,0x302,0x90,0x0,0x108,0x2B,0x104,0xFFFD,0x100,0x1,0x0,0x200,0x104,0xFFFD,0x100,0xB,0x0,0x200,0x209,0x302,0x1D2,0x0,0x108,0x2C,0x104,0xFFFD,0x100,0x3,0x0,0x200,0x302,0x432,0x0,0x108,0x2D,0x104,0xFFFD,0x100,0x4,0x0,0x200,0x302,0x4E2,0x0,0x108,0x2E,0x104,0xFFFD,0x100,0x5,0x0,0x200,0x302,0x592,0x0,0x108,0x2F,0x104,0xFFFD,0x100,0x6,0x0,0x200,0x302,0x16E,0x0,0x108,0x30,0x104,0xFFFD,0x100,0x7,0x0,0x200,0x302,0x18C,0x0,0x108,0x31,0x104,0xFFFD,0x100,0x8,0x0,0x200,0x302,0x77C,0x0,0x108,0x32,0x104,0xFFFD,0x100,0x9,0x0,0x200,0x302,0x1AA,0x0,0x108,0x33,0x300,0xA6,0x0,0x108,0x36,0x405,0x108,0x37,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x38,0x300,0xA6,0x0,0x108,0x3B,0x404,0x108,0x3C,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x3D,0x300,0xA6,0x0,0x108,0x41,0x100,0x0,0x0,0x104,0xFFFA,0x0,0x10,0x108,0x42,0x100,0xA,0x0,0x407,0x108,0x43,0x300,0x364,0x0,0x108,0x4A,0x104,0xFFF9,0x100,0x0,0x0,0x204,0x302,0x1F2,0x0,0x108,0x4B,0x300,0x208,0x0,0x108,0x4E,0x104,0xFFF9,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF9,0x108,0x51,0x104,0xFFF8,0x100,0x0,0x0,0x204,0x302,0x228,0x0,0x108,0x52,0x300,0x23E,0x0,0x108,0x54,0x104,0xFFF8,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF8,0x108,0x57,0x104,0xFFF7,0x100,0x0,0x0,0x204,0x302,0x3D4,0x0,0x108,0x59,0x300,0x274,0x0,0x108,0x5A,0x104,0xFFF7,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF7,0x108,0x69,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0xFFF6,0x100,0x3E8,0x0,0x20F,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0x6D,0x100,0x1,0x0,0x105,0x52,0x108,0x6E,0x100,0x0,0x0,0x105,0xFFF5,0x108,0x6F,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x70,0x104,0xFFFD,0x100,0xB,0x0,0x200,0x302,0x274,0x0,0x108,0x71,0x300,0x2FE,0x0,0x108,0x75,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x76,0x100,0x5,0x0,0x407,0x108,0x77,0x104,0xB0,0x105,0xFFF5,0x108,0x78,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0x79,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x2FE,0x0,0x108,0x7A,0x300,0x3D4,0x0,0x108,0x80,0x100,0x0,0x0,0x105,0x52,0x108,0x82,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x83,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x84,0x104,0xFFF8,0x105,0xD,0x108,0x85,0x100,0x2,0x0,0x407,0x108,0x86,0x403,0x0,0x108,0x89,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x3BE,0x0,0x108,0x96,0x100,0xC8,0x0,0x407,0x108,0x98,0x100,0x0,0x0,0x105,0x52,0x108,0x99,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x9A,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x9B,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x9C,0x300,0xA6,0x0,0x108,0xA3,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x2A,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xA4,0x100,0x64,0x0,0x407,0x108,0xA5,0x100,0x1,0x0,0x105,0x52,0x108,0xA8,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xA9,0x100,0x5,0x0,0x407,0x108,0xAA,0x104,0xB0,0x105,0xFFF5,0x108,0xAB,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0xAC,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x47C,0x0,0x108,0xAD,0x300,0x364,0x0,0x108,0xB1,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x2B,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xB2,0x100,0x64,0x0,0x407,0x108,0xB3,0x100,0x1,0x0,0x105,0x52,0x108,0xB6,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xB7,0x100,0x5,0x0,0x407,0x108,0xB8,0x104,0xB0,0x105,0xFFF5,0x108,0xB9,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0xBA,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x52C,0x0,0x108,0xBB,0x300,0x364,0x0,0x108,0xC4,0x100,0x0,0x0,0x105,0xE,0x108,0xC5,0x100,0x21,0x0,0x105,0x10,0x108,0xCA,0x100,0xFA,0x0,0x105,0x118,0x108,0xCC,0x100,0x17,0x0,0x105,0x121,0x108,0xCD,0x100,0xA,0x0,0x105,0x11F,0x108,0xCE,0x100,0x5,0x0,0x105,0x120,0x108,0xCF,0x100,0x8,0x0,0x105,0xE,0x108,0xD0,0x100,0x0,0x0,0x100,0xA,0x0,0x100,0xA,0x0,0x0,0x1,0x108,0xD4,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xD5,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x60E,0x0,0x108,0xD9,0x100,0x0,0x0,0x105,0xE,0x108,0xE2,0x100,0x64,0x0,0x407,0x108,0xE5,0x104,0xFFF7,0x100,0xD40,0x3,0x20F,0x104,0xFFF3,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xE7,0x100,0x0,0x0,0x105,0xFFF5,0x108,0xE9,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xEA,0x100,0x5,0x0,0x407,0x108,0xEB,0x104,0xB0,0x105,0xFFF5,0x108,0xEC,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x692,0x0,0x108,0xED,0x100,0xFA,0x0,0x407,0x108,0xEF,0x408,0x108,0xF3,0x100,0x0,0x0,0x105,0xFFFD,0x108,0xF4,0x100,0x0,0x0,0x105,0xFFF4,0x108,0xF5,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0xF6,0x300,0xA6,0x0,0x108,0xF9,0x100,0x0,0x0,0x105,0xE,0x108,0xFA,0x100,0xC8,0x0,0x407,0x108,0xFC,0x100,0x2,0x0,0x407,0x108,0xFD,0x403,0x0,0x108,0xFE,0x305,0x0,0x0,0x108,0xFF,0x100,0x14D,0x0,0x105,0x10,0x108,0x101,0x300,0x6E8,0x0,0x108,0x109,0x104,0x117,0x100,0x2,0x0,0x203,0x302,0x364,0x0,0x108,0x10B,0x100,0x3,0x0,0x280,0x108,0x10C,0x100,0x3,0x0,0x105,0x116,0x108,0x10D,0x40A,0x1,0x0,0x108,0x10F,0x104,0x117,0x100,0x1,0x0,0x200,0x302,0x7E8,0x0,0x108,0x112,0x406,0x1,0x108,0x113,0x100,0x1,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x116,0x406,0x1,0x108,0x117,0x100,0x5,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x11B,0x100,0x8,0x0,0x105,0xFFF4,0x108,0x11C,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F3,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x11F,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x850,0x0,0x108,0x120,0x300,0x830,0x0,0x108,0x123,0x406,0x0,0x108,0x124,0x100,0x64,0x0,0x407,0x108,0x125,0x300,0x364,0x0,0x108,0x128,0x100,0x1,0x0,0x105,0xFFF2,0x108,0x12A,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x100,0x4240,0xF,0x104,0xFFF2,0x20E,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0x12B,0x100,0xA,0x0,0x407,0x108,0x12E,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x12F,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x205,0x302,0x916,0x0,0x108,0x130,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x210,0x204,0x302,0x916,0x0,0x108,0x131,0x300,0x8C0,0x0,0x108,0x134,0x104,0xFFF8,0x105,0xD,0x108,0x135,0x100,0xA,0x0,0x407,0x108,0x136,0x403,0x0,0x108,0x137,0x100,0x1F4,0x0,0x407,0x108,0x139,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x24,0x210,0x100,0x1,0x0,0x104,0xFFF2,0x210,0x20E,0x20C,0x0,0x4,0x108,0x13B,0x305,0x0,0x0,0x108,0x13C,0x100,0x1F4,0x0,0x407,0x108,0x13D,0x408,0x108,0x13E,0x100,0xA,0x0,0x407,0x108,0x13F,0x300,0x99E,0x0,0x108,0x143,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0xFFF3,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0x146,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x147,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x9CE,0x0,0x108,0x148,0x100,0x1F4,0x0,0x407,0x108,0x149,0x305,0x0,0x0,0x108,0x14A,0x100,0x7D0,0x0,0x407,0x108,0x14B,0x408,0x108,0x14E,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x14F,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x150,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x151,0x300,0xA6,0x0,0x108,0x1A0,0x401,0xFFFF,0x0,0x401,0xFFFF,0x0000
 };
unsigned short * __ipm_Gripper_sbdata[] = { 
	__ipm_Gripper_sb_MaxonMotion_mopdata,NULL
 };
unsigned short __ipm_ThetaAxis_sb_Motion_mopdata[] = { 
	0x0,0x522,0x108,0x3,0x100,0xBB8,0x0,0x407,0x108,0x6,0x104,0x117,0x105,0xFFFF,0x108,0xE,0x100,0x0,0x0,0x105,0xE,0x108,0x13,0x100,0x12C,0x0,0x407,0x108,0x16,0x404,0x108,0x17,0x408,0x108,0x19,0x100,0x64,0x0,0x407,0x108,0x1F,0x100,0x0,0x0,0x105,0xFFFE,0x108,0x22,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x23,0x100,0x1,0x0,0x105,0xFFFC,0x108,0x24,0x100,0x1,0x0,0x105,0xFFFB,0x108,0x25,0x100,0x64,0x0,0x105,0xF,0x108,0x28,0x104,0xFFFC,0x100,0x0,0x0,0x200,0x302,0x90,0x0,0x108,0x2B,0x104,0xFFFD,0x100,0x1,0x0,0x200,0x104,0xFFFD,0x100,0xB,0x0,0x200,0x209,0x302,0x1D2,0x0,0x108,0x2C,0x104,0xFFFD,0x100,0x3,0x0,0x200,0x302,0x432,0x0,0x108,0x2D,0x104,0xFFFD,0x100,0x4,0x0,0x200,0x302,0x4E2,0x0,0x108,0x2E,0x104,0xFFFD,0x100,0x5,0x0,0x200,0x302,0x592,0x0,0x108,0x2F,0x104,0xFFFD,0x100,0x6,0x0,0x200,0x302,0x16E,0x0,0x108,0x30,0x104,0xFFFD,0x100,0x7,0x0,0x200,0x302,0x18C,0x0,0x108,0x31,0x104,0xFFFD,0x100,0x8,0x0,0x200,0x302,0x77A,0x0,0x108,0x32,0x104,0xFFFD,0x100,0x9,0x0,0x200,0x302,0x1AA,0x0,0x108,0x33,0x300,0xA6,0x0,0x108,0x36,0x405,0x108,0x37,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x38,0x300,0xA6,0x0,0x108,0x3B,0x404,0x108,0x3C,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x3D,0x300,0xA6,0x0,0x108,0x41,0x100,0x0,0x0,0x104,0xFFFA,0x0,0x10,0x108,0x42,0x100,0xA,0x0,0x407,0x108,0x43,0x300,0x364,0x0,0x108,0x4A,0x104,0xFFF9,0x100,0x0,0x0,0x204,0x302,0x1F2,0x0,0x108,0x4B,0x300,0x208,0x0,0x108,0x4E,0x104,0xFFF9,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF9,0x108,0x51,0x104,0xFFF8,0x100,0x0,0x0,0x204,0x302,0x228,0x0,0x108,0x52,0x300,0x23E,0x0,0x108,0x54,0x104,0xFFF8,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF8,0x108,0x57,0x104,0xFFF7,0x100,0x0,0x0,0x204,0x302,0x3D4,0x0,0x108,0x59,0x300,0x274,0x0,0x108,0x5A,0x104,0xFFF7,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF7,0x108,0x69,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0xFFF6,0x100,0x3E8,0x0,0x20F,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0x6D,0x100,0x1,0x0,0x105,0x52,0x108,0x6E,0x100,0x0,0x0,0x105,0xFFF5,0x108,0x6F,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x70,0x104,0xFFFD,0x100,0xB,0x0,0x200,0x302,0x274,0x0,0x108,0x71,0x300,0x2FE,0x0,0x108,0x75,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x76,0x100,0x5,0x0,0x407,0x108,0x77,0x104,0xB0,0x105,0xFFF5,0x108,0x78,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0x79,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x2FE,0x0,0x108,0x7A,0x300,0x3D4,0x0,0x108,0x80,0x100,0x0,0x0,0x105,0x52,0x108,0x82,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x83,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x84,0x104,0xFFF8,0x105,0xD,0x108,0x85,0x100,0x2,0x0,0x407,0x108,0x86,0x403,0x0,0x108,0x89,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x3BE,0x0,0x108,0x96,0x100,0xC8,0x0,0x407,0x108,0x98,0x100,0x0,0x0,0x105,0x52,0x108,0x99,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x9A,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x9B,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x9C,0x300,0xA6,0x0,0x108,0xA4,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x2A,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xA5,0x100,0x64,0x0,0x407,0x108,0xA6,0x100,0x1,0x0,0x105,0x52,0x108,0xA9,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xAA,0x100,0x5,0x0,0x407,0x108,0xAB,0x104,0xB0,0x105,0xFFF5,0x108,0xAC,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0xAD,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x47C,0x0,0x108,0xAE,0x300,0x364,0x0,0x108,0xB2,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x2B,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xB3,0x100,0x64,0x0,0x407,0x108,0xB4,0x100,0x1,0x0,0x105,0x52,0x108,0xB7,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xB8,0x100,0x5,0x0,0x407,0x108,0xB9,0x104,0xB0,0x105,0xFFF5,0x108,0xBA,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0xBB,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x52C,0x0,0x108,0xBC,0x300,0x364,0x0,0x108,0xC5,0x100,0x0,0x0,0x105,0xE,0x108,0xC9,0x100,0xFA,0x0,0x105,0x118,0x108,0xCB,0x100,0xB,0x0,0x105,0x121,0x108,0xCC,0x103,0x0,0x3FD0,0x0,0x0,0x105,0x11F,0x108,0xCD,0x103,0x9999,0x3FB9,0x999A,0x9999,0x105,0x120,0x108,0xCE,0x100,0x8,0x0,0x105,0xE,0x108,0xCF,0x100,0x0,0x0,0x100,0xA,0x0,0x100,0xA,0x0,0x0,0x1,0x108,0xD3,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xD4,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x608,0x0,0x108,0xD9,0x100,0x0,0x0,0x105,0xE,0x108,0xDE,0x103,0x9999,0x3FB9,0x999A,0x9999,0x100,0x0,0x0,0x100,0xA,0x0,0x100,0xA,0x0,0x0,0x3,0x108,0xDF,0x305,0x0,0x0,0x108,0xE3,0x100,0xC8,0x0,0x407,0x108,0xE6,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0xFFF3,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xEB,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xEC,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x6AC,0x0,0x108,0xED,0x100,0x1F4,0x0,0x407,0x108,0xEE,0x305,0x0,0x0,0x108,0xF0,0x408,0x108,0xF4,0x100,0x0,0x0,0x105,0xFFFD,0x108,0xF5,0x100,0x0,0x0,0x105,0xFFF4,0x108,0xF6,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0xF7,0x300,0xA6,0x0,0x108,0xFA,0x100,0x0,0x0,0x105,0xE,0x108,0xFB,0x100,0xC8,0x0,0x407,0x108,0xFD,0x100,0x2,0x0,0x407,0x108,0xFE,0x403,0x0,0x108,0xFF,0x305,0x0,0x0,0x108,0x100,0x300,0x6F4,0x0,0x108,0x108,0x104,0x117,0x100,0x2,0x0,0x203,0x302,0x364,0x0,0x108,0x10A,0x100,0x3,0x0,0x280,0x108,0x10B,0x100,0x3,0x0,0x105,0x116,0x108,0x10C,0x40A,0x1,0x0,0x108,0x10E,0x104,0x117,0x100,0x1,0x0,0x200,0x302,0x7E6,0x0,0x108,0x111,0x406,0x1,0x108,0x112,0x100,0x1,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x115,0x406,0x1,0x108,0x116,0x100,0x5,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x11A,0x100,0x8,0x0,0x105,0xFFF4,0x108,0x11B,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F3,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x11E,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x84E,0x0,0x108,0x11F,0x300,0x82E,0x0,0x108,0x122,0x406,0x0,0x108,0x123,0x100,0x64,0x0,0x407,0x108,0x124,0x300,0x364,0x0,0x108,0x127,0x100,0x1,0x0,0x105,0xFFF2,0x108,0x129,0x104,0xFFF7,0x100,0x4240,0xF,0x104,0xFFF2,0x20E,0x104,0xFFF9,0x104,0xFFF8,0x0,0x3,0x108,0x12A,0x100,0xA,0x0,0x407,0x108,0x12D,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x12E,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x205,0x302,0x8FC,0x0,0x108,0x12F,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x210,0x204,0x302,0x8FC,0x0,0x108,0x130,0x300,0x8A6,0x0,0x108,0x133,0x104,0xFFF8,0x105,0xD,0x108,0x134,0x100,0xA,0x0,0x407,0x108,0x135,0x403,0x0,0x108,0x136,0x100,0x1F4,0x0,0x407,0x108,0x138,0x104,0xFFF7,0x104,0x24,0x210,0x100,0x1,0x0,0x104,0xFFF2,0x210,0x20E,0x20C,0x0,0x4,0x108,0x13A,0x305,0x0,0x0,0x108,0x13B,0x100,0x1F4,0x0,0x407,0x108,0x13C,0x408,0x108,0x13D,0x100,0xA,0x0,0x407,0x108,0x13E,0x300,0x97C,0x0,0x108,0x142,0x104,0xFFF7,0x100,0x2,0x0,0x20E,0x104,0xFFF3,0x104,0xFFF9,0x104,0xFFF8,0x0,0x3,0x108,0x145,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x146,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x99C,0x0,0x108,0x147,0x100,0x1F4,0x0,0x407,0x108,0x148,0x305,0x0,0x0,0x108,0x149,0x100,0x7D0,0x0,0x407,0x108,0x14A,0x408,0x108,0x14D,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x14E,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x14F,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x150,0x300,0xA6,0x0,0x108,0x196,0x401,0xFFFF,0x0,0x401,0xFFFF,0x0000
 };
unsigned short * __ipm_ThetaAxis_sbdata[] = { 
	__ipm_ThetaAxis_sb_Motion_mopdata,NULL
 };
unsigned short __ipm_TransferStation_sb_StepperMotion_mopdata[] = { 
	0x0,0x5E7,0x108,0x4,0x100,0x12C,0x0,0x407,0x108,0x6,0x100,0x8,0x0,0x105,0xFFFF,0x108,0x9,0x404,0x108,0xA,0x408,0x108,0xC,0x100,0x64,0x0,0x407,0x108,0x12,0x100,0x0,0x0,0x105,0xFFFE,0x108,0x15,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x16,0x100,0x1,0x0,0x105,0xFFFC,0x108,0x17,0x100,0x1,0x0,0x105,0xFFFB,0x108,0x1B,0x104,0xFFFC,0x100,0x0,0x0,0x200,0x302,0x6A,0x0,0x108,0x1E,0x104,0xFFFD,0x100,0x1,0x0,0x200,0x104,0xFFFD,0x100,0x2,0x0,0x200,0x209,0x302,0x1AC,0x0,0x108,0x1F,0x104,0xFFFD,0x100,0x3,0x0,0x200,0x302,0x4AE,0x0,0x108,0x20,0x104,0xFFFD,0x100,0x4,0x0,0x200,0x302,0x56A,0x0,0x108,0x21,0x104,0xFFFD,0x100,0x5,0x0,0x200,0x302,0x626,0x0,0x108,0x22,0x104,0xFFFD,0x100,0x6,0x0,0x200,0x302,0x148,0x0,0x108,0x23,0x104,0xFFFD,0x100,0x7,0x0,0x200,0x302,0x166,0x0,0x108,0x24,0x104,0xFFFD,0x100,0x8,0x0,0x200,0x302,0x8F4,0x0,0x108,0x25,0x104,0xFFFD,0x100,0x9,0x0,0x200,0x302,0x184,0x0,0x108,0x26,0x300,0x80,0x0,0x108,0x29,0x405,0x108,0x2A,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x2B,0x300,0x80,0x0,0x108,0x2E,0x404,0x108,0x2F,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x30,0x300,0x80,0x0,0x108,0x34,0x100,0x0,0x0,0x104,0xFFFA,0x0,0x10,0x108,0x35,0x100,0xA,0x0,0x407,0x108,0x36,0x300,0x3D2,0x0,0x108,0x3D,0x104,0xFFF9,0x100,0x0,0x0,0x204,0x302,0x1CC,0x0,0x108,0x3E,0x300,0x1E2,0x0,0x108,0x41,0x104,0xFFF9,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF9,0x108,0x44,0x104,0xFFF8,0x100,0x0,0x0,0x204,0x302,0x202,0x0,0x108,0x45,0x300,0x218,0x0,0x108,0x47,0x104,0xFFF8,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF8,0x108,0x4A,0x104,0xFFF7,0x100,0x0,0x0,0x204,0x302,0x44A,0x0,0x108,0x4C,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x105,0xFFF7,0x108,0x4D,0x300,0x262,0x0,0x108,0x4E,0x104,0xFFF7,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF7,0x108,0x51,0x104,0xFFF5,0x100,0x3E8,0x0,0x20F,0x105,0xFFF6,0x108,0x57,0x104,0xFFF6,0x104,0x1E,0x20D,0x105,0xFFF4,0x108,0x59,0x104,0xFFFD,0x100,0x1,0x0,0x200,0x302,0x2A8,0x0,0x108,0x5A,0x300,0x2F2,0x0,0x108,0x5E,0x104,0xFFF7,0x104,0xFFF6,0x104,0xFFF9,0x104,0xFFF8,0x0,0x3,0x108,0x5F,0x100,0x64,0x0,0x407,0x108,0x60,0x100,0x1,0x0,0x105,0x52,0x108,0x61,0x100,0x0,0x0,0x105,0xFFF3,0x108,0x62,0x300,0x32A,0x0,0x108,0x65,0x104,0xFFF7,0x104,0xFFF6,0x100,0x1,0x0,0x210,0x20E,0x104,0xFFF9,0x104,0xFFF8,0x0,0x3,0x108,0x66,0x100,0x14,0x0,0x407,0x108,0x67,0x300,0x390,0x0,0x108,0x6A,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x3D2,0x0,0x108,0x6B,0x100,0x5,0x0,0x407,0x108,0x6C,0x104,0xB0,0x105,0xFFF3,0x108,0x6D,0x104,0xFFF3,0x100,0x1,0x0,0x210,0x200,0x302,0x3E0,0x0,0x108,0x6E,0x104,0xFFF3,0x100,0x2,0x0,0x201,0x302,0x32A,0x0,0x108,0x6F,0x300,0x44A,0x0,0x108,0x72,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x3D2,0x0,0x108,0x74,0x100,0x5,0x0,0x407,0x108,0x75,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x390,0x0,0x108,0x76,0x300,0x44A,0x0,0x108,0x7C,0x100,0x0,0x0,0x105,0x52,0x108,0x7E,0x100,0x0,0x0,0x105,0xFFF2,0x108,0x7F,0x104,0xFFFF,0x100,0x1,0x0,0x20C,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF2,0x108,0x80,0x104,0xFFF8,0x105,0xD,0x108,0x81,0x100,0x2,0x0,0x407,0x108,0x82,0x403,0x0,0x108,0x85,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x434,0x0,0x108,0x92,0x305,0x0,0x0,0x108,0x93,0x100,0x0,0x0,0x105,0x52,0x108,0x94,0x100,0x0,0x0,0x105,0xFFF2,0x108,0x95,0x104,0xFFFF,0x100,0x1,0x0,0x20C,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF2,0x108,0x96,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x97,0x300,0x80,0x0,0x108,0x9E,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x105,0xFFF7,0x108,0x9F,0x104,0xFFF7,0x104,0x2A,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xA0,0x100,0x64,0x0,0x407,0x108,0xA1,0x100,0x1,0x0,0x105,0x52,0x108,0xA4,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x3D2,0x0,0x108,0xA5,0x100,0x5,0x0,0x407,0x108,0xA6,0x104,0xB0,0x105,0xFFF3,0x108,0xA7,0x104,0xFFF3,0x100,0x1,0x0,0x210,0x200,0x302,0x3E0,0x0,0x108,0xA8,0x104,0xFFF3,0x100,0x2,0x0,0x201,0x302,0x504,0x0,0x108,0xA9,0x300,0x3D2,0x0,0x108,0xAC,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x105,0xFFF7,0x108,0xAD,0x104,0xFFF7,0x104,0x2B,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xAE,0x100,0x64,0x0,0x407,0x108,0xAF,0x100,0x1,0x0,0x105,0x52,0x108,0xB2,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x3D2,0x0,0x108,0xB3,0x100,0x5,0x0,0x407,0x108,0xB4,0x104,0xB0,0x105,0xFFF3,0x108,0xB5,0x104,0xFFF3,0x100,0x1,0x0,0x210,0x200,0x302,0x3E0,0x0,0x108,0xB6,0x104,0xFFF3,0x100,0x2,0x0,0x201,0x302,0x5C0,0x0,0x108,0xB7,0x300,0x3D2,0x0,0x108,0xC0,0x100,0x1,0x0,0x210,0x105,0xFFF1,0x108,0xC1,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x100,0x4240,0xF,0x104,0xFFF1,0x20E,0x104,0xFFF9,0x100,0x2710,0x0,0x20F,0x104,0xFFF8,0x100,0x2710,0x0,0x20F,0x0,0x3,0x108,0xC2,0x100,0xA,0x0,0x407,0x108,0xC5,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x8C0,0x0,0x108,0xC6,0x100,0x7E1,0x0,0x106,0x0,0xFFF0,0x108,0xC7,0x104,0xFFF0,0x100,0x1,0x0,0x200,0x302,0x6C0,0x0,0x108,0xC8,0x300,0x67A,0x0,0x108,0xCB,0x104,0xFFF8,0x105,0xD,0x108,0xCC,0x100,0xA,0x0,0x407,0x108,0xCD,0x403,0x0,0x108,0xCE,0x305,0x0,0x0,0x108,0xCF,0x100,0x1F4,0x0,0x407,0x108,0xD0,0x104,0xFFF7,0x100,0xA,0x0,0x20F,0x100,0x3E8,0x0,0x20F,0x100,0x4240,0xF,0x104,0xFFF1,0x20E,0x210,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x4,0x108,0xD3,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x8C0,0x0,0x108,0xD4,0x100,0x7E1,0x0,0x106,0x0,0xFFF0,0x108,0xD5,0x104,0xFFF0,0x100,0x0,0x0,0x200,0x302,0x77E,0x0,0x108,0xD6,0x300,0x738,0x0,0x108,0xD9,0x104,0xFFF8,0x105,0xD,0x108,0xDA,0x100,0xA,0x0,0x407,0x108,0xDB,0x403,0x0,0x108,0xDC,0x305,0x0,0x0,0x108,0xDD,0x100,0x1F4,0x0,0x407,0x108,0xDE,0x408,0x108,0xDF,0x408,0x108,0xE0,0x100,0xA,0x0,0x407,0x108,0xE1,0x300,0x7D6,0x0,0x108,0xE4,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0xFFEF,0x100,0x3E8,0x0,0x20F,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xE7,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x8C0,0x0,0x108,0xE8,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x80E,0x0,0x108,0xE9,0x100,0x1F4,0x0,0x407,0x108,0xEA,0x305,0x0,0x0,0x108,0xEB,0x100,0x7D0,0x0,0x407,0x108,0xEC,0x408,0x108,0xED,0x408,0x108,0xF1,0x100,0xC8,0x0,0x407,0x108,0xF5,0x100,0x0,0x0,0x105,0xFFFD,0x108,0xF6,0x100,0x0,0x0,0x105,0xFFF2,0x108,0xF7,0x104,0xFFFF,0x100,0x1,0x0,0x20C,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF2,0x108,0xF8,0x300,0x80,0x0,0x108,0xFB,0x100,0xC8,0x0,0x407,0x108,0xFD,0x100,0x2,0x0,0x407,0x108,0xFE,0x403,0x0,0x108,0xFF,0x305,0x0,0x0,0x108,0x100,0x300,0x874,0x0,0x108,0x108,0x104,0x117,0x100,0x2,0x0,0x203,0x302,0x3D2,0x0,0x108,0x10A,0x100,0x3,0x0,0x280,0x108,0x10B,0x100,0x3,0x0,0x105,0x116,0x108,0x10C,0x40A,0x1,0x0,0x108,0x10E,0x104,0x117,0x100,0x1,0x0,0x200,0x302,0x960,0x0,0x108,0x111,0x406,0x1,0x108,0x112,0x100,0x1,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x115,0x406,0x1,0x108,0x116,0x100,0x5,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x11A,0x100,0x8,0x0,0x105,0xFFF2,0x108,0x11B,0x104,0xFFFF,0x100,0x1,0x0,0x20C,0x100,0xA,0x0,0x20E,0x100,0x1F3,0x0,0x20C,0x107,0x0,0xFFF2,0x108,0x11E,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x9D0,0x0,0x108,0x11F,0x300,0x9B0,0x0,0x108,0x122,0x406,0x0,0x108,0x123,0x100,0x64,0x0,0x407,0x108,0x124,0x300,0x3D2,0x0,0x108,0x127,0x100,0x1,0x0,0x105,0xFFF1,0x108,0x129,0x104,0xFFF7,0x100,0x4240,0xF,0x104,0xFFF1,0x20E,0x104,0xFFF9,0x104,0xFFF8,0x0,0x3,0x108,0x12A,0x100,0xA,0x0,0x407,0x108,0x12D,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x3D2,0x0,0x108,0x12E,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x205,0x302,0xA7E,0x0,0x108,0x12F,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x210,0x204,0x302,0xA7E,0x0,0x108,0x130,0x300,0xA28,0x0,0x108,0x133,0x104,0xFFF8,0x105,0xD,0x108,0x134,0x100,0xA,0x0,0x407,0x108,0x135,0x403,0x0,0x108,0x136,0x100,0x1F4,0x0,0x407,0x108,0x138,0x104,0xFFF7,0x104,0x24,0x210,0x100,0x1,0x0,0x104,0xFFF1,0x210,0x20E,0x20C,0x0,0x4,0x108,0x13A,0x305,0x0,0x0,0x108,0x13B,0x100,0x1F4,0x0,0x407,0x108,0x13C,0x408,0x108,0x13D,0x100,0xA,0x0,0x407,0x108,0x13E,0x300,0x7D6,0x0,0x108,0x142,0x104,0xFFF7,0x100,0x2,0x0,0x20E,0x104,0xFFEF,0x104,0xFFF9,0x104,0xFFF8,0x0,0x3,0x108,0x145,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x3D2,0x0,0x108,0x146,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x80E,0x0,0x108,0x147,0x100,0x1F4,0x0,0x407,0x108,0x148,0x305,0x0,0x0,0x108,0x149,0x100,0x7D0,0x0,0x407,0x108,0x14A,0x408,0x108,0x14D,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x14E,0x100,0x0,0x0,0x105,0xFFF2,0x108,0x14F,0x104,0xFFFF,0x100,0x1,0x0,0x20C,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF2,0x108,0x150,0x300,0x80,0x0,0x108,0x18E,0x401,0xFFFF,0x0,0x401,0xFFFF,0x0000
 };
unsigned short * __ipm_TransferStation_sbdata[] = { 
	__ipm_TransferStation_sb_StepperMotion_mopdata,NULL
 };
unsigned short __ipm_XAxis_sb_axis_X_mopdata[] = { 
	0x0,0x81,0x108,0x2,0x100,0x3E8,0x0,0x407,0x108,0xA,0x100,0x2,0x0,0x105,0xFFFF,0x108,0xF,0x100,0x3E8,0x0,0x407,0x108,0x10,0x100,0x4,0x0,0x105,0xFFFF,0x108,0x14,0x104,0xFFFE,0x100,0xA,0x0,0x201,0x302,0x34,0x0,0x108,0x16,0x100,0x2,0x0,0x105,0x132,0x108,0x17,0x100,0x3,0x0,0x105,0x133,0x108,0x18,0x104,0xFFFD,0x105,0x124,0x108,0x19,0x104,0xFFFC,0x105,0x125,0x108,0x1A,0x104,0xFFFF,0x104,0xFFFB,0x104,0xFFFA,0x104,0xFFF9,0x0,0x3,0x108,0x1B,0x305,0x0,0x0,0x108,0x1D,0x100,0x0,0x0,0x105,0xFFFE,0x108,0x1E,0x100,0x0,0x0,0x105,0xFFF8,0x108,0x1F,0x100,0x1FE,0x0,0x107,0x0,0xFFF8,0x108,0x20,0x100,0x0,0x0,0x105,0x132,0x108,0x21,0x100,0x0,0x0,0x105,0x133,0x108,0x22,0x300,0x34,0x0,0x108,0x25,0x401,0xFFFF,0x0,0x401,0xFFFF,0x0000
 };
unsigned short __ipm_XAxis_sb_Motion_mopdata[] = { 
	0x0,0x522,0x108,0x3,0x100,0xBB8,0x0,0x407,0x108,0x6,0x104,0x117,0x105,0xFFF7,0x108,0xE,0x100,0x0,0x0,0x105,0xE,0x108,0x13,0x100,0x12C,0x0,0x407,0x108,0x16,0x404,0x108,0x17,0x408,0x108,0x19,0x100,0x64,0x0,0x407,0x108,0x1F,0x100,0x0,0x0,0x105,0xFFF6,0x108,0x22,0x100,0x0,0x0,0x105,0xFFFE,0x108,0x23,0x100,0x1,0x0,0x105,0xFFF5,0x108,0x24,0x100,0x1,0x0,0x105,0xFFF4,0x108,0x25,0x100,0x64,0x0,0x105,0xF,0x108,0x28,0x104,0xFFF5,0x100,0x0,0x0,0x200,0x302,0x90,0x0,0x108,0x2B,0x104,0xFFFE,0x100,0x1,0x0,0x200,0x104,0xFFFE,0x100,0xB,0x0,0x200,0x209,0x302,0x1D2,0x0,0x108,0x2C,0x104,0xFFFE,0x100,0x3,0x0,0x200,0x302,0x432,0x0,0x108,0x2D,0x104,0xFFFE,0x100,0x4,0x0,0x200,0x302,0x4E2,0x0,0x108,0x2E,0x104,0xFFFE,0x100,0x5,0x0,0x200,0x302,0x592,0x0,0x108,0x2F,0x104,0xFFFE,0x100,0x6,0x0,0x200,0x302,0x16E,0x0,0x108,0x30,0x104,0xFFFE,0x100,0x7,0x0,0x200,0x302,0x18C,0x0,0x108,0x31,0x104,0xFFFE,0x100,0x8,0x0,0x200,0x302,0x77A,0x0,0x108,0x32,0x104,0xFFFE,0x100,0x9,0x0,0x200,0x302,0x1AA,0x0,0x108,0x33,0x300,0xA6,0x0,0x108,0x36,0x405,0x108,0x37,0x100,0x0,0x0,0x105,0xFFFE,0x108,0x38,0x300,0xA6,0x0,0x108,0x3B,0x404,0x108,0x3C,0x100,0x0,0x0,0x105,0xFFFE,0x108,0x3D,0x300,0xA6,0x0,0x108,0x41,0x100,0x0,0x0,0x104,0xFFF3,0x0,0x10,0x108,0x42,0x100,0xA,0x0,0x407,0x108,0x43,0x300,0x364,0x0,0x108,0x4A,0x104,0xFFFA,0x100,0x0,0x0,0x204,0x302,0x1F2,0x0,0x108,0x4B,0x300,0x208,0x0,0x108,0x4E,0x104,0xFFFA,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFFA,0x108,0x51,0x104,0xFFF9,0x100,0x0,0x0,0x204,0x302,0x228,0x0,0x108,0x52,0x300,0x23E,0x0,0x108,0x54,0x104,0xFFF9,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF9,0x108,0x57,0x104,0xFFF2,0x100,0x0,0x0,0x204,0x302,0x3D4,0x0,0x108,0x59,0x300,0x274,0x0,0x108,0x5A,0x104,0xFFF2,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF2,0x108,0x69,0x104,0xFFF2,0x100,0x3E8,0x0,0x20F,0x104,0xFFF1,0x100,0x3E8,0x0,0x20F,0x104,0xFFFA,0x100,0x3E8,0x0,0x20F,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0x6D,0x100,0x1,0x0,0x105,0x52,0x108,0x6E,0x100,0x0,0x0,0x105,0xFFF0,0x108,0x6F,0x104,0xFFFE,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x70,0x104,0xFFFE,0x100,0xB,0x0,0x200,0x302,0x274,0x0,0x108,0x71,0x300,0x2FE,0x0,0x108,0x75,0x104,0xFFFE,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x76,0x100,0x5,0x0,0x407,0x108,0x77,0x104,0xB0,0x105,0xFFF0,0x108,0x78,0x104,0xFFF0,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0x79,0x104,0xFFF0,0x100,0x2,0x0,0x201,0x302,0x2FE,0x0,0x108,0x7A,0x300,0x3D4,0x0,0x108,0x80,0x100,0x0,0x0,0x105,0x52,0x108,0x82,0x100,0x0,0x0,0x105,0xFFF8,0x108,0x83,0x104,0xFFF7,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF8,0x108,0x84,0x104,0xFFF9,0x105,0xD,0x108,0x85,0x100,0x2,0x0,0x407,0x108,0x86,0x403,0x0,0x108,0x89,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x3BE,0x0,0x108,0x96,0x100,0xC8,0x0,0x407,0x108,0x98,0x100,0x0,0x0,0x105,0x52,0x108,0x99,0x100,0x0,0x0,0x105,0xFFF8,0x108,0x9A,0x104,0xFFF7,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF8,0x108,0x9B,0x100,0x0,0x0,0x105,0xFFFE,0x108,0x9C,0x300,0xA6,0x0,0x108,0xA4,0x104,0xFFF2,0x100,0x3E8,0x0,0x20F,0x104,0x2A,0x104,0xFFFA,0x100,0x3E8,0x0,0x20F,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xA5,0x100,0x64,0x0,0x407,0x108,0xA6,0x100,0x1,0x0,0x105,0x52,0x108,0xA9,0x104,0xFFFE,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xAA,0x100,0x5,0x0,0x407,0x108,0xAB,0x104,0xB0,0x105,0xFFF0,0x108,0xAC,0x104,0xFFF0,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0xAD,0x104,0xFFF0,0x100,0x2,0x0,0x201,0x302,0x47C,0x0,0x108,0xAE,0x300,0x364,0x0,0x108,0xB2,0x104,0xFFF2,0x100,0x3E8,0x0,0x20F,0x104,0x2B,0x104,0xFFFA,0x100,0x3E8,0x0,0x20F,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xB3,0x100,0x64,0x0,0x407,0x108,0xB4,0x100,0x1,0x0,0x105,0x52,0x108,0xB7,0x104,0xFFFE,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xB8,0x100,0x5,0x0,0x407,0x108,0xB9,0x104,0xB0,0x105,0xFFF0,0x108,0xBA,0x104,0xFFF0,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0xBB,0x104,0xFFF0,0x100,0x2,0x0,0x201,0x302,0x52C,0x0,0x108,0xBC,0x300,0x364,0x0,0x108,0xC5,0x100,0x0,0x0,0x105,0xE,0x108,0xC9,0x100,0xFA,0x0,0x105,0x118,0x108,0xCB,0x100,0xB,0x0,0x105,0x121,0x108,0xCC,0x103,0x0,0x3FD0,0x0,0x0,0x105,0x11F,0x108,0xCD,0x103,0x9999,0x3FB9,0x999A,0x9999,0x105,0x120,0x108,0xCE,0x100,0x8,0x0,0x105,0xE,0x108,0xCF,0x100,0x0,0x0,0x100,0xA,0x0,0x100,0xA,0x0,0x0,0x1,0x108,0xD3,0x104,0xFFFE,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xD4,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x608,0x0,0x108,0xD9,0x100,0x0,0x0,0x105,0xE,0x108,0xDE,0x103,0x9999,0x3FB9,0x999A,0x9999,0x100,0x0,0x0,0x100,0xA,0x0,0x100,0xA,0x0,0x0,0x3,0x108,0xDF,0x305,0x0,0x0,0x108,0xE3,0x100,0xC8,0x0,0x407,0x108,0xE6,0x104,0xFFF2,0x100,0x3E8,0x0,0x20F,0x104,0xFFEF,0x104,0xFFFA,0x100,0x3E8,0x0,0x20F,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xEB,0x104,0xFFFE,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xEC,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x6AC,0x0,0x108,0xED,0x100,0x1F4,0x0,0x407,0x108,0xEE,0x305,0x0,0x0,0x108,0xF0,0x408,0x108,0xF4,0x100,0x0,0x0,0x105,0xFFFE,0x108,0xF5,0x100,0x0,0x0,0x105,0xFFF8,0x108,0xF6,0x104,0xFFF7,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF8,0x108,0xF7,0x300,0xA6,0x0,0x108,0xFA,0x100,0x0,0x0,0x105,0xE,0x108,0xFB,0x100,0xC8,0x0,0x407,0x108,0xFD,0x100,0x2,0x0,0x407,0x108,0xFE,0x403,0x0,0x108,0xFF,0x305,0x0,0x0,0x108,0x100,0x300,0x6F4,0x0,0x108,0x108,0x104,0x117,0x100,0x2,0x0,0x203,0x302,0x364,0x0,0x108,0x10A,0x100,0x3,0x0,0x280,0x108,0x10B,0x100,0x3,0x0,0x105,0x116,0x108,0x10C,0x40A,0x1,0x0,0x108,0x10E,0x104,0x117,0x100,0x1,0x0,0x200,0x302,0x7E6,0x0,0x108,0x111,0x406,0x1,0x108,0x112,0x100,0x1,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x115,0x406,0x1,0x108,0x116,0x100,0x5,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x11A,0x100,0x8,0x0,0x105,0xFFF8,0x108,0x11B,0x104,0xFFF7,0x100,0xA,0x0,0x20E,0x100,0x1F3,0x0,0x20C,0x107,0x0,0xFFF8,0x108,0x11E,0x104,0xFFFE,0x100,0x0,0x0,0x200,0x302,0x84E,0x0,0x108,0x11F,0x300,0x82E,0x0,0x108,0x122,0x406,0x0,0x108,0x123,0x100,0x64,0x0,0x407,0x108,0x124,0x300,0x364,0x0,0x108,0x127,0x100,0x1,0x0,0x105,0xFFEE,0x108,0x129,0x104,0xFFF2,0x100,0x4240,0xF,0x104,0xFFEE,0x20E,0x104,0xFFFA,0x104,0xFFF9,0x0,0x3,0x108,0x12A,0x100,0xA,0x0,0x407,0x108,0x12D,0x104,0xFFFE,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x12E,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x205,0x302,0x8FC,0x0,0x108,0x12F,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x210,0x204,0x302,0x8FC,0x0,0x108,0x130,0x300,0x8A6,0x0,0x108,0x133,0x104,0xFFF9,0x105,0xD,0x108,0x134,0x100,0xA,0x0,0x407,0x108,0x135,0x403,0x0,0x108,0x136,0x100,0x1F4,0x0,0x407,0x108,0x138,0x104,0xFFF2,0x104,0x24,0x210,0x100,0x1,0x0,0x104,0xFFEE,0x210,0x20E,0x20C,0x0,0x4,0x108,0x13A,0x305,0x0,0x0,0x108,0x13B,0x100,0x1F4,0x0,0x407,0x108,0x13C,0x408,0x108,0x13D,0x100,0xA,0x0,0x407,0x108,0x13E,0x300,0x97C,0x0,0x108,0x142,0x104,0xFFF2,0x100,0x2,0x0,0x20E,0x104,0xFFEF,0x104,0xFFFA,0x104,0xFFF9,0x0,0x3,0x108,0x145,0x104,0xFFFE,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x146,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x99C,0x0,0x108,0x147,0x100,0x1F4,0x0,0x407,0x108,0x148,0x305,0x0,0x0,0x108,0x149,0x100,0x7D0,0x0,0x407,0x108,0x14A,0x408,0x108,0x14D,0x100,0x0,0x0,0x105,0xFFFE,0x108,0x14E,0x100,0x0,0x0,0x105,0xFFF8,0x108,0x14F,0x104,0xFFF7,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF8,0x108,0x150,0x300,0xA6,0x0,0x108,0x196,0x401,0xFFFF,0x0,0x401,0xFFFF,0x0000
 };
unsigned short * __ipm_XAxis_sbdata[] = { 
	__ipm_XAxis_sb_axis_X_mopdata,__ipm_XAxis_sb_Motion_mopdata,NULL
 };
unsigned short __ipm_YAxis_sb_axis_Y_mopdata[] = { 
	0x0,0x13,0x108,0x2,0x100,0x3E8,0x0,0x407,0x108,0x8,0x300,0xC,0x0,0x108,0xA,0x401,0xFFFF,0x0,0x401,0xFFFF,0x0000
 };
unsigned short __ipm_YAxis_sb_Motion_mopdata[] = { 
	0x0,0x522,0x108,0x3,0x100,0xBB8,0x0,0x407,0x108,0x6,0x104,0x117,0x105,0xFFFF,0x108,0xE,0x100,0x0,0x0,0x105,0xE,0x108,0x13,0x100,0x12C,0x0,0x407,0x108,0x16,0x404,0x108,0x17,0x408,0x108,0x19,0x100,0x64,0x0,0x407,0x108,0x1F,0x100,0x0,0x0,0x105,0xFFFE,0x108,0x22,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x23,0x100,0x1,0x0,0x105,0xFFFC,0x108,0x24,0x100,0x1,0x0,0x105,0xFFFB,0x108,0x25,0x100,0x64,0x0,0x105,0xF,0x108,0x28,0x104,0xFFFC,0x100,0x0,0x0,0x200,0x302,0x90,0x0,0x108,0x2B,0x104,0xFFFD,0x100,0x1,0x0,0x200,0x104,0xFFFD,0x100,0xB,0x0,0x200,0x209,0x302,0x1D2,0x0,0x108,0x2C,0x104,0xFFFD,0x100,0x3,0x0,0x200,0x302,0x432,0x0,0x108,0x2D,0x104,0xFFFD,0x100,0x4,0x0,0x200,0x302,0x4E2,0x0,0x108,0x2E,0x104,0xFFFD,0x100,0x5,0x0,0x200,0x302,0x592,0x0,0x108,0x2F,0x104,0xFFFD,0x100,0x6,0x0,0x200,0x302,0x16E,0x0,0x108,0x30,0x104,0xFFFD,0x100,0x7,0x0,0x200,0x302,0x18C,0x0,0x108,0x31,0x104,0xFFFD,0x100,0x8,0x0,0x200,0x302,0x77A,0x0,0x108,0x32,0x104,0xFFFD,0x100,0x9,0x0,0x200,0x302,0x1AA,0x0,0x108,0x33,0x300,0xA6,0x0,0x108,0x36,0x405,0x108,0x37,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x38,0x300,0xA6,0x0,0x108,0x3B,0x404,0x108,0x3C,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x3D,0x300,0xA6,0x0,0x108,0x41,0x100,0x0,0x0,0x104,0xFFFA,0x0,0x10,0x108,0x42,0x100,0xA,0x0,0x407,0x108,0x43,0x300,0x364,0x0,0x108,0x4A,0x104,0xFFF9,0x100,0x0,0x0,0x204,0x302,0x1F2,0x0,0x108,0x4B,0x300,0x208,0x0,0x108,0x4E,0x104,0xFFF9,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF9,0x108,0x51,0x104,0xFFF8,0x100,0x0,0x0,0x204,0x302,0x228,0x0,0x108,0x52,0x300,0x23E,0x0,0x108,0x54,0x104,0xFFF8,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF8,0x108,0x57,0x104,0xFFF7,0x100,0x0,0x0,0x204,0x302,0x3D4,0x0,0x108,0x59,0x300,0x274,0x0,0x108,0x5A,0x104,0xFFF7,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF7,0x108,0x69,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0xFFF6,0x100,0x3E8,0x0,0x20F,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0x6D,0x100,0x1,0x0,0x105,0x52,0x108,0x6E,0x100,0x0,0x0,0x105,0xFFF5,0x108,0x6F,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x70,0x104,0xFFFD,0x100,0xB,0x0,0x200,0x302,0x274,0x0,0x108,0x71,0x300,0x2FE,0x0,0x108,0x75,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x76,0x100,0x5,0x0,0x407,0x108,0x77,0x104,0xB0,0x105,0xFFF5,0x108,0x78,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0x79,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x2FE,0x0,0x108,0x7A,0x300,0x3D4,0x0,0x108,0x80,0x100,0x0,0x0,0x105,0x52,0x108,0x82,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x83,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x84,0x104,0xFFF8,0x105,0xD,0x108,0x85,0x100,0x2,0x0,0x407,0x108,0x86,0x403,0x0,0x108,0x89,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x3BE,0x0,0x108,0x96,0x100,0xC8,0x0,0x407,0x108,0x98,0x100,0x0,0x0,0x105,0x52,0x108,0x99,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x9A,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x9B,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x9C,0x300,0xA6,0x0,0x108,0xA4,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x2A,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xA5,0x100,0x64,0x0,0x407,0x108,0xA6,0x100,0x1,0x0,0x105,0x52,0x108,0xA9,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xAA,0x100,0x5,0x0,0x407,0x108,0xAB,0x104,0xB0,0x105,0xFFF5,0x108,0xAC,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0xAD,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x47C,0x0,0x108,0xAE,0x300,0x364,0x0,0x108,0xB2,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x2B,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xB3,0x100,0x64,0x0,0x407,0x108,0xB4,0x100,0x1,0x0,0x105,0x52,0x108,0xB7,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xB8,0x100,0x5,0x0,0x407,0x108,0xB9,0x104,0xB0,0x105,0xFFF5,0x108,0xBA,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0xBB,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x52C,0x0,0x108,0xBC,0x300,0x364,0x0,0x108,0xC5,0x100,0x0,0x0,0x105,0xE,0x108,0xC9,0x100,0xFA,0x0,0x105,0x118,0x108,0xCB,0x100,0xB,0x0,0x105,0x121,0x108,0xCC,0x103,0x0,0x3FD0,0x0,0x0,0x105,0x11F,0x108,0xCD,0x103,0x9999,0x3FB9,0x999A,0x9999,0x105,0x120,0x108,0xCE,0x100,0x8,0x0,0x105,0xE,0x108,0xCF,0x100,0x0,0x0,0x100,0xA,0x0,0x100,0xA,0x0,0x0,0x1,0x108,0xD3,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xD4,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x608,0x0,0x108,0xD9,0x100,0x0,0x0,0x105,0xE,0x108,0xDE,0x103,0x9999,0x3FB9,0x999A,0x9999,0x100,0x0,0x0,0x100,0xA,0x0,0x100,0xA,0x0,0x0,0x3,0x108,0xDF,0x305,0x0,0x0,0x108,0xE3,0x100,0xC8,0x0,0x407,0x108,0xE6,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0xFFF3,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xEB,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xEC,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x6AC,0x0,0x108,0xED,0x100,0x1F4,0x0,0x407,0x108,0xEE,0x305,0x0,0x0,0x108,0xF0,0x408,0x108,0xF4,0x100,0x0,0x0,0x105,0xFFFD,0x108,0xF5,0x100,0x0,0x0,0x105,0xFFF4,0x108,0xF6,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0xF7,0x300,0xA6,0x0,0x108,0xFA,0x100,0x0,0x0,0x105,0xE,0x108,0xFB,0x100,0xC8,0x0,0x407,0x108,0xFD,0x100,0x2,0x0,0x407,0x108,0xFE,0x403,0x0,0x108,0xFF,0x305,0x0,0x0,0x108,0x100,0x300,0x6F4,0x0,0x108,0x108,0x104,0x117,0x100,0x2,0x0,0x203,0x302,0x364,0x0,0x108,0x10A,0x100,0x3,0x0,0x280,0x108,0x10B,0x100,0x3,0x0,0x105,0x116,0x108,0x10C,0x40A,0x1,0x0,0x108,0x10E,0x104,0x117,0x100,0x1,0x0,0x200,0x302,0x7E6,0x0,0x108,0x111,0x406,0x1,0x108,0x112,0x100,0x1,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x115,0x406,0x1,0x108,0x116,0x100,0x5,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x11A,0x100,0x8,0x0,0x105,0xFFF4,0x108,0x11B,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F3,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x11E,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x84E,0x0,0x108,0x11F,0x300,0x82E,0x0,0x108,0x122,0x406,0x0,0x108,0x123,0x100,0x64,0x0,0x407,0x108,0x124,0x300,0x364,0x0,0x108,0x127,0x100,0x1,0x0,0x105,0xFFF2,0x108,0x129,0x104,0xFFF7,0x100,0x4240,0xF,0x104,0xFFF2,0x20E,0x104,0xFFF9,0x104,0xFFF8,0x0,0x3,0x108,0x12A,0x100,0xA,0x0,0x407,0x108,0x12D,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x12E,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x205,0x302,0x8FC,0x0,0x108,0x12F,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x210,0x204,0x302,0x8FC,0x0,0x108,0x130,0x300,0x8A6,0x0,0x108,0x133,0x104,0xFFF8,0x105,0xD,0x108,0x134,0x100,0xA,0x0,0x407,0x108,0x135,0x403,0x0,0x108,0x136,0x100,0x1F4,0x0,0x407,0x108,0x138,0x104,0xFFF7,0x104,0x24,0x210,0x100,0x1,0x0,0x104,0xFFF2,0x210,0x20E,0x20C,0x0,0x4,0x108,0x13A,0x305,0x0,0x0,0x108,0x13B,0x100,0x1F4,0x0,0x407,0x108,0x13C,0x408,0x108,0x13D,0x100,0xA,0x0,0x407,0x108,0x13E,0x300,0x97C,0x0,0x108,0x142,0x104,0xFFF7,0x100,0x2,0x0,0x20E,0x104,0xFFF3,0x104,0xFFF9,0x104,0xFFF8,0x0,0x3,0x108,0x145,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x146,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x99C,0x0,0x108,0x147,0x100,0x1F4,0x0,0x407,0x108,0x148,0x305,0x0,0x0,0x108,0x149,0x100,0x7D0,0x0,0x407,0x108,0x14A,0x408,0x108,0x14D,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x14E,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x14F,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x150,0x300,0xA6,0x0,0x108,0x196,0x401,0xFFFF,0x0,0x401,0xFFFF,0x0000
 };
unsigned short * __ipm_YAxis_sbdata[] = { 
	__ipm_YAxis_sb_axis_Y_mopdata,__ipm_YAxis_sb_Motion_mopdata,NULL
 };
unsigned short __ipm_ZAxis_sb_axis_Z_mopdata[] = { 
	0x0,0x13,0x108,0x2,0x100,0x3E8,0x0,0x407,0x108,0x8,0x300,0xC,0x0,0x108,0xA,0x401,0xFFFF,0x0,0x401,0xFFFF,0x0000
 };
unsigned short __ipm_ZAxis_sb_Motion_mopdata[] = { 
	0x0,0x522,0x108,0x3,0x100,0xBB8,0x0,0x407,0x108,0x6,0x104,0x117,0x105,0xFFFF,0x108,0xE,0x100,0x0,0x0,0x105,0xE,0x108,0x13,0x100,0x12C,0x0,0x407,0x108,0x16,0x404,0x108,0x17,0x408,0x108,0x19,0x100,0x64,0x0,0x407,0x108,0x1F,0x100,0x0,0x0,0x105,0xFFFE,0x108,0x22,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x23,0x100,0x1,0x0,0x105,0xFFFC,0x108,0x24,0x100,0x1,0x0,0x105,0xFFFB,0x108,0x25,0x100,0x64,0x0,0x105,0xF,0x108,0x28,0x104,0xFFFC,0x100,0x0,0x0,0x200,0x302,0x90,0x0,0x108,0x2B,0x104,0xFFFD,0x100,0x1,0x0,0x200,0x104,0xFFFD,0x100,0xB,0x0,0x200,0x209,0x302,0x1D2,0x0,0x108,0x2C,0x104,0xFFFD,0x100,0x3,0x0,0x200,0x302,0x432,0x0,0x108,0x2D,0x104,0xFFFD,0x100,0x4,0x0,0x200,0x302,0x4E2,0x0,0x108,0x2E,0x104,0xFFFD,0x100,0x5,0x0,0x200,0x302,0x592,0x0,0x108,0x2F,0x104,0xFFFD,0x100,0x6,0x0,0x200,0x302,0x16E,0x0,0x108,0x30,0x104,0xFFFD,0x100,0x7,0x0,0x200,0x302,0x18C,0x0,0x108,0x31,0x104,0xFFFD,0x100,0x8,0x0,0x200,0x302,0x77A,0x0,0x108,0x32,0x104,0xFFFD,0x100,0x9,0x0,0x200,0x302,0x1AA,0x0,0x108,0x33,0x300,0xA6,0x0,0x108,0x36,0x405,0x108,0x37,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x38,0x300,0xA6,0x0,0x108,0x3B,0x404,0x108,0x3C,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x3D,0x300,0xA6,0x0,0x108,0x41,0x100,0x0,0x0,0x104,0xFFFA,0x0,0x10,0x108,0x42,0x100,0xA,0x0,0x407,0x108,0x43,0x300,0x364,0x0,0x108,0x4A,0x104,0xFFF9,0x100,0x0,0x0,0x204,0x302,0x1F2,0x0,0x108,0x4B,0x300,0x208,0x0,0x108,0x4E,0x104,0xFFF9,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF9,0x108,0x51,0x104,0xFFF8,0x100,0x0,0x0,0x204,0x302,0x228,0x0,0x108,0x52,0x300,0x23E,0x0,0x108,0x54,0x104,0xFFF8,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF8,0x108,0x57,0x104,0xFFF7,0x100,0x0,0x0,0x204,0x302,0x3D4,0x0,0x108,0x59,0x300,0x274,0x0,0x108,0x5A,0x104,0xFFF7,0x100,0x1,0x0,0x210,0x20E,0x105,0xFFF7,0x108,0x69,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0xFFF6,0x100,0x3E8,0x0,0x20F,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0x6D,0x100,0x1,0x0,0x105,0x52,0x108,0x6E,0x100,0x0,0x0,0x105,0xFFF5,0x108,0x6F,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x70,0x104,0xFFFD,0x100,0xB,0x0,0x200,0x302,0x274,0x0,0x108,0x71,0x300,0x2FE,0x0,0x108,0x75,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x76,0x100,0x5,0x0,0x407,0x108,0x77,0x104,0xB0,0x105,0xFFF5,0x108,0x78,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0x79,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x2FE,0x0,0x108,0x7A,0x300,0x3D4,0x0,0x108,0x80,0x100,0x0,0x0,0x105,0x52,0x108,0x82,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x83,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x84,0x104,0xFFF8,0x105,0xD,0x108,0x85,0x100,0x2,0x0,0x407,0x108,0x86,0x403,0x0,0x108,0x89,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x3BE,0x0,0x108,0x96,0x100,0xC8,0x0,0x407,0x108,0x98,0x100,0x0,0x0,0x105,0x52,0x108,0x99,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x9A,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x9B,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x9C,0x300,0xA6,0x0,0x108,0xA4,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x2A,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xA5,0x100,0x64,0x0,0x407,0x108,0xA6,0x100,0x1,0x0,0x105,0x52,0x108,0xA9,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xAA,0x100,0x5,0x0,0x407,0x108,0xAB,0x104,0xB0,0x105,0xFFF5,0x108,0xAC,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0xAD,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x47C,0x0,0x108,0xAE,0x300,0x364,0x0,0x108,0xB2,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0x2B,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xB3,0x100,0x64,0x0,0x407,0x108,0xB4,0x100,0x1,0x0,0x105,0x52,0x108,0xB7,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xB8,0x100,0x5,0x0,0x407,0x108,0xB9,0x104,0xB0,0x105,0xFFF5,0x108,0xBA,0x104,0xFFF5,0x100,0x1,0x0,0x210,0x200,0x302,0x372,0x0,0x108,0xBB,0x104,0xFFF5,0x100,0x2,0x0,0x201,0x302,0x52C,0x0,0x108,0xBC,0x300,0x364,0x0,0x108,0xC5,0x100,0x0,0x0,0x105,0xE,0x108,0xC9,0x100,0xFA,0x0,0x105,0x118,0x108,0xCB,0x100,0xB,0x0,0x105,0x121,0x108,0xCC,0x103,0x0,0x3FD0,0x0,0x0,0x105,0x11F,0x108,0xCD,0x103,0x9999,0x3FB9,0x999A,0x9999,0x105,0x120,0x108,0xCE,0x100,0x8,0x0,0x105,0xE,0x108,0xCF,0x100,0x0,0x0,0x100,0xA,0x0,0x100,0xA,0x0,0x0,0x1,0x108,0xD3,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xD4,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x608,0x0,0x108,0xD9,0x100,0x0,0x0,0x105,0xE,0x108,0xDE,0x103,0x9999,0x3FB9,0x999A,0x9999,0x100,0x0,0x0,0x100,0xA,0x0,0x100,0xA,0x0,0x0,0x3,0x108,0xDF,0x305,0x0,0x0,0x108,0xE3,0x100,0xC8,0x0,0x407,0x108,0xE6,0x104,0xFFF7,0x100,0x3E8,0x0,0x20F,0x104,0xFFF3,0x104,0xFFF9,0x100,0x3E8,0x0,0x20F,0x104,0xFFF8,0x100,0x3E8,0x0,0x20F,0x0,0x3,0x108,0xEB,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0xEC,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x6AC,0x0,0x108,0xED,0x100,0x1F4,0x0,0x407,0x108,0xEE,0x305,0x0,0x0,0x108,0xF0,0x408,0x108,0xF4,0x100,0x0,0x0,0x105,0xFFFD,0x108,0xF5,0x100,0x0,0x0,0x105,0xFFF4,0x108,0xF6,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0xF7,0x300,0xA6,0x0,0x108,0xFA,0x100,0x0,0x0,0x105,0xE,0x108,0xFB,0x100,0xC8,0x0,0x407,0x108,0xFD,0x100,0x2,0x0,0x407,0x108,0xFE,0x403,0x0,0x108,0xFF,0x305,0x0,0x0,0x108,0x100,0x300,0x6F4,0x0,0x108,0x108,0x104,0x117,0x100,0x2,0x0,0x203,0x302,0x364,0x0,0x108,0x10A,0x100,0x3,0x0,0x280,0x108,0x10B,0x100,0x3,0x0,0x105,0x116,0x108,0x10C,0x40A,0x1,0x0,0x108,0x10E,0x104,0x117,0x100,0x1,0x0,0x200,0x302,0x7E6,0x0,0x108,0x111,0x406,0x1,0x108,0x112,0x100,0x1,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x115,0x406,0x1,0x108,0x116,0x100,0x5,0x0,0x100,0x1,0x0,0x0,0x200,0x108,0x11A,0x100,0x8,0x0,0x105,0xFFF4,0x108,0x11B,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F3,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x11E,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x84E,0x0,0x108,0x11F,0x300,0x82E,0x0,0x108,0x122,0x406,0x0,0x108,0x123,0x100,0x64,0x0,0x407,0x108,0x124,0x300,0x364,0x0,0x108,0x127,0x100,0x1,0x0,0x105,0xFFF2,0x108,0x129,0x104,0xFFF7,0x100,0x4240,0xF,0x104,0xFFF2,0x20E,0x104,0xFFF9,0x104,0xFFF8,0x0,0x3,0x108,0x12A,0x100,0xA,0x0,0x407,0x108,0x12D,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x12E,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x205,0x302,0x8FC,0x0,0x108,0x12F,0x104,0x5,0x103,0xCCCC,0x3FEC,0xCCCD,0xCCCC,0x210,0x204,0x302,0x8FC,0x0,0x108,0x130,0x300,0x8A6,0x0,0x108,0x133,0x104,0xFFF8,0x105,0xD,0x108,0x134,0x100,0xA,0x0,0x407,0x108,0x135,0x403,0x0,0x108,0x136,0x100,0x1F4,0x0,0x407,0x108,0x138,0x104,0xFFF7,0x104,0x24,0x210,0x100,0x1,0x0,0x104,0xFFF2,0x210,0x20E,0x20C,0x0,0x4,0x108,0x13A,0x305,0x0,0x0,0x108,0x13B,0x100,0x1F4,0x0,0x407,0x108,0x13C,0x408,0x108,0x13D,0x100,0xA,0x0,0x407,0x108,0x13E,0x300,0x97C,0x0,0x108,0x142,0x104,0xFFF7,0x100,0x2,0x0,0x20E,0x104,0xFFF3,0x104,0xFFF9,0x104,0xFFF8,0x0,0x3,0x108,0x145,0x104,0xFFFD,0x100,0x0,0x0,0x200,0x302,0x364,0x0,0x108,0x146,0x104,0xB0,0x100,0x2,0x0,0x201,0x302,0x99C,0x0,0x108,0x147,0x100,0x1F4,0x0,0x407,0x108,0x148,0x305,0x0,0x0,0x108,0x149,0x100,0x7D0,0x0,0x407,0x108,0x14A,0x408,0x108,0x14D,0x100,0x0,0x0,0x105,0xFFFD,0x108,0x14E,0x100,0x0,0x0,0x105,0xFFF4,0x108,0x14F,0x104,0xFFFF,0x100,0xA,0x0,0x20E,0x100,0x1F4,0x0,0x20C,0x107,0x0,0xFFF4,0x108,0x150,0x300,0xA6,0x0,0x108,0x196,0x401,0xFFFF,0x0,0x401,0xFFFF,0x0000
 };
unsigned short * __ipm_ZAxis_sbdata[] = { 
	__ipm_ZAxis_sb_axis_Z_mopdata,__ipm_ZAxis_sb_Motion_mopdata,NULL
 };
int __QS4IPM_NUMBER[] = { 
5,6,8,4,3,7,0,1,2,
 };
unsigned short ** __QS4IPMs[] = { 
	__ipm_EmptyAxis1_sbdata,__ipm_EmptyAxis2_sbdata,__ipm_EmptyAxis3_sbdata,__ipm_Gripper_sbdata,__ipm_ThetaAxis_sbdata,__ipm_TransferStation_sbdata,__ipm_XAxis_sbdata,__ipm_YAxis_sbdata,__ipm_ZAxis_sbdata,NULL
 };
IPMPARAM __ipm_EmptyAxis1_param[] = { {8,10000},{9,1000000},{10,1000000},{12,1},{13,100000},{14,0},{15,1},{16,1000},{17,0.8},{18,0.1},{19,0},{20,0},{21,0},{22,0},{23,10},{24,0},{25,0},{26,1048576},{27,1048576},{28,1},{29,1},{35,0},{41,0.01},{42,1E+50},{43,-1E+50},{44,0},{45,0},{48,0},{71,0},{72,0},{73,0},{79,200},{80,0.001},{81,0},{82,0},{90,1},{91,10000},{117,0},{118,0},{170,0},{171,0},{172,0},{173,0},{286,0},{315,0},{316,0},{0xffff,0} };
IPMPARAM __ipm_EmptyAxis2_param[] = { {8,10000},{9,1000000},{10,1000000},{12,1},{13,100000},{14,0},{15,1},{16,1000},{17,0.8},{18,0.1},{19,0},{20,0},{21,0},{22,0},{23,10},{24,0},{25,0},{26,1048576},{27,1048576},{28,1},{29,1},{35,0},{41,0.01},{42,1E+50},{43,-1E+50},{44,0},{45,0},{48,0},{71,0},{72,0},{73,0},{79,200},{80,0.001},{81,0},{82,0},{90,1},{91,10000},{117,0},{118,0},{170,0},{171,0},{172,0},{173,0},{286,0},{315,0},{316,0},{0xffff,0} };
IPMPARAM __ipm_EmptyAxis3_param[] = { {8,10000},{9,1000000},{10,1000000},{12,1},{13,100000},{14,2},{15,1},{16,1000},{17,0.8},{18,0.1},{19,0},{20,0},{21,0},{22,0},{23,10},{24,0},{25,0},{26,10000},{27,1048576},{28,1},{29,1},{35,0},{41,0.01},{42,1E+50},{43,-1E+50},{44,0},{45,0},{48,0},{71,0},{72,0},{73,5},{79,200},{80,0.001},{81,0},{82,0},{90,1},{91,200},{117,0},{118,0},{170,0},{171,0},{172,0},{173,0},{286,0},{315,0},{316,0},{0xffff,0} };
IPMPARAM __ipm_Gripper_param[] = { {8,10000},{9,1000000},{10,1000000},{12,1},{13,100000},{14,0},{15,1},{16,333},{17,0.8},{18,0.1},{19,0},{20,0},{21,0},{22,0},{23,10},{24,0},{25,0},{26,6},{27,1048576},{28,18},{29,10},{35,0},{41,0.01},{42,1E+50},{43,-1E+50},{44,0},{45,0},{48,0},{71,0},{72,0},{73,0},{79,200},{80,0.001},{81,0},{82,0},{90,1},{91,10000},{117,0},{118,0},{170,0},{171,0},{172,0},{173,0},{286,0},{315,0},{316,0},{0xffff,0} };
IPMPARAM __ipm_ThetaAxis_param[] = { {8,10000},{9,1000000},{10,1000000},{12,1},{13,100},{14,0},{15,1},{16,1800},{17,0.8},{18,0.1},{19,0},{20,0},{21,0},{22,0},{23,10},{24,0},{25,0},{26,1280000},{27,1048576},{28,1},{29,36},{35,0},{41,3.6},{42,360},{43,-360},{44,0},{45,0},{48,0},{71,0},{72,0},{73,0},{79,200},{80,0.001},{81,0},{82,0},{90,1},{91,10000},{117,0},{118,0},{170,0},{171,0},{172,0},{173,0},{286,0},{315,0},{316,0},{0xffff,0} };
IPMPARAM __ipm_TransferStation_param[] = { {8,10000},{9,1000000},{10,1000000},{12,1},{13,100000},{14,2},{15,1},{16,1000},{17,0.8},{18,0.1},{19,0},{20,0},{21,0},{22,0},{23,10},{24,0},{25,0},{26,10000},{27,1048576},{28,1},{29,360},{35,0},{41,0.01},{42,1E+50},{43,-1E+50},{44,0},{45,0},{48,0},{71,0},{72,0},{73,5},{79,200},{80,0.001},{81,0},{82,0},{90,1},{91,200},{117,0},{118,0},{170,0},{171,0},{172,0},{173,0},{286,0},{315,0},{316,0},{0xffff,0} };
IPMPARAM __ipm_XAxis_param[] = { {8,0.949},{9,10},{10,10},{12,1},{13,100},{14,0},{15,0.949},{16,500},{17,0.69},{18,0.0794621589540506},{19,18.4731923758238},{20,0},{21,0},{22,0},{23,10},{24,0},{25,0},{26,1280000},{27,1048576},{28,1},{29,20},{35,0},{41,0.01},{42,150},{43,-90},{44,0},{45,0},{48,0},{71,0},{72,0},{73,1},{79,200},{80,0.001},{81,0},{82,0},{90,1},{91,10000},{117,0},{118,0},{170,1},{171,1.36E-05},{172,464.955712731289},{173,1},{286,0},{315,0},{316,0},{0xffff,0} };
IPMPARAM __ipm_YAxis_param[] = { {8,10000},{9,10},{10,10},{12,1},{13,100},{14,0},{15,1},{16,1000},{17,0.8},{18,0.1},{19,0},{20,0},{21,0},{22,0},{23,10},{24,0},{25,0},{26,1280000},{27,1048576},{28,1},{29,20},{35,0},{41,0.01},{42,280},{43,0},{44,0},{45,0},{48,0},{71,0},{72,0},{73,0},{79,200},{80,0.001},{81,0},{82,0},{90,1},{91,10000},{117,0},{118,0},{170,0},{171,0},{172,0},{173,0},{286,0},{315,0},{316,0},{0xffff,0} };
IPMPARAM __ipm_ZAxis_param[] = { {8,10000},{9,10},{10,20},{12,1},{13,100},{14,0},{15,1},{16,250},{17,0.8},{18,0.1},{19,0},{20,0},{21,0},{22,0},{23,10},{24,0},{25,0},{26,1280000},{27,1048576},{28,1},{29,5},{35,0},{41,0.01},{42,160},{43,0},{44,0},{45,0},{48,0},{71,0},{72,0},{73,0},{79,200},{80,0.001},{81,0},{82,0},{90,1},{91,10000},{117,0},{118,0},{170,0},{171,0},{172,0},{173,0},{286,0},{315,0},{316,0},{0xffff,0} };
IPMPARAM* __QS4IPMPARAMS[] = { 
	&__ipm_EmptyAxis1_param[0],&__ipm_EmptyAxis2_param[0],&__ipm_EmptyAxis3_param[0],&__ipm_Gripper_param[0],&__ipm_ThetaAxis_param[0],&__ipm_TransferStation_param[0],&__ipm_XAxis_param[0],&__ipm_YAxis_param[0],&__ipm_ZAxis_param[0],NULL
 };

int IPM_STOP(int ipm) {
	int result;
	RETVAL data;
#ifdef IPM_RPC
	data = __IPM_STOP(NULL, ipm, 0, &result, 0);
	return (data == SUCCESS);
#else
	return TRUE;
#endif
}

int IPM_STOP_QS4(int ipm, int reason, int slewed) {
	int result;
	RETVAL data;
#ifdef IPM_RPC
	if (reason)
	{
		reason |= 0x80000000;  // make negative number for reason if foreground task
	}
	data = __IPM_STOP(NULL, ipm, reason, &result, 0);
	return (data == SUCCESS);
#else
	return TRUE;
#endif
}

int IPM_CLEAR_SBs(int ipm) {
	int result;
//	if (!IPM_STOP(ipm)) return FALSE;
#ifdef IPM_RPC
	return (__IPM_CLEAR(NULL, ipm, &result, 0) == SUCCESS);
#else
	return TRUE;
#endif
}

int IPM_START_SB(int ipm, int sb, int fg) {
	int result;
#ifdef IPM_RPC
	if (fg)
	{
		sb |= 0x80000000;  // make negative number for msb if foreground task
	}
	return (__IPM_START(NULL, ipm, sb, &result, 0) == SUCCESS);
#else
	return TRUE;
#endif
}

int IPM_LOAD_SB(int ipm, int sb_number, void* sb) {
	unsigned short * ptr;
	unsigned short _hilen,_lolen;
	int len;
	int result=0;
	ptr = (unsigned short *)sb;
	_hilen = *ptr++;
	_lolen = *ptr++;
	len = (_hilen << 16) + _lolen;
#ifdef IPM_RPC
	return (__IPM_LOAD(NULL, ipm, sb_number, ptr, len << 1, &result, 0) == SUCCESS);
#else
	return TRUE;
#endif
}

int INIT_IPM_PARAMs(int ipm_index) {
	int success = TRUE;
	IPMPARAM* ptr = __QS4IPMPARAMS[ipm_index];
	while (TRUE) {
		if (ptr->pnum == 0xffff) break;
		_DW(NULL, 36822, __QS4IPM_NUMBER[ipm_index], ptr->pnum, ptr->value);
		ptr++;
	} 
	// restore nonvolatile if present for tuning parameters
	_DW(NULL, 36822, __QS4IPM_NUMBER[ipm_index], 136, 10);

	return success;
}

RETVAL TEST_IPMs()
{
	// Make sure all motors needed are available
	unsigned short *** iptr = &__QS4IPMs[0];
	int i = 0;
	int result = 0;
	RETVAL data = SUCCESS;
	if (!__IPMVAR_TEST_IPMs)
	{
		// Do not check number of drives, program will control EtherCAT
		return data;
	}
	while (*iptr != NULL) {
		data = __IPM_STOP(NULL, __QS4IPM_NUMBER[i], 0x55AB, &result, 0);
		if (data != SUCCESS)
		{
			break;
		}
		iptr++;
		if (*iptr == NULL)
		{
			// That was the last axis so tell call this is the last axis so can prepare
			// and knows this is a restart with reason code 0x55AA.
			__IPM_STOP(NULL, __QS4IPM_NUMBER[i], 0x55AA, &result, 0);
		}
		i++;
	}
	return data;
}

int INIT_IPMs() {
	unsigned short *** iptr = &__QS4IPMs[0];
	unsigned short ** sbptr;
	int i = 0;
	int sbno;
	int success = TRUE;
	while (*iptr != NULL) {
		success = IPM_STOP(__QS4IPM_NUMBER[i]);
		if (success != TRUE)
		{
			break;
		}
		success = IPM_CLEAR_SBs(__QS4IPM_NUMBER[i]);
		if (success != TRUE)
		{
			break;
		}
		success = INIT_IPM_PARAMs(i);
		if (success != TRUE)
		{
			break;
		}
		sbptr = *iptr;
		sbno = 0;
		while ((*sbptr != NULL) && (success == TRUE)) {
			success = IPM_LOAD_SB(__QS4IPM_NUMBER[i], sbno, *sbptr);
			sbno++;
			sbptr++;
		}
		i++;
		iptr++;
		if (success == FALSE)
		{
		}
	}
	return success;
}

void __initIPMs()
{
	int i;
	for (i=0; i<MAX_AXIS; i++) IPM_STOP_QS4(i, 1, 0);
	INIT_IPMs();
}

void __initQS4(int aisize, int aosize, int tick) {
	int i;
	for (i=0; i<aisize; i++) {
		if (__aiCT[i] < 0) continue;
#ifdef QS4_NEWINIT
		regWrite((UINT16)(9993), i);
		regWrite((UINT16)(9994), __aiRS[i]);
		regWrite((UINT16)(9995), __aiCT[i]);
#else
		regWrite((UINT16)(9501+i), __aiRS[i]);
		regWrite((UINT16)(9001+i), __aiCT[i]);
#endif
	}
#ifdef QS4_NEWINIT
	for (i=0; i<aosize; i++) {
		if (__aoCM[i] < 0) continue;
		regWrite((UINT16)(9991), i);
		regWrite((UINT16)(9992), __aoCM[i] ? 6 : 1);
	}
	if (__IPMVAR_TEST_IPMs)
	{
		// only do if user program is not bringing up EtherCAT itself
		__initIPMs();
	}
#else
	regWrite((UINT16)13022, 0);
#endif
	regWrite((UINT16)9990, 1);
	regWrite((UINT16)9989, tick);
	QS4ControlInit();
	__RUNTICK = 1;
}

RETVAL Motion_Put_Attributes( UINT8 MotorNum, UINT8 count, UINT8 *Attribute, STDVAL *value);
typedef	RETVAL (*MOTION_PUT_ATTRIBUTES)( UINT8 MotorNum, UINT8 count, UINT8 *Attribute, STDVAL *value);

// We are re-using the Motion_Put_Attribute since was never used
#ifdef ABSTRACT_INTIME
static
#endif
RETVAL Motion_Put_Attributes( UINT8 MotorNum, UINT8 count, UINT8 *Attribute, STDVAL *value)
{
	//	MOTION_PUT_ATTRIBUTE    Motion_Put_Attribute;
	if (getCoreTable() != NULL)
	{
		if (coreTable->Motion_Put_Attribute != NULL)
		{
			return(((MOTION_PUT_ATTRIBUTES)(*coreTable->Motion_Put_Attribute))(MotorNum, count, Attribute, value));
		}
	}
	return(ERROR_NOT_DEFINED);
}

#define __CTC_MOTION_SOFTSTOP 2
#define __CTC_MOTION_HARDSTOP 1
#define __CTC_MOTION_SEARCH_AND_HOME 3
#define __CTC_MOTION_ZERO 4
#define __CTC_SERVO_ERROR 8
#define __CTC_SERVO_POSITION 7
#define __CTC_SERVO_RUNNING 5
#define __CTC_SERVO_STOPPED 6
#define __CTC_SERVO_STATUS_REG 15003
#define __CTC_SERVO_POS_REG 15000
#define __CTC_SERVO_ERROR_REG 15001

/* Simple Motion Commands (no parameters required) */
#define __MOTION_COMMAND_RESET                     0
#define __MOTION_COMMAND_HARD_STOP                 1
#define __MOTION_COMMAND_SOFT_STOP                 2
#define __MOTION_COMMAND_SEARCH_HOME               3
#define __MOTION_COMMAND_MOVE_VEL_FORWARD          8
#define __MOTION_COMMAND_MOVE_VEL_FORWARD_WAIT     9
#define __MOTION_COMMAND_MOVE_VEL_REVERSE         10
#define __MOTION_COMMAND_MOVE_VEL_REVERSE_WAIT    11
#define __MOTION_COMMAND_MOVE_TO_TARGET           12
#define __MOTION_COMMAND_MOVE_TO_TARGET_WAIT      13
#define __MOTION_COMMAND_CHECK_READY              15
#define __MOTION_COMMAND_PROFILE_AXIS             16

#define __MOTION_ATTRIBUTE_STATUS                  0
#define __MOTION_ATTRIBUTE_VERSION                 1
#define __MOTION_ATTRIBUTE_COMPILE_OPTION          2
#define __MOTION_ATTRIBUTE_TARGET                  3
#define __MOTION_ATTRIBUTE_DEADBAND                4
#define __MOTION_ATTRIBUTE_MAX_SPEED               5
#define __MOTION_ATTRIBUTE_ACCELERATION            6
#define __MOTION_ATTRIBUTE_DECELERATION            7
#define __MOTION_ATTRIBUTE_PROPORTIONAL            8
#define __MOTION_ATTRIBUTE_INTEGRAL                9
#define __MOTION_ATTRIBUTE_DIFFERENTIAL           10
#define __MOTION_ATTRIBUTE_BANDWIDTH              11 /* 2214 */
#define __MOTION_ATTRIBUTE_VELOCITY_FEEDFORWARD   11 /* 2x19 */
#define __MOTION_ATTRIBUTE_ACCEL_FEEDFORWARD      12
#define __MOTION_ATTRIBUTE_ERROR_LIMIT            13
#define __MOTION_ATTRIBUTE_POSITION               14											    
#define __MOTION_ATTRIBUTE_VELOCITY               15
#define __MOTION_ATTRIBUTE_ERROR                  16
#define __MOTION_ATTRIBUTE_CUMULATIVE_ERROR       17
#define __MOTION_ATTRIBUTE_REGISTRATION_POSITION  18
#define __MOTION_ATTRIBUTE_REGISTRATION_STATUS    19
#define __MOTION_ATTRIBUTE_REGISTRATION_DISTANCE  20
#define __MOTION_ATTRIBUTE_REGISTRATION_BEGIN     21
#define __MOTION_ATTRIBUTE_REGISTRATION_WINDOW    22
#define __MOTION_ATTRIBUTE_RATIO_NUMERATOR        23
#define __MOTION_ATTRIBUTE_RATIO_DENOMINATOR      24
#define __MOTION_ATTRIBUTE_SERVO_FILTER           25
#define __MOTION_ATTRIBUTE_HOME_DIRECTION         26
#define __MOTION_ATTRIBUTE_START_OPTION           27
#define __MOTION_ATTRIBUTE_MASTER_START           28
#define __MOTION_ATTRIBUTE_FORCE_POSITION         29
#define __MOTION_ATTRIBUTE_FORCE_CUMULATIVE       30
#define __MOTION_ATTRIBUTE_AUX_INPUT_STATUS       31
#define __MOTION_ATTRIBUTE_AUX_INPUT_POLARITY     32
#define __MOTION_ATTRIBUTE_LEADER_POSITION        33
#define __MOTION_ATTRIBUTE_LEADER_VELOCITY        34
#define __MOTION_ATTRIBUTE_PLS_POSITION           35
#define __MOTION_ATTRIBUTE_CAM_TABLE_WIDTH        36
#define __MOTION_ATTRIBUTE_CAM_TABLE_ROW          37
#define __MOTION_ATTRIBUTE_CAM_TABLE_XFERPTR      38
#define __MOTION_ATTRIBUTE_ANALOG_OUTPUT_VALUE    39
#define __MOTION_ATTRIBUTE_SPEED_LIMIT            40
#define __MOTION_ATTRIBUTE_SOFTWARE_MAX_POSITION  41
#define __MOTION_ATTRIBUTE_SOFTWARE_MIN_POSITION  42
#define __MOTION_ATTRIBUTE_SOFTWARE_START_INPUT   43
#define __MOTION_ATTRIBUTE_SOFTWARE_FREE_INPUT    44
#define __MOTION_ATTRIBUTE_SOFTWARE_HOME_INPUT    45
#define __MOTION_ATTRIBUTE_SOFTWARE_POS_LIM_INPUT 46
#define __MOTION_ATTRIBUTE_SOFTWARE_NEG_LIM_INPUT 47
#define __MOTION_ATTRIBUTE_SERVO_OUTPUT_RANGE     48  /* Servo Output range value */
#define __MOTION_ATTRIBUTE_SERVO_OUTPUT_OFFSET    49  /* Servo Output zero value */
#define __MOTION_ATTRIBUTE_SERVO_CHANNEL_STATUS   50  /* Channel mode and status data */
#define __MOTION_ATTRIBUTE_SERVO_MOTOR_STATUS     51  /* Motor mode and status data */
#define __MOTION_ATTRIBUTE_SERVO_PROFILE_STATUS   52  /* Motor mode and status data */
#define __MOTION_ATTRIBUTE_SERVO_CONTROLLER_STATUS 53 /* Controller Status */
#define __MOTION_ATTRIBUTE_SERVO_MASTER_SELECTION 54  /* Master Axis Selection */
#define __MOTION_ATTRIBUTE_SERVO_MASTER_POSITION  55  /* Master Axis Position */
#define __MOTION_ATTRIBUTE_SERVO_MASTER_VELOCITY  56  /* Master Axis Velocity */
#define __MOTION_ATTRIBUTE_SERVO_GAIN_SCALING     57  /* Gain scaling constant */
#define __MOTION_ATTRIBUTE_SERVO_INDEX_STATUS     58  /* Index latch Status */
#define __MOTION_ATTRIBUTE_SERVO_INDEX_POSITION   59  /* Index Position Latch */
#define __MOTION_ATTRIBUTE_SERVO_DEBUG_STATUS     60
#define __MOTION_ATTRIBUTE_SERVO_SERIAL_NUMBER    61
#define __MOTION_ATTRIBUTE_SERVO_MONITOR_VERSION  62

// Profile bit masks
#define __CTC_PROFILE_SERVO_MOTOR_OFF_AT_POSITION_CMD 0
#define __CTC_PROFILE_SERVO_AT_POSITION_CMD 1
#define __CTC_PROFILE_SERVO_DEADBAND_CMD 2

#define __CTC_PROFILE_SERVO_DEADBAND 0x04
#define __CTC_PROFILE_SERVO_MAXSPEED 0x08
#define __CTC_PROFILE_SERVO_ACCEL 0x10
#define __CTC_PROFILE_SERVO_P 0x20
#define __CTC_PROFILE_SERVO_I 0x40
#define __CTC_PROFILE_SERVO_D 0x80

// Turn modes
#define __CTC_SERVO_ABSOLUTE_MOVE 0x40
#define __CTC_SERVO_VELOCITY_MOVE 0x10
#define __CTC_SERVO_RELATIVE_MOVE 0x20

RETVAL _servoProfile(int axis, int mode, int deadband, int maxspeed, int accel, int P, int I, int D)
{
	/* reserved for decode a PROFILE SERVO and PROFILE SERVO EXT */
	UINT8  servonum=axis;
	UINT8  command = mode;
	UINT8  count;
	UINT8  attributes[7];
	STDVAL values[7];

	count = 0;
	/* Check for "Profile Holding Mode" */
	if( command & __CTC_PROFILE_SERVO_DEADBAND) {
		/* New holding mode */
		attributes[ count] = __MOTION_ATTRIBUTE_DEADBAND;
		switch( command & 0x03) {
		case __CTC_PROFILE_SERVO_MOTOR_OFF_AT_POSITION_CMD: /* Servo Motor off when stopped */
			values[ count] = 0x80000000;
			break;
		case __CTC_PROFILE_SERVO_AT_POSITION_CMD: /* Servo at Position */
			values[ count] = 0;
			break;
		case __CTC_PROFILE_SERVO_DEADBAND_CMD: /* Deadband at Position */
			values[count] = deadband;
			break;
		case 3: /* Illegal */
			return ERROR_ILLEGAL_INST;
		}
		++count;
		/* Done with holding mode */
	}
	/* Check for Max Speed */
	if( command & __CTC_PROFILE_SERVO_MAXSPEED) {
		/* New Max Speed */
		attributes[ count] = __MOTION_ATTRIBUTE_MAX_SPEED;
		values[count] = maxspeed;
		++count;
		/* Done with max speed */
	}
	/* Check for Acceleration rate */
	if( command & __CTC_PROFILE_SERVO_ACCEL) {
		/* New Acceleration */
		attributes[ count] = __MOTION_ATTRIBUTE_ACCELERATION;
		values[count] = accel;
		++count;
		/* Done with acceleration */
		/* The original quickstep interpreter generated a "deceleration" 
		profile automatically to go with the acceleration profile.
		SHOULD WE ADD THIS???
		*/
	}
	/* Check for "Gain" */
	if( command & __CTC_PROFILE_SERVO_P) {
		/* New "Gain" */
		attributes[ count] = __MOTION_ATTRIBUTE_PROPORTIONAL;
		values[count] = P;
		++count;
		/* Done with "gain" */
	}
	/* Check for "Filter Zero" */
	if( command & __CTC_PROFILE_SERVO_I) {
		/* New "Filter Zero" */
		attributes[ count] = __MOTION_ATTRIBUTE_INTEGRAL;
		values[count] = I;
		++count;
		/* Done with "filter zero" */
	}
	/* Check for "filter pole" */
	if( command & __CTC_PROFILE_SERVO_D) {
		/* New "Filter Pole" */
		attributes[ count] = __MOTION_ATTRIBUTE_DIFFERENTIAL;
		values[count] = D;
		++count;
		/* Done with "filter pole" */
	}
	if( count > 0) {
		return Motion_Put_Attributes( servonum, count, attributes, values);
	}
	/* If we reach here, there was an error */
	return ERROR_ILLEGAL_INST;
}

RETVAL _servoTurn(int axis, int mode, int dir, int position);
RETVAL _servoInfo(int axis, int cmd);




int _rol(int value, int bitnum)
{
	return value << bitnum;
}
int _ror(int value, int bitnum)
{
	return value >> bitnum;
}

int _rotate_shift(int varFrom, int varTo, int bits, int backward_shift, int circular_shift)
{
	INT32 flags;
	unsigned int mask;
	unsigned int circular_mask;
	int  shift_count;
	unsigned short shift_field_width;
	int first_flag = varFrom;
	int last_flag = varTo;
#define __FLAG_BASE32_REGISTER 13021  // there are 128 flag registers, this reads 32 at a time

	if( last_flag < first_flag) {
		// error
		return -1;
	}

	shift_count = bits & 0x1f;

	shift_field_width = last_flag - first_flag + 1;
	if(( shift_field_width < shift_count) || (shift_field_width > 32)) {
		return -1;
	}

	// read flag register
	regRead((varFrom/32)+__FLAG_BASE32_REGISTER,&flags);

	// shift/rotate must be within the same boundries of a 32 bit value
	if ((first_flag/32) != ((last_flag-1)/32))
	{
		// exceeded boundry
		return -1;
	}

	/* Create a mask with the correct number of 1 bits
	using the algorithm of (2^shift_field_width) - 1.
	(shift_field_width must be >= 1) */
	if (shift_field_width == 32)
	{
		mask = 0xffffffff;
	}
	else
	{
		mask = (0x00000001 << shift_field_width) - 1;
	}
	/* Mask off any flags we are not interested in */
	flags &= mask;
	/* Create a circular mask that will capture the
	bits shifted off the end. 
	If not circular shift, this mask should be 0.
	If backward shift, the mask should be right-aligned;
	If not backward shift, line-up the mask with
	the last bit */
	if( circular_shift) {
		/* circular shift -- create mask for bits shift off end */
		if (shift_count == 32)
		{
			circular_mask = 0xffffffff;
		}
		else
		{
			circular_mask = (0x00000001 << shift_count) - 1;
		}
		if( backward_shift == 0) {
			/* forward circular shift -- line-up circular mask with last bit */
			circular_mask = circular_mask << (shift_field_width - shift_count);
		}
	}
	else {
		/* Not a circular shift, clear mask */
		circular_mask = 0;
	}
	/* AND flags with circular mask to capture bits shifted off end */
	circular_mask &= flags;
	/* SHIFT FLAGS */
	if( backward_shift) {
		/* shift flags backward -- to right. */
		flags = flags >> shift_count;
		/* Line-up circular mask with left-end and OR captured flags back */
		circular_mask = circular_mask << (shift_field_width - shift_count);
		flags |= circular_mask;
	}
	else {
		/* shift flags forward and circular mask backwards */
		flags = (flags << shift_count) & mask;
		circular_mask = circular_mask >> (shift_field_width - shift_count);
		flags |= circular_mask;
	}
	/* write the result back */
	regWrite((varFrom/32)+__FLAG_BASE32_REGISTER,flags);
	return 0;
}

int _shiftrb(int varFrom, int varTo, int bits)
{
	return _rotate_shift(varFrom, varTo, bits, 1, 0);
}
int _shiftlb(int varFrom, int varTo, int bits)
{
	return _rotate_shift(varFrom, varTo, bits, 1, 0);
}

int _rorb(int varFrom, int varTo, int bits)
{
	return _rotate_shift(varFrom, varTo, bits, 0, 1);
}
int _rolb(int varFrom, int varTo, int bits)
{
	return _rotate_shift(varFrom, varTo, bits, 1, 1);
}

#define __CTC_SOFTCOUNTER_UP 1
#define __CTC_SOFTCOUNTER_DOWN 2
#define __CTC_SOFTCOUNTER_RESET 3
#define __CTC_SOFTCOUNTER_DISABLE 4
#define __CTC_SOFTCOUNTER_ENABLE 5
#define __CTC_SOFTCOUNTER_START 6

// soft counters are 1 to 8
int _softcounter(int counter, int cmd, int mask, int inp_up, int inp_down, int inp_reset)
{
UINT8 attributes[4];
STDVAL values[4];

	counter--;  // adjust since 0 based
	// Clunky but will work, pass commands via the motor API
	switch(cmd)
	{
		case __CTC_SOFTCOUNTER_UP:
		case __CTC_SOFTCOUNTER_DOWN:
		case __CTC_SOFTCOUNTER_ENABLE:
		case __CTC_SOFTCOUNTER_DISABLE:
		case __CTC_SOFTCOUNTER_RESET:
			attributes[0] = cmd;
			values[0] = 0;
			if (Motion_Put_Attributes((unsigned char)0x40 + counter,1, attributes, values) == SUCCESS)
			{
				return 0;
			}			
			break;
		case __CTC_SOFTCOUNTER_START:
			attributes[0] = cmd;
			if (mask & 1) // check up
			{
				attributes[1] = 0;  // present
			}
			else
			{
				attributes[1] = 0xff;  // not present
			}
			if (mask & 2) // check down
			{
				attributes[2] = 0;  // present
			}
			else
			{
				attributes[2] = 0xff;  // not present
			}
			if (mask & 4) // check reset
			{
				attributes[3] = 0;  // present
			}
			else
			{
				attributes[3] = 0xff;  // not present
			}
			values[0] = 0;
			values[1] = inp_up;
			values[2] = inp_down;
			values[3] = inp_reset;
			if (Motion_Put_Attributes((unsigned char)0x40 + counter,4, attributes, values) == SUCCESS)
			{
				return 0;
			}			
			break;
		default:
			return -1;
	}
	return -1;
}

#if QB_HDR_VERSION > 100

//--QS4TYPES--//
#define __QS4OBJ_PID (0)
// --------------------------------------- QS4 PID

typedef struct PID_TD {
	const int* offsets;
	const int* types;
	const char** names;
	const char* name;
	int readOnly;
	//
	int mode;
	double kp;
	double ki;
	double kd;
	double kff;
	double manual_feedback;
	double output_hilimit;
	double output_lolimit;
	double setpoint;
	double setpoint_rate;
	double setpoint_rate_adjusted;
	double feedback;
	double error;
	double error0;
	double error1;
	double integrator;
	double output;
	int use_manual_feedback;
	int pcount;
	int first;
	double period;
	double iperiod;
	double rate;
	double error_deadband;
	double setpoint_lolimit;
	double setpoint_hilimit;
	double feedback_lolimit;
	double feedback_hilimit;
	double error_lolimit;
	double error_hilimit;
	int in_setpoint_limit;
	int in_feedback_limit;
	int in_error_limit;
	int in_output_limit;
	int subtick;
	int tick_multiplier;
	double output_scale;
	double integrator_unwind_constant;
	int derivative_form;
	int enabled;
	double offset;
	short _RF_ptr;
	void* _RF;
	short _RO_ptr;
	void* _RO;
} PID_Struct;

const int PID_Offsets[] = {
	41,
	offsetof(PID_Struct, mode),
	offsetof(PID_Struct, kp),
	offsetof(PID_Struct, ki),
	offsetof(PID_Struct, kd),
	offsetof(PID_Struct, kff),
	offsetof(PID_Struct, manual_feedback),
	offsetof(PID_Struct, output_hilimit),
	offsetof(PID_Struct, output_lolimit),
	offsetof(PID_Struct, setpoint),
	offsetof(PID_Struct, setpoint_rate),
	offsetof(PID_Struct, setpoint_rate_adjusted),
	offsetof(PID_Struct, feedback),
	offsetof(PID_Struct, error),
	offsetof(PID_Struct, error0),
	offsetof(PID_Struct, error1),
	offsetof(PID_Struct, integrator),
	offsetof(PID_Struct, output),
	offsetof(PID_Struct, use_manual_feedback),
	offsetof(PID_Struct, pcount),
	offsetof(PID_Struct, first),
	offsetof(PID_Struct, period),
	offsetof(PID_Struct, iperiod),
	offsetof(PID_Struct, rate),
	offsetof(PID_Struct, error_deadband),
	offsetof(PID_Struct, setpoint_lolimit),
	offsetof(PID_Struct, setpoint_hilimit),
	offsetof(PID_Struct, feedback_lolimit),
	offsetof(PID_Struct, feedback_hilimit),
	offsetof(PID_Struct, error_lolimit),
	offsetof(PID_Struct, error_hilimit),
	offsetof(PID_Struct, in_setpoint_limit),
	offsetof(PID_Struct, in_feedback_limit),
	offsetof(PID_Struct, in_error_limit),
	offsetof(PID_Struct, in_output_limit),
	offsetof(PID_Struct, subtick),
	offsetof(PID_Struct, tick_multiplier),
	offsetof(PID_Struct, output_scale),
	offsetof(PID_Struct, integrator_unwind_constant),
	offsetof(PID_Struct, derivative_form),
	offsetof(PID_Struct, enabled),
	offsetof(PID_Struct, offset)
};

const int PID_Types[] = {
	VARIANT_INTEGER,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_INTEGER,
	VARIANT_INTEGER,
	VARIANT_INTEGER,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_INTEGER,
	VARIANT_INTEGER,
	VARIANT_INTEGER,
	VARIANT_INTEGER,
	VARIANT_INTEGER,
	VARIANT_INTEGER,
	VARIANT_DOUBLE,
	VARIANT_DOUBLE,
	VARIANT_INTEGER,
	VARIANT_INTEGER,
	VARIANT_DOUBLE
};

const char* PID_Names[] = {
	"PID",
	"mode",
	"kp",
	"ki",
	"kd",
	"kff",
	"manual_feedback",
	"output_hilimit",
	"output_lolimit",
	"setpoint",
	"setpoint_rate",
	"setpoint_rate_adjusted",
	"feedback",
	"error",
	"error0",
	"error1",
	"integrator",
	"output",
	"use_manual_feedback",
	"pcount",
	"first",
	"period",
	"iperiod",
	"rate",
	"error_deadband",
	"setpoint_lolimit",
	"setpoint_hilimit",
	"feedback_lolimit",
	"feedback_hilimit",
	"error_lolimit",
	"error_hilimit",
	"in_setpoint_limit",
	"in_feedback_limit",
	"in_error_limit",
	"in_output_limit",
	"subtick",
	"tick_multiplier",
	"output_scale",
	"integrator_unwind_constant",
	"derivative_form",
	"enabled",
	"offset"
};

#define __QS4OBJ_XVar_int (1)
// --------------------------------------- QS4 XVar_int

typedef struct XVar_int_TD {
	const int* offsets;
	const int* types;
	const char** names;
	const char* name;
	int readOnly;
	//
	int value;
} XVar_int_Struct;

const int XVar_int_Offsets[] = {
	1,
	offsetof(XVar_int_Struct, value)
};

const int XVar_int_Types[] = {
	VARIANT_INTEGER
};

const char* XVar_int_Names[] = {
	"XVar_int",
};

#define __QS4OBJ_XVar_float64 (2)
// --------------------------------------- QS4 XVar_float64

typedef struct XVar_float64_TD {
	const int* offsets;
	const int* types;
	const char** names;
	const char* name;
	int readOnly;
	//
	double value;
} XVar_float64_Struct;

const int XVar_float64_Offsets[] = {
	1,
	offsetof(XVar_float64_Struct, value)
};

const int XVar_float64_Types[] = {
	VARIANT_DOUBLE
};

const char* XVar_float64_Names[] = {
	"XVar_float64",
};

#define __QS4OBJ_XVar_string (3)
// --------------------------------------- QS4 XVar_string

typedef struct XVar_string_TD {
	const int* offsets;
	const int* types;
	const char** names;
	const char* name;
	int readOnly;
	//
	char value[VARIANT_MAX_STRING+1];
} XVar_string_Struct;

const int XVar_string_Offsets[] = {
	1,
	offsetof(XVar_string_Struct, value)
};

const int XVar_string_Types[] = {
	VARIANT_STRING
};

const char* XVar_string_Names[] = {
	"XVar_string",
};

#define __QS4OBJ_XVar_float32 (4)
// --------------------------------------- QS4 XVar_float32

typedef struct XVar_float32_TD {
	const int* offsets;
	const int* types;
	const char** names;
	const char* name;
	int readOnly;
	//
	float value;
} XVar_float32_Struct;

const int XVar_float32_Offsets[] = {
	1,
	offsetof(XVar_float32_Struct, value)
};

const int XVar_float32_Types[] = {
	VARIANT_FLOAT
};

const char* XVar_float32_Names[] = {
	"XVar_float32",
};


#define __QS4OBJ_EMPTY (-1)

//--QS4OBJECTS--//
extern XVar_int_Struct AutoMode;
extern XVar_int_Struct ManualMode;
XVar_int_Struct AutoMode = { &XVar_int_Offsets[1], &XVar_int_Types[0], &XVar_int_Names[1], "AutoMode", 0, 1};
XVar_int_Struct ManualMode = { &XVar_int_Offsets[1], &XVar_int_Types[0], &XVar_int_Names[1], "ManualMode", 0, 0};

void* QS4Objects[] = {
//--QS4OBJECTSTABLE--//
&AutoMode,
&ManualMode
};

int QS4ObjectTypes[] = {
//--QS4OBJECTSTYPES--//
__QS4OBJ_XVar_int,
__QS4OBJ_XVar_int
};

QS4SYMBOL QS4SymbolTable[] = {
//--QS4SYMBOLTABLE--//
	{ 13201, 0, 16385, "F1_Trigger" },
	{ 13232, 0, 16385, "F32_Mode" },
	{ 1, 0, 16385, "i" },
	{ 10, 0, 16385, "R10_Mode" },
	{ 12333, 0, 16385, "R12333_RestartEtherCAT" },
	{ 13464, 0, 16385, "R13464_EtherCATStatus" },
	{ 20099, 0, 16385, "R20099_ModBusTCPWordSwap" },
	{ 36101, 0, 16392, "R36101_Temp" },
	{ 36711, 0, 16392, "R36711_Ax1Fpos" },
	{ 36712, 0, 16392, "R36712_Ax1Fpos" },
	{ 36713, 0, 16392, "R36713_Ax1Fpos" },
	{ 36714, 0, 16392, "R36714_Ax1Fpos" },
	{ 500, 0, 16385, "R500_RestartProgram" },
	{ 9, 0, 16385, "R9_Dwell" },
	{ 20, 0, 16385, "running1" },
	{ 29, 0, 16385, "running10" },
	{ 21, 0, 16385, "running2" },
	{ 22, 0, 16385, "running3" },
	{ 23, 0, 16385, "running4" },
	{ 24, 0, 16385, "running5" },
	{ 25, 0, 16385, "running6" },
	{ 26, 0, 16385, "running7" },
	{ 27, 0, 16385, "running8" },
	{ 28, 0, 16385, "running9" },
	{ 36201, 0, 81921, "StageTasks" },
	{ 36701, 0, 16392, "R36701_Speed" },
	{ 36702, 0, 16392, "R36702_Accel" },
	{ 36703, 0, 16392, "R36703_Decel" },
	{ 36704, 0, 16392, "R36704_XTarget" },
	{ 36705, 0, 16392, "R36705_YTarget" },
	{ 36706, 0, 16392, "R36706_ZTarget" },
	{ 501, 0, 16385, "R501_Speed" },
	{ 502, 0, 16385, "R502_Accel" },
	{ 503, 0, 16385, "R503_Decel" },
	{ 504, 0, 16385, "R504_Target" },
	{ 505, 0, 16385, "R505_HomeOffset" },
	{ 509, 0, 16385, "R509_X_fpos" },
	{ 510, 0, 16385, "R510_XAxisCommands" },
	{ 511, 0, 16385, "R511_Speed" },
	{ 512, 0, 16385, "R512_Accel" },
	{ 513, 0, 16385, "R513_Decel" },
	{ 514, 0, 16385, "R514_Target" },
	{ 515, 0, 16385, "R515_HomeOffset" },
	{ 519, 0, 16385, "R519_Y_fpos" },
	{ 520, 0, 16385, "R520_YAxisCommands" },
	{ 521, 0, 16385, "R521_Speed" },
	{ 522, 0, 16385, "R522_Accel" },
	{ 523, 0, 16385, "R523_Decel" },
	{ 524, 0, 16385, "R524_Target" },
	{ 525, 0, 16385, "R525_HomeOffset" },
	{ 529, 0, 16385, "R529_Z_fpos" },
	{ 530, 0, 16385, "R530_ZAxisCommands" },
	{ 531, 0, 16385, "R531_Speed" },
	{ 532, 0, 16385, "R532_Accel" },
	{ 533, 0, 16385, "R533_Decel" },
	{ 534, 0, 16385, "R534_Target" },
	{ 535, 0, 16385, "R535_HomeOffset" },
	{ 539, 0, 16385, "R539_fpos" },
	{ 540, 0, 16385, "R540_ThetaCommands" },
	{ 541, 0, 16385, "R541_Speed" },
	{ 542, 0, 16385, "R542_Accel" },
	{ 543, 0, 16385, "R543_Decel" },
	{ 544, 0, 16385, "R544_Target" },
	{ 545, 0, 16385, "R545_HomeOffset" },
	{ 549, 0, 16385, "R549_fpos" },
	{ 550, 0, 16385, "R550_GripperCommands" },
	{ 551, 0, 16385, "R551_Speed" },
	{ 552, 0, 16385, "R552_Accel" },
	{ 553, 0, 16385, "R553_Decel" },
	{ 554, 0, 16385, "R554_Target" },
	{ 555, 0, 16385, "R555_HomeOffset" },
	{ 559, 0, 16385, "R559_fpos" },
	{ 560, 0, 16385, "R560_GripperRotCommands" },
	{ 561, 0, 16385, "R561_Speed" },
	{ 562, 0, 16385, "R562_Accel" },
	{ 563, 0, 16385, "R563_Decel" },
	{ 564, 0, 16385, "R564_Target" },
	{ 565, 0, 16385, "R565_HomeOffset" },
	{ 569, 0, 16385, "R569_fpos" },
	{ 570, 0, 16385, "R570_Empty1Commands" },
	{ 571, 0, 16385, "R571_Speed" },
	{ 572, 0, 16385, "R572_Accel" },
	{ 573, 0, 16385, "R573_Decel" },
	{ 574, 0, 16385, "R574_Target" },
	{ 575, 0, 16385, "R575_HomeOffset" },
	{ 579, 0, 16385, "R579_fpos" },
	{ 580, 0, 16385, "R580_Empty2Commands" },
	{ 581, 0, 16385, "R581_Speed" },
	{ 582, 0, 16385, "R582_Accel" },
	{ 583, 0, 16385, "R583_Decel" },
	{ 584, 0, 16385, "R584_Target" },
	{ 585, 0, 16385, "R585_HomeOffset" },
	{ 589, 0, 16385, "R589_fpos" },
	{ 590, 0, 16385, "R590_TransferStationCommands" },
	{ 591, 0, 16385, "R591_Speed" },
	{ 592, 0, 16385, "R592_Accel" },
	{ 593, 0, 16385, "R593_Decel" },
	{ 594, 0, 16385, "R594_Target" },
	{ 595, 0, 16385, "R595_HomeOffset" },
	{ 599, 0, 16385, "R599_fpos" },
	{ 600, 0, 16385, "R600_Empty3Commands" },
	{ 0, 0, 1, "AutoMode.value" },
	{ 1, 0, 1, "ManualMode.value" },
	{ 5, __IPMVAR_CTC_EmptyAxis1_Axisnum, 8208, "EmptyAxis1.Axisnum" },
	{ 5, __IPMVAR_CTC_EmptyAxis1_Limit, 8208, "EmptyAxis1.Limit" },
	{ 5, __IPMVAR_CTC_EmptyAxis1_command, 8208, "EmptyAxis1.command" },
	{ 5, __IPMVAR_CTC_EmptyAxis1_WaitStart, 8208, "EmptyAxis1.WaitStart" },
	{ 5, __IPMVAR_CTC_EmptyAxis1_MSBRunning, 8208, "EmptyAxis1.MSBRunning" },
	{ 5, __IPMVAR_CTC_EmptyAxis1_NewPosition, 8208, "EmptyAxis1.NewPosition" },
	{ 5, __IPMVAR_CTC_EmptyAxis1_Accel, 8208, "EmptyAxis1.Accel" },
	{ 5, __IPMVAR_CTC_EmptyAxis1_Decel, 8208, "EmptyAxis1.Decel" },
	{ 5, __IPMVAR_CTC_EmptyAxis1_Maxspeed, 8208, "EmptyAxis1.Maxspeed" },
	{ 5, __IPMVAR_CTC_EmptyAxis1_Target, 8208, "EmptyAxis1.Target" },
	{ 5, __IPMVAR_CTC_EmptyAxis1_State, 8208, "EmptyAxis1.State" },
	{ 5, __IPMVAR_CTC_EmptyAxis1_RegWrite, 8208, "EmptyAxis1.RegWrite" },
	{ 5, __IPMVAR_CTC_EmptyAxis1_OffsetHome, 8208, "EmptyAxis1.OffsetHome" },
	{ 5, __IPMVAR_CTC_EmptyAxis1_Direction, 8208, "EmptyAxis1.Direction" },
	{ 6, __IPMVAR_CTC_EmptyAxis2_Axisnum, 8208, "EmptyAxis2.Axisnum" },
	{ 6, __IPMVAR_CTC_EmptyAxis2_Limit, 8208, "EmptyAxis2.Limit" },
	{ 6, __IPMVAR_CTC_EmptyAxis2_command, 8208, "EmptyAxis2.command" },
	{ 6, __IPMVAR_CTC_EmptyAxis2_WaitStart, 8208, "EmptyAxis2.WaitStart" },
	{ 6, __IPMVAR_CTC_EmptyAxis2_MSBRunning, 8208, "EmptyAxis2.MSBRunning" },
	{ 6, __IPMVAR_CTC_EmptyAxis2_NewPosition, 8208, "EmptyAxis2.NewPosition" },
	{ 6, __IPMVAR_CTC_EmptyAxis2_Accel, 8208, "EmptyAxis2.Accel" },
	{ 6, __IPMVAR_CTC_EmptyAxis2_Decel, 8208, "EmptyAxis2.Decel" },
	{ 6, __IPMVAR_CTC_EmptyAxis2_Maxspeed, 8208, "EmptyAxis2.Maxspeed" },
	{ 6, __IPMVAR_CTC_EmptyAxis2_Target, 8208, "EmptyAxis2.Target" },
	{ 6, __IPMVAR_CTC_EmptyAxis2_State, 8208, "EmptyAxis2.State" },
	{ 6, __IPMVAR_CTC_EmptyAxis2_RegWrite, 8208, "EmptyAxis2.RegWrite" },
	{ 6, __IPMVAR_CTC_EmptyAxis2_OffsetHome, 8208, "EmptyAxis2.OffsetHome" },
	{ 6, __IPMVAR_CTC_EmptyAxis2_Direction, 8208, "EmptyAxis2.Direction" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_Axisnum, 8208, "EmptyAxis3.Axisnum" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_Limit, 8208, "EmptyAxis3.Limit" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_command, 8208, "EmptyAxis3.command" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_WaitStart, 8208, "EmptyAxis3.WaitStart" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_MSBRunning, 8208, "EmptyAxis3.MSBRunning" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_NewPosition, 8208, "EmptyAxis3.NewPosition" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_Accel, 8208, "EmptyAxis3.Accel" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_Decel, 8208, "EmptyAxis3.Decel" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_Maxspeed, 8208, "EmptyAxis3.Maxspeed" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_Distance, 8208, "EmptyAxis3.Distance" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_Target, 8208, "EmptyAxis3.Target" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_TravelDirection, 8208, "EmptyAxis3.TravelDirection" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_State, 8208, "EmptyAxis3.State" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_RegWrite, 8208, "EmptyAxis3.RegWrite" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_Direction, 8208, "EmptyAxis3.Direction" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_In1, 8208, "EmptyAxis3.In1" },
	{ 8, __IPMVAR_CTC_EmptyAxis3_OffsetHome, 8208, "EmptyAxis3.OffsetHome" },
	{ 4, __IPMVAR_CTC_Gripper_Axisnum, 8208, "Gripper.Axisnum" },
	{ 4, __IPMVAR_CTC_Gripper_Limit, 8208, "Gripper.Limit" },
	{ 4, __IPMVAR_CTC_Gripper_command, 8208, "Gripper.command" },
	{ 4, __IPMVAR_CTC_Gripper_WaitStart, 8208, "Gripper.WaitStart" },
	{ 4, __IPMVAR_CTC_Gripper_MSBRunning, 8208, "Gripper.MSBRunning" },
	{ 4, __IPMVAR_CTC_Gripper_NewPosition, 8208, "Gripper.NewPosition" },
	{ 4, __IPMVAR_CTC_Gripper_Accel, 8208, "Gripper.Accel" },
	{ 4, __IPMVAR_CTC_Gripper_Decel, 8208, "Gripper.Decel" },
	{ 4, __IPMVAR_CTC_Gripper_Maxspeed, 8208, "Gripper.Maxspeed" },
	{ 4, __IPMVAR_CTC_Gripper_Target, 8208, "Gripper.Target" },
	{ 4, __IPMVAR_CTC_Gripper_State, 8208, "Gripper.State" },
	{ 4, __IPMVAR_CTC_Gripper_RegWrite, 8208, "Gripper.RegWrite" },
	{ 4, __IPMVAR_CTC_Gripper_OffsetHome, 8208, "Gripper.OffsetHome" },
	{ 4, __IPMVAR_CTC_Gripper_Direction, 8208, "Gripper.Direction" },
	{ 3, __IPMVAR_CTC_ThetaAxis_Axisnum, 8208, "ThetaAxis.Axisnum" },
	{ 3, __IPMVAR_CTC_ThetaAxis_Limit, 8208, "ThetaAxis.Limit" },
	{ 3, __IPMVAR_CTC_ThetaAxis_command, 8208, "ThetaAxis.command" },
	{ 3, __IPMVAR_CTC_ThetaAxis_WaitStart, 8208, "ThetaAxis.WaitStart" },
	{ 3, __IPMVAR_CTC_ThetaAxis_MSBRunning, 8208, "ThetaAxis.MSBRunning" },
	{ 3, __IPMVAR_CTC_ThetaAxis_NewPosition, 8208, "ThetaAxis.NewPosition" },
	{ 3, __IPMVAR_CTC_ThetaAxis_Accel, 8208, "ThetaAxis.Accel" },
	{ 3, __IPMVAR_CTC_ThetaAxis_Decel, 8208, "ThetaAxis.Decel" },
	{ 3, __IPMVAR_CTC_ThetaAxis_Maxspeed, 8208, "ThetaAxis.Maxspeed" },
	{ 3, __IPMVAR_CTC_ThetaAxis_Target, 8208, "ThetaAxis.Target" },
	{ 3, __IPMVAR_CTC_ThetaAxis_State, 8208, "ThetaAxis.State" },
	{ 3, __IPMVAR_CTC_ThetaAxis_RegWrite, 8208, "ThetaAxis.RegWrite" },
	{ 3, __IPMVAR_CTC_ThetaAxis_OffsetHome, 8208, "ThetaAxis.OffsetHome" },
	{ 3, __IPMVAR_CTC_ThetaAxis_Direction, 8208, "ThetaAxis.Direction" },
	{ 7, __IPMVAR_CTC_TransferStation_Axisnum, 8208, "TransferStation.Axisnum" },
	{ 7, __IPMVAR_CTC_TransferStation_Limit, 8208, "TransferStation.Limit" },
	{ 7, __IPMVAR_CTC_TransferStation_command, 8208, "TransferStation.command" },
	{ 7, __IPMVAR_CTC_TransferStation_WaitStart, 8208, "TransferStation.WaitStart" },
	{ 7, __IPMVAR_CTC_TransferStation_MSBRunning, 8208, "TransferStation.MSBRunning" },
	{ 7, __IPMVAR_CTC_TransferStation_NewPosition, 8208, "TransferStation.NewPosition" },
	{ 7, __IPMVAR_CTC_TransferStation_Accel, 8208, "TransferStation.Accel" },
	{ 7, __IPMVAR_CTC_TransferStation_Decel, 8208, "TransferStation.Decel" },
	{ 7, __IPMVAR_CTC_TransferStation_Maxspeed, 8208, "TransferStation.Maxspeed" },
	{ 7, __IPMVAR_CTC_TransferStation_Distance, 8208, "TransferStation.Distance" },
	{ 7, __IPMVAR_CTC_TransferStation_Target, 8208, "TransferStation.Target" },
	{ 7, __IPMVAR_CTC_TransferStation_TravelDirection, 8208, "TransferStation.TravelDirection" },
	{ 7, __IPMVAR_CTC_TransferStation_State, 8208, "TransferStation.State" },
	{ 7, __IPMVAR_CTC_TransferStation_RegWrite, 8208, "TransferStation.RegWrite" },
	{ 7, __IPMVAR_CTC_TransferStation_Direction, 8208, "TransferStation.Direction" },
	{ 7, __IPMVAR_CTC_TransferStation_In1, 8208, "TransferStation.In1" },
	{ 7, __IPMVAR_CTC_TransferStation_OffsetHome, 8208, "TransferStation.OffsetHome" },
	{ 0, __IPMVAR_CTC_XAxis_speed, 8208, "XAxis.speed" },
	{ 0, __IPMVAR_CTC_XAxis_command, 8208, "XAxis.command" },
	{ 0, __IPMVAR_CTC_XAxis_YTarget, 8208, "XAxis.YTarget" },
	{ 0, __IPMVAR_CTC_XAxis_ZTarget, 8208, "XAxis.ZTarget" },
	{ 0, __IPMVAR_CTC_XAxis_XTarget, 8208, "XAxis.XTarget" },
	{ 0, __IPMVAR_CTC_XAxis_Accel, 8208, "XAxis.Accel" },
	{ 0, __IPMVAR_CTC_XAxis_Decel, 8208, "XAxis.Decel" },
	{ 0, __IPMVAR_CTC_XAxis_RegWrite, 8208, "XAxis.RegWrite" },
	{ 0, __IPMVAR_CTC_XAxis_Axisnum, 8208, "XAxis.Axisnum" },
	{ 0, __IPMVAR_CTC_XAxis_Limit, 8208, "XAxis.Limit" },
	{ 0, __IPMVAR_CTC_XAxis_WaitStart, 8208, "XAxis.WaitStart" },
	{ 0, __IPMVAR_CTC_XAxis_MSBRunning, 8208, "XAxis.MSBRunning" },
	{ 0, __IPMVAR_CTC_XAxis_NewPosition, 8208, "XAxis.NewPosition" },
	{ 0, __IPMVAR_CTC_XAxis_Maxspeed, 8208, "XAxis.Maxspeed" },
	{ 0, __IPMVAR_CTC_XAxis_Target, 8208, "XAxis.Target" },
	{ 0, __IPMVAR_CTC_XAxis_State, 8208, "XAxis.State" },
	{ 0, __IPMVAR_CTC_XAxis_OffsetHome, 8208, "XAxis.OffsetHome" },
	{ 0, __IPMVAR_CTC_XAxis_Direction, 8208, "XAxis.Direction" },
	{ 1, __IPMVAR_CTC_YAxis_Axisnum, 8208, "YAxis.Axisnum" },
	{ 1, __IPMVAR_CTC_YAxis_Limit, 8208, "YAxis.Limit" },
	{ 1, __IPMVAR_CTC_YAxis_command, 8208, "YAxis.command" },
	{ 1, __IPMVAR_CTC_YAxis_WaitStart, 8208, "YAxis.WaitStart" },
	{ 1, __IPMVAR_CTC_YAxis_MSBRunning, 8208, "YAxis.MSBRunning" },
	{ 1, __IPMVAR_CTC_YAxis_NewPosition, 8208, "YAxis.NewPosition" },
	{ 1, __IPMVAR_CTC_YAxis_Accel, 8208, "YAxis.Accel" },
	{ 1, __IPMVAR_CTC_YAxis_Decel, 8208, "YAxis.Decel" },
	{ 1, __IPMVAR_CTC_YAxis_Maxspeed, 8208, "YAxis.Maxspeed" },
	{ 1, __IPMVAR_CTC_YAxis_Target, 8208, "YAxis.Target" },
	{ 1, __IPMVAR_CTC_YAxis_State, 8208, "YAxis.State" },
	{ 1, __IPMVAR_CTC_YAxis_RegWrite, 8208, "YAxis.RegWrite" },
	{ 1, __IPMVAR_CTC_YAxis_OffsetHome, 8208, "YAxis.OffsetHome" },
	{ 1, __IPMVAR_CTC_YAxis_Direction, 8208, "YAxis.Direction" },
	{ 2, __IPMVAR_CTC_ZAxis_Axisnum, 8208, "ZAxis.Axisnum" },
	{ 2, __IPMVAR_CTC_ZAxis_Limit, 8208, "ZAxis.Limit" },
	{ 2, __IPMVAR_CTC_ZAxis_command, 8208, "ZAxis.command" },
	{ 2, __IPMVAR_CTC_ZAxis_WaitStart, 8208, "ZAxis.WaitStart" },
	{ 2, __IPMVAR_CTC_ZAxis_MSBRunning, 8208, "ZAxis.MSBRunning" },
	{ 2, __IPMVAR_CTC_ZAxis_NewPosition, 8208, "ZAxis.NewPosition" },
	{ 2, __IPMVAR_CTC_ZAxis_Accel, 8208, "ZAxis.Accel" },
	{ 2, __IPMVAR_CTC_ZAxis_Decel, 8208, "ZAxis.Decel" },
	{ 2, __IPMVAR_CTC_ZAxis_Maxspeed, 8208, "ZAxis.Maxspeed" },
	{ 2, __IPMVAR_CTC_ZAxis_Target, 8208, "ZAxis.Target" },
	{ 2, __IPMVAR_CTC_ZAxis_State, 8208, "ZAxis.State" },
	{ 2, __IPMVAR_CTC_ZAxis_RegWrite, 8208, "ZAxis.RegWrite" },
	{ 2, __IPMVAR_CTC_ZAxis_OffsetHome, 8208, "ZAxis.OffsetHome" },
	{ 2, __IPMVAR_CTC_ZAxis_Direction, 8208, "ZAxis.Direction" },
	{ 5, 30, 8208, "EmptyAxis1.tpos" },
	{ 5, 32, 8208, "EmptyAxis1.fpos" },
	{ 5, 36, 8208, "EmptyAxis1.perr" },
	{ 5, 37, 8208, "EmptyAxis1.trqc" },
	{ 5, 38, 8208, "EmptyAxis1.vcmd" },
	{ 5, 39, 8208, "EmptyAxis1.vel" },
	{ 5, 74, 8208, "EmptyAxis1.faulted" },
	{ 5, 89, 8208, "EmptyAxis1.mposc" },
	{ 5, 107, 8208, "EmptyAxis1.mpgai" },
	{ 5, 108, 8208, "EmptyAxis1.mpgfi" },
	{ 5, 111, 8208, "EmptyAxis1.spgai" },
	{ 5, 112, 8208, "EmptyAxis1.spgfi" },
	{ 5, 113, 8208, "EmptyAxis1.tmc1" },
	{ 5, 114, 8208, "EmptyAxis1.tmc2" },
	{ 5, 115, 8208, "EmptyAxis1.tsc1" },
	{ 5, 116, 8208, "EmptyAxis1.tsc2" },
	{ 5, 129, 8208, "EmptyAxis1.sdc" },
	{ 5, 168, 8208, "EmptyAxis1.sfpos" },
	{ 5, 215, 8208, "EmptyAxis1.runv" },
	{ 6, 30, 8208, "EmptyAxis2.tpos" },
	{ 6, 32, 8208, "EmptyAxis2.fpos" },
	{ 6, 36, 8208, "EmptyAxis2.perr" },
	{ 6, 37, 8208, "EmptyAxis2.trqc" },
	{ 6, 38, 8208, "EmptyAxis2.vcmd" },
	{ 6, 39, 8208, "EmptyAxis2.vel" },
	{ 6, 74, 8208, "EmptyAxis2.faulted" },
	{ 6, 89, 8208, "EmptyAxis2.mposc" },
	{ 6, 107, 8208, "EmptyAxis2.mpgai" },
	{ 6, 108, 8208, "EmptyAxis2.mpgfi" },
	{ 6, 111, 8208, "EmptyAxis2.spgai" },
	{ 6, 112, 8208, "EmptyAxis2.spgfi" },
	{ 6, 113, 8208, "EmptyAxis2.tmc1" },
	{ 6, 114, 8208, "EmptyAxis2.tmc2" },
	{ 6, 115, 8208, "EmptyAxis2.tsc1" },
	{ 6, 116, 8208, "EmptyAxis2.tsc2" },
	{ 6, 129, 8208, "EmptyAxis2.sdc" },
	{ 6, 168, 8208, "EmptyAxis2.sfpos" },
	{ 6, 215, 8208, "EmptyAxis2.runv" },
	{ 8, 30, 8208, "EmptyAxis3.tpos" },
	{ 8, 32, 8208, "EmptyAxis3.fpos" },
	{ 8, 36, 8208, "EmptyAxis3.perr" },
	{ 8, 37, 8208, "EmptyAxis3.trqc" },
	{ 8, 38, 8208, "EmptyAxis3.vcmd" },
	{ 8, 39, 8208, "EmptyAxis3.vel" },
	{ 8, 74, 8208, "EmptyAxis3.faulted" },
	{ 8, 89, 8208, "EmptyAxis3.mposc" },
	{ 8, 107, 8208, "EmptyAxis3.mpgai" },
	{ 8, 108, 8208, "EmptyAxis3.mpgfi" },
	{ 8, 111, 8208, "EmptyAxis3.spgai" },
	{ 8, 112, 8208, "EmptyAxis3.spgfi" },
	{ 8, 113, 8208, "EmptyAxis3.tmc1" },
	{ 8, 114, 8208, "EmptyAxis3.tmc2" },
	{ 8, 115, 8208, "EmptyAxis3.tsc1" },
	{ 8, 116, 8208, "EmptyAxis3.tsc2" },
	{ 8, 129, 8208, "EmptyAxis3.sdc" },
	{ 8, 168, 8208, "EmptyAxis3.sfpos" },
	{ 8, 215, 8208, "EmptyAxis3.runv" },
	{ 4, 30, 8208, "Gripper.tpos" },
	{ 4, 32, 8208, "Gripper.fpos" },
	{ 4, 36, 8208, "Gripper.perr" },
	{ 4, 37, 8208, "Gripper.trqc" },
	{ 4, 38, 8208, "Gripper.vcmd" },
	{ 4, 39, 8208, "Gripper.vel" },
	{ 4, 74, 8208, "Gripper.faulted" },
	{ 4, 89, 8208, "Gripper.mposc" },
	{ 4, 107, 8208, "Gripper.mpgai" },
	{ 4, 108, 8208, "Gripper.mpgfi" },
	{ 4, 111, 8208, "Gripper.spgai" },
	{ 4, 112, 8208, "Gripper.spgfi" },
	{ 4, 113, 8208, "Gripper.tmc1" },
	{ 4, 114, 8208, "Gripper.tmc2" },
	{ 4, 115, 8208, "Gripper.tsc1" },
	{ 4, 116, 8208, "Gripper.tsc2" },
	{ 4, 129, 8208, "Gripper.sdc" },
	{ 4, 168, 8208, "Gripper.sfpos" },
	{ 4, 215, 8208, "Gripper.runv" },
	{ 3, 30, 8208, "ThetaAxis.tpos" },
	{ 3, 32, 8208, "ThetaAxis.fpos" },
	{ 3, 36, 8208, "ThetaAxis.perr" },
	{ 3, 37, 8208, "ThetaAxis.trqc" },
	{ 3, 38, 8208, "ThetaAxis.vcmd" },
	{ 3, 39, 8208, "ThetaAxis.vel" },
	{ 3, 74, 8208, "ThetaAxis.faulted" },
	{ 3, 89, 8208, "ThetaAxis.mposc" },
	{ 3, 107, 8208, "ThetaAxis.mpgai" },
	{ 3, 108, 8208, "ThetaAxis.mpgfi" },
	{ 3, 111, 8208, "ThetaAxis.spgai" },
	{ 3, 112, 8208, "ThetaAxis.spgfi" },
	{ 3, 113, 8208, "ThetaAxis.tmc1" },
	{ 3, 114, 8208, "ThetaAxis.tmc2" },
	{ 3, 115, 8208, "ThetaAxis.tsc1" },
	{ 3, 116, 8208, "ThetaAxis.tsc2" },
	{ 3, 129, 8208, "ThetaAxis.sdc" },
	{ 3, 168, 8208, "ThetaAxis.sfpos" },
	{ 3, 215, 8208, "ThetaAxis.runv" },
	{ 7, 30, 8208, "TransferStation.tpos" },
	{ 7, 32, 8208, "TransferStation.fpos" },
	{ 7, 36, 8208, "TransferStation.perr" },
	{ 7, 37, 8208, "TransferStation.trqc" },
	{ 7, 38, 8208, "TransferStation.vcmd" },
	{ 7, 39, 8208, "TransferStation.vel" },
	{ 7, 74, 8208, "TransferStation.faulted" },
	{ 7, 89, 8208, "TransferStation.mposc" },
	{ 7, 107, 8208, "TransferStation.mpgai" },
	{ 7, 108, 8208, "TransferStation.mpgfi" },
	{ 7, 111, 8208, "TransferStation.spgai" },
	{ 7, 112, 8208, "TransferStation.spgfi" },
	{ 7, 113, 8208, "TransferStation.tmc1" },
	{ 7, 114, 8208, "TransferStation.tmc2" },
	{ 7, 115, 8208, "TransferStation.tsc1" },
	{ 7, 116, 8208, "TransferStation.tsc2" },
	{ 7, 129, 8208, "TransferStation.sdc" },
	{ 7, 168, 8208, "TransferStation.sfpos" },
	{ 7, 215, 8208, "TransferStation.runv" },
	{ 0, 30, 8208, "XAxis.tpos" },
	{ 0, 32, 8208, "XAxis.fpos" },
	{ 0, 36, 8208, "XAxis.perr" },
	{ 0, 37, 8208, "XAxis.trqc" },
	{ 0, 38, 8208, "XAxis.vcmd" },
	{ 0, 39, 8208, "XAxis.vel" },
	{ 0, 74, 8208, "XAxis.faulted" },
	{ 0, 89, 8208, "XAxis.mposc" },
	{ 0, 107, 8208, "XAxis.mpgai" },
	{ 0, 108, 8208, "XAxis.mpgfi" },
	{ 0, 111, 8208, "XAxis.spgai" },
	{ 0, 112, 8208, "XAxis.spgfi" },
	{ 0, 113, 8208, "XAxis.tmc1" },
	{ 0, 114, 8208, "XAxis.tmc2" },
	{ 0, 115, 8208, "XAxis.tsc1" },
	{ 0, 116, 8208, "XAxis.tsc2" },
	{ 0, 129, 8208, "XAxis.sdc" },
	{ 0, 168, 8208, "XAxis.sfpos" },
	{ 0, 215, 8208, "XAxis.runv" },
	{ 1, 30, 8208, "YAxis.tpos" },
	{ 1, 32, 8208, "YAxis.fpos" },
	{ 1, 36, 8208, "YAxis.perr" },
	{ 1, 37, 8208, "YAxis.trqc" },
	{ 1, 38, 8208, "YAxis.vcmd" },
	{ 1, 39, 8208, "YAxis.vel" },
	{ 1, 74, 8208, "YAxis.faulted" },
	{ 1, 89, 8208, "YAxis.mposc" },
	{ 1, 107, 8208, "YAxis.mpgai" },
	{ 1, 108, 8208, "YAxis.mpgfi" },
	{ 1, 111, 8208, "YAxis.spgai" },
	{ 1, 112, 8208, "YAxis.spgfi" },
	{ 1, 113, 8208, "YAxis.tmc1" },
	{ 1, 114, 8208, "YAxis.tmc2" },
	{ 1, 115, 8208, "YAxis.tsc1" },
	{ 1, 116, 8208, "YAxis.tsc2" },
	{ 1, 129, 8208, "YAxis.sdc" },
	{ 1, 168, 8208, "YAxis.sfpos" },
	{ 1, 215, 8208, "YAxis.runv" },
	{ 2, 30, 8208, "ZAxis.tpos" },
	{ 2, 32, 8208, "ZAxis.fpos" },
	{ 2, 36, 8208, "ZAxis.perr" },
	{ 2, 37, 8208, "ZAxis.trqc" },
	{ 2, 38, 8208, "ZAxis.vcmd" },
	{ 2, 39, 8208, "ZAxis.vel" },
	{ 2, 74, 8208, "ZAxis.faulted" },
	{ 2, 89, 8208, "ZAxis.mposc" },
	{ 2, 107, 8208, "ZAxis.mpgai" },
	{ 2, 108, 8208, "ZAxis.mpgfi" },
	{ 2, 111, 8208, "ZAxis.spgai" },
	{ 2, 112, 8208, "ZAxis.spgfi" },
	{ 2, 113, 8208, "ZAxis.tmc1" },
	{ 2, 114, 8208, "ZAxis.tmc2" },
	{ 2, 115, 8208, "ZAxis.tsc1" },
	{ 2, 116, 8208, "ZAxis.tsc2" },
	{ 2, 129, 8208, "ZAxis.sdc" },
	{ 2, 168, 8208, "ZAxis.sfpos" },
	{ 2, 215, 8208, "ZAxis.runv" },
};
//--QS4SYMBOLTABLEN--//
#define	QS4SYMBOLS	410
//--QS4SYMBOLTABLEGUID--//
const char* QS4SYMBOLGUID = "00000000-0000-0000-0000-000000000000";

double __deltaCapture[CAPTURE_DEPTH];
int __ioCapture[IO_CAPTURES][CAPTURE_DEPTH];
double __dataCapture[DATA_CAPTURES][CAPTURE_DEPTH];

int __captureRegObjNum[DATA_CAPTURES];
int __capturePropNum[DATA_CAPTURES];
int __captureType[DATA_CAPTURES];

void* __capturePtrs[DATA_CAPTURES];
int __captureVType[DATA_CAPTURES];

#ifdef ABSTRACT_INTIME
static
#endif
double __GDT = 0;

#ifdef ABSTRACT_INTIME
static
#endif
double __GRDT = 0;

int __capptr = 0;
int __nobj = 0;

#ifdef ABSTRACT_INTIME
static
#endif
unsigned long globalLastTick = 0;
#ifdef ABSTRACT_INTIME
static
#endif
unsigned long globalLastSubTick = 0;

#if 0
int getTaskNumber(int i)
{
	if (_myTaskHandle1.value == TASK_THREADS[i].task->taskHandle)
	{
		// first task
		return 1;
	}
	else if (_myTaskHandle2.value == TASK_THREADS[i].task->taskHandle)
	{
		// second task
		return 2;
	}
	else
	{
		return 0;
	}
}
#endif

// Invoked during initialization for PID setup
void QS4ControlInit() {
	int i;
	for (i=0; i<DATA_CAPTURES; i++)
		__captureType[i] = CAPTURE_NONE;
	writeCAP(CAPTURE_IDLE);
	writeCAPDEPTH(CAPTURE_DEPTH);
	__nobj = sizeof(QS4Objects) / sizeof(void*);
	if (__nobj == 1)
	{
		if (QS4Objects[0] == NULL)  // PC_Realtime
		{
			__nobj = 0;
		}
	}
}

// Invoked periodically by the 5300 Analog_Scanner thread after all analog inputs are scanned
void QS4Control(int reason, void *info) {
	if (!__RUNTICK) return;
#ifdef ABSTRACT_INTIME
	_txe_mutex_get(__qs4_control_mutex, TX_WAIT_FOREVER);
#else
	tx_mutex_get(&__qs4_control_mutex, TX_WAIT_FOREVER);
#endif
	switch (reason) {
		case QS4C_BOARD_ANALOG_READ:
			processBoard((SlotMem_AIN *)info);
			break;
		case QS4C_ALL_ANALOG_READ:
			processTick();
			break;
	}
#ifdef ABSTRACT_INTIME
	_txe_mutex_put(__qs4_control_mutex);
#else
	tx_mutex_put(&__qs4_control_mutex);
#endif
}

int computeDT(unsigned long* lastTick, unsigned long* lastSubTick, double* dt, double* rdt) {
	unsigned long tick, subtick;
	int ok;
	long rawdt;
#ifdef ABSTRACT_INTIME
	tick = systemTics();
	subtick = 0;
#else
	unsigned long firstread;
	TX_INTERRUPT_SAVE_AREA
	TX_DISABLE
	firstread = AT91C_TC0_CV;
	tick = systemTics();
	subtick = AT91C_TC0_CV;
	if (subtick < firstread) tick++;
	TX_RESTORE
#endif
	if (*lastTick > 0) {
		rawdt = 5760*(tick - *lastTick) + (subtick - *lastSubTick);
		*dt = 173.61111111E-9 * (double)rawdt;
		*rdt = 1.0 / *dt;
		ok = 1;
	}
	else ok = 0;
	*lastTick = tick;
	*lastSubTick = subtick;
	return ok;
}

void processBoard(SlotMem_AIN *info) {
}

void initPWM(int reg, int period) {
	if (reg == 5903) {
		regWrite((UINT16)5903, 0);
		regWrite((UINT16)5904, period);
		regWrite((UINT16)5901, 65535);
		return;
	}
	if (reg == 5907) {
		regWrite((UINT16)5907, 0);
		regWrite((UINT16)5908, period);
		regWrite((UINT16)5905, 65535);
		return;
	}
}

void processPID(PID_Struct* pid, double dt, double rdt) {
	double delta_err = 0;
	double last_int;
	double output;
	double rsp;
	double drate;
	//
	pid->subtick++;
	pid->iperiod += dt;
	if (pid->subtick < pid->tick_multiplier) return;
	pid->period = pid->iperiod;
	pid->iperiod = 0;
	pid->rate = 1.0 / pid->period;
	pid->subtick = 0;
	//
	pid->feedback = pid->use_manual_feedback ? pid->manual_feedback : _DRX(pid->_RF_ptr, pid->_RF);
	if (pid->feedback < pid->feedback_lolimit) { pid->feedback = pid->feedback_lolimit; pid->in_feedback_limit = 1; }
	else if (pid->feedback > pid->feedback_hilimit) { pid->feedback = pid->feedback_hilimit; pid->in_feedback_limit = 1; }
	else pid->in_feedback_limit = 0;
	//
	drate = (pid->setpoint - pid->setpoint_rate_adjusted) * pid->rate;
	if (drate < 0) {
		if (-drate > pid->setpoint_rate)
			pid->setpoint_rate_adjusted -= pid->setpoint_rate * pid->period;
		else
			pid->setpoint_rate_adjusted = pid->setpoint;
	}
	else if (drate > 0) {
		if (drate > pid->setpoint_rate)
			pid->setpoint_rate_adjusted += pid->setpoint_rate * pid->period;
		else
			pid->setpoint_rate_adjusted = pid->setpoint;
	}
	rsp = pid->setpoint_rate_adjusted;
	if (rsp < pid->setpoint_lolimit) { rsp = pid->setpoint_lolimit; pid->in_setpoint_limit = 1; }
	else if (rsp > pid->setpoint_hilimit) { rsp = pid->setpoint_hilimit; pid->in_setpoint_limit = 1; }
	else pid->in_setpoint_limit = 0;
	//
	pid->error = rsp - pid->feedback;
	if (pid->error < pid->error_lolimit) { pid->error = pid->error_lolimit; pid->in_error_limit = 1; }
	else if (pid->error > pid->error_hilimit) { pid->error = pid->error_hilimit; pid->in_error_limit = 1; }
	else pid->in_error_limit = 0;
	//
	if (pid->derivative_form)
		delta_err = pid->error - pid->error0;
	else
		delta_err = pid->error - 2.0 * pid->error0 + pid->error1;
	pid->error1 = pid->error0;
	pid->error0 = pid->error;
	last_int = pid->integrator;
	if (____abs(pid->error) < pid->error_deadband) pid->error = 0;
	if (pid->derivative_form) {
		pid->integrator = pid->ki * pid->error * pid->period;
		output = pid->kp * (pid->error - pid->error0) + pid->integrator + pid->kd * delta_err * pid->rate + pid->kff * rsp;
	}
	else {
		pid->integrator += pid->ki * pid->error * pid->period;
		output = pid->kp * pid->error + pid->integrator + pid->kd * delta_err * pid->rate + pid->kff * rsp;
	}
	if (!pid->enabled) { output = 0; pid->error0 = pid->error1 = 0; }
	output += pid->offset;
#if 0
	if (output > pid->output_hilimit) { output = pid->output_hilimit; if (sign(output)==sign(pid->error)) pid->integrator = last_int * pid->integrator_unwind_constant; pid->in_output_limit = 1; }
	else if (output < pid->output_lolimit) { output = pid->output_lolimit; if (sign(output)==sign(pid->error)) pid->integrator = last_int * pid->integrator_unwind_constant; pid->in_output_limit = 1; }
	else pid->in_output_limit = 0;
#else
	// Below fixed to handle unwind properly, KRH
	if (output >= pid->output_hilimit)
	{
		output = pid->output_hilimit;
		if (sign(output)==sign(pid->error))
			pid->integrator = last_int * pid->integrator_unwind_constant;
		else if ((output == 0) && (sign(1)==sign(pid->error)))
			pid->integrator = last_int * pid->integrator_unwind_constant; 
		pid->in_output_limit = 1; 
	}
	else if (output <= pid->output_lolimit) 
	{
		output = pid->output_lolimit; 
		if (sign(output)==sign(pid->error)) 
			pid->integrator = last_int * pid->integrator_unwind_constant; 
		else if ((output == 0) && (sign(-1)==sign(pid->error)))
			pid->integrator = last_int * pid->integrator_unwind_constant;             
		pid->in_output_limit = 1; 
	}
	else 
		pid->in_output_limit = 0;

#endif
	if ((pid->ki == 0 || !pid->enabled) && !pid->in_output_limit) pid->integrator *= pid->integrator_unwind_constant;
	output *= pid->output_scale;
	if ((!pid->_RO_ptr) && ((int)pid->_RO == 5903 || (int)pid->_RO == 5907) && (output < 0)) output = 0;
	pid->output = output;
	if (!pid->first) {
		pid->first = 1;
		if (!pid->_RO_ptr) initPWM((int)pid->_RO, (int)(pid->output_hilimit * pid->output_scale));
	}
	_DWX(pid->_RO_ptr, pid->_RO, pid->output);
	pid->pcount++;
}

void* getObjectAddress(int objnum, int propnum, int* typeptr) {
	QS4OBJECT_HEADER *pobj;
	int* poffsets;
	int* ptypes;
	int size;
	void* voidptr;
	if (objnum < 0) return NULL;
	if (objnum >= __nobj) return NULL;
	pobj = QS4Objects[objnum];
	if (pobj == NULL) return NULL;
	poffsets = (int*)pobj->offsets;
	ptypes = (int*)pobj->types;
	size = *(poffsets - 1);
	if (propnum >= size) return NULL;
	poffsets += propnum;
	ptypes += propnum;
	voidptr = (unsigned char *)pobj + *poffsets;
	*typeptr = *ptypes;
	return voidptr;
}

void processCapture() {
	int i;
	int cap = readCAP();
	if (cap == CAPTURE_IDLE) return;
	switch (cap) {
		case CAPTURE_INIT:
			// init capture
			for (i=0; i<CAPTURE_DEPTH; i++) __deltaCapture[i] = 0;
			writeCAP(CAPTURE_ACTIVE);
			__capptr = 0;
			for (i=0; i<DATA_CAPTURES; i++) {
				switch(__captureType[i]) {
					case CAPTURE_OBJ:
						__capturePtrs[i] = getObjectAddress(__captureRegObjNum[i], __capturePropNum[i], &__captureVType[i]);
						break;
					default:
						__capturePtrs[i] = NULL;
						break;
				}
			}
		case CAPTURE_ACTIVE:
			// capture
			if (__capptr >= CAPTURE_DEPTH) { writeCAP(CAPTURE_IDLE); break; }
			if (__capptr >= readCAPDEPTH()) { writeCAP(CAPTURE_IDLE); break; }
			if (__capptr == 0)
				__deltaCapture[0] = 0;
			else
				__deltaCapture[__capptr] = __deltaCapture[__capptr-1] + __GDT;
			for (i=0; i<(IO_CAPTURES >> 1); i++)
				__ioCapture[i][__capptr] = _I(NULL, 11001+i, 0, 0);
			for (i=0; i<(IO_CAPTURES >> 1); i++)
				__ioCapture[i+(IO_CAPTURES >> 1)][__capptr] = _I(NULL, 10001+i, 0, 0);
			for (i=0; i<DATA_CAPTURES; i++) {
				switch(__captureType[i]) {
					case CAPTURE_NONE:
						break;
					case CAPTURE_OBJ:
						if (__capturePtrs[i] == NULL)
							__dataCapture[i][__capptr] = 0;
						else {
							switch (__captureVType[i]) {
								case VARIANT_INTEGER:
									__dataCapture[i][__capptr] = (double)(*((int*)(__capturePtrs[i])));
									break;
								case VARIANT_FLOAT:
									__dataCapture[i][__capptr] = (double)(*((float*)(__capturePtrs[i])));
									break;
								case VARIANT_DOUBLE:
									__dataCapture[i][__capptr] = (double)(*((double*)(__capturePtrs[i])));
									break;
								default:
									__dataCapture[i][__capptr] = 0;
									break;
							}
						}
						break;
					case CAPTURE_REG:
						__dataCapture[i][__capptr] = _D(NULL, __captureRegObjNum[i], 0, 0);
						break;
					case CAPTURE_AREG:
						__dataCapture[i][__capptr] = _D(NULL, 36822, __captureRegObjNum[i], __capturePropNum[i]);
						break;
				}
				if ((__capptr+1) < CAPTURE_DEPTH)
				{
					__dataCapture[i][__capptr+1] = 0;
				}
			}
			__capptr++;
			break;
		case CAPTURE_WAITING:
			break;
		default:
			writeCAP(CAPTURE_IDLE);
			break;
	}
}

void processTick() {
	int ok;
	int i;
	ok = computeDT(&globalLastTick, &globalLastSubTick, &__GDT, &__GRDT);
	if (!ok) return;
	for (i=0; i<sizeof(QS4Objects) / sizeof(void*); i++) {
		switch(QS4ObjectTypes[i]) {
			case __QS4OBJ_EMPTY:
				break;
			case __QS4OBJ_PID:
				processPID((PID_Struct*)QS4Objects[i], __GDT, __GRDT);
				break;
		}
	}
	processCapture();
}

int QS4I_READ_INT(int objnum, int propnum) {
	int VALUE = 0;
	switch (objnum) {
		//--QS4I_READ_INT--//
	}
	return VALUE;
}

float QS4I_READ_FLOAT(int objnum, int propnum) {
	float VALUE = 0;
	switch (objnum) {
		//--QS4I_READ_DOUBLE--//
	}
	return VALUE;
}


double QS4I_READ_DOUBLE(int objnum, int propnum) {
	double VALUE = 0;
	switch (objnum) {
		//--QS4I_READ_DOUBLE--//
	}
	return VALUE;
}

void QS4I_WRITE_INT(int objnum, int propnum, int VALUE) {
	switch (objnum) {
		//--QS4I_WRITE_INT--//
	}
}

void QS4I_WRITE_DOUBLE(int objnum, int propnum, double VALUE) {
	switch (objnum) {
		//--QS4I_WRITE_DOUBLE--//
	}
}

void QS4I_WRITE_FLOAT(int objnum, int propnum, float VALUE) {
	switch (objnum) {
		//--QS4I_WRITE_DOUBLE--//
	}
}


int handleSpecialQS4Read(int objnum, int propnum, int proptype, void *resultVal, QS4_BLOCKACCESS *blockaccess) {
	int i,j,k;
	int* iresult = (int*)resultVal;
	double* dresult = (double*)resultVal;
	float* fresult = (float*)resultVal;
	switch (-objnum) {
		case 1:		// Time-Deltas (for Capture)
			if (blockaccess == NULL) return -1;
			for (i=0; i<blockaccess->n; i++) {
				dresult[i] = __deltaCapture[i+blockaccess->offset];
			}
			return VARIANT_DOUBLE;
		case 2:		// I/O Capture
			if (blockaccess == NULL) return -1;
			if (propnum < 0) return -1;
			if (propnum >= IO_CAPTURES) return -1;
			for (i=0; i<blockaccess->n; i++) {
				iresult[i] = (int)__ioCapture[propnum][i+blockaccess->offset];
			}
			return VARIANT_INTEGER;
		case 3:		// Data Capture
			if (blockaccess == NULL) return -1;
			if (propnum < 0) return -1;
			if (propnum >= DATA_CAPTURES) return -1;
			for (i=0; i<blockaccess->n; i++) {
				dresult[i] = __dataCapture[propnum][i+blockaccess->offset];
			}
			return VARIANT_DOUBLE;
		case 4:		// Capture Set-up
			if (blockaccess == NULL) return -1;
			if (blockaccess->n != DATA_CAPTURES * 3) return -1;
			j = 0;
			for (i=0; i<blockaccess->n;) {
				iresult[i+0] = __captureRegObjNum[j];
				iresult[i+1] = __capturePropNum[j];
				iresult[i+2] = __captureType[j];
				 i += 3;
				j++;
			}
			return VARIANT_INTEGER;
		case 5:		// # of symbols in symbol table
			if (blockaccess != NULL) return -1;
			*iresult = QS4SYMBOLS;
			return VARIANT_INTEGER;
		case 6:		// get symbol
			if (blockaccess == NULL) return -1;
			if (propnum < 0) return -1;
			if (propnum >= QS4SYMBOLS) return -1;
			*iresult++ = QS4SymbolTable[propnum].regobj;
			*iresult++ = QS4SymbolTable[propnum].propnum;
			*iresult++ = QS4SymbolTable[propnum].type;
			k = 3;
			j = strlen(QS4SymbolTable[propnum].name) + 1;
			for (i=0; i<j; i++) {
				*iresult++ = QS4SymbolTable[propnum].name[i];
				k++;
			}
			blockaccess->n = k;
			return VARIANT_INTEGER;
		case 7:		// get symbol table GUID
			if (blockaccess == NULL) return -1;
			j = strlen(QS4SYMBOLGUID) + 1;
			for (i=0; i<j; i++) {
				*iresult++ = (int)(QS4SYMBOLGUID[i]);
			}
			blockaccess->n = j;
			return VARIANT_INTEGER;
		case 8:		// RESERVED
			break;
		case 9:		// Read Register via _D()
			if (blockaccess != NULL) return -1;
			*dresult = _D(NULL, propnum, 0, 0);
			return VARIANT_DOUBLE;
		case 10:		// Read Register via _F()
			if (blockaccess != NULL) return -1;
			*fresult = (float)_D(NULL, propnum, 0, 0);
			return VARIANT_FLOAT;
		case 13:  // $AXISMAP
			if ((propnum > MAX_AXIS) || (propnum < 1))
			{
				return -1;
			}
			if (blockaccess != NULL) return -1;
			*iresult = __axisMap[propnum-1];
			return VARIANT_INTEGER;

		default:
			break;
	}
	return -1;
}

int handleSpecialQS4Write(int objnum, int propnum, int proptype, void *resultVal, QS4_BLOCKACCESS *blockaccess) {
	int i,j,rv;
	int* iresult = (int*)resultVal;
	double* dresult = (double*)resultVal;
	float* fresult = (float*)resultVal;
	switch (-objnum) {
		case 1:		// RESERVED
		case 2:		// RESERVED
		case 3:		// RESERVED
			break;
		case 4:		// Capture Set-up
			if (blockaccess == NULL) return -1;
			if (blockaccess->n != DATA_CAPTURES * 3) return -1;
#ifdef ABSTRACT_INTIME
			_txe_mutex_get(__qs4_control_mutex, TX_WAIT_FOREVER);
#else
			tx_mutex_get(&__qs4_control_mutex, TX_WAIT_FOREVER);
#endif
			if (readCAP() == CAPTURE_IDLE) {
				j = 0;
				for (i=0; i<blockaccess->n;) {
					__captureRegObjNum[j] = iresult[i+0];
					__capturePropNum[j] = iresult[i+1];
					__captureType[j] = iresult[i+2];
					i += 3;
					j++;
				}
				rv = 0;
			}
			else
				rv = -1;
#ifdef ABSTRACT_INTIME
			_txe_mutex_put(__qs4_control_mutex);
#else
			tx_mutex_put(&__qs4_control_mutex);
#endif
			return rv;
		case 5:		// RESERVED
		case 6:		// RESERVED
		case 7:		// RESERVED
			break;
		case 8:		// STOP Axis
			// only stop axes
			if ((propnum & 0x7fff0000) > 0) return 0;
			if (propnum == 1024) {
				// STOP All Axis
				for (i=0; i<MAX_AXIS; i++) IPM_STOP_QS4(i, 1, 0);
				break;
			}
			IPM_STOP_QS4(propnum, 1, 0);
			return 0;
		case 9:		// Write Register via _DW()
			if (blockaccess != NULL) return -1;
			_DW(NULL, propnum, 0, 0, *dresult);
			return 0;
		case 10:		// Write Register via _FW()
			if (blockaccess != NULL) return -1;
			_FW(NULL, propnum, 0, 0, *fresult);
			return 0;
		case 11:        // Issue stop and load MSB's
			__initIPMs();
			break;
		case 13:
			if ((propnum > MAX_AXIS) || (propnum < 1))
			{
				return -1;
			}
			__axisMap[propnum-1] = *iresult;
			break;
		default:
			break;
	}
	return -1;
}

#ifdef ABSTRACT_INTIME
int getQS4ObjectIndirect(int write, int objnum, int propnum, int proptype, void *resultVal, void *pblk) {  // INTIME
	QS4_BLOCKACCESS *blockaccess = pblk;  // INTIME
#else
int getQS4ObjectIndirect(int write, int objnum, int propnum, int proptype, void *resultVal, QS4_BLOCKACCESS *blockaccess) {
#endif
	if (write) {
		if (objnum < 0) return handleSpecialQS4Write(objnum, propnum, proptype, resultVal, blockaccess);
		if (blockaccess != NULL) return -1;
		switch (proptype) {
			case VARIANT_INTEGER:
				QS4I_WRITE_INT(objnum, propnum, *((int*)resultVal));
				break;
			case VARIANT_DOUBLE:
				QS4I_WRITE_DOUBLE(objnum, propnum, *((double*)resultVal));
				break;
			case VARIANT_FLOAT:
				QS4I_WRITE_FLOAT(objnum, propnum, *((float*)resultVal));
				break;
			default:
				return -1;
		}
	}
	else {
		if (objnum < 0) return handleSpecialQS4Read(objnum, propnum, proptype, resultVal, blockaccess);
		switch (proptype) {
			case VARIANT_INTEGER:
				*((int*)resultVal) = QS4I_READ_INT(objnum, propnum);
				break;
			case VARIANT_DOUBLE:
				*((double*)resultVal) = QS4I_READ_DOUBLE(objnum, propnum);
				break;
			case VARIANT_FLOAT:
				*((float*)resultVal) = QS4I_READ_FLOAT(objnum, propnum);
				break;
			default:
				return -1;
		}
	}
	return 0;
}

void* getQS4ObjectTablePointer(int *size) {
	int sz = sizeof(QS4Objects) / sizeof(void*);
	if (sz == 1)
	{
		if (QS4Objects[0] == NULL)  // PC_Realtime
		{
			sz = 0;
		}
	}

	*size = sz;
	return &QS4Objects[0];
}

// Kill all other tasks except ours
void stepCancelOtherTasks(TASK *task)
{
#ifdef QB_RUNTIME

	TASK *tskptr;
	int i;
	for (i = 0;i!=MAX_TASK_THREADS;i++)
	{
		tskptr = TASK_THREADS[i].task;
		if (tskptr == NULL)
		{
			continue;
		}
		if (tskptr->state == TASK_UNUSED)
		{
			continue;
		}
		if (tskptr == task)
		{
			continue;
		}
		tskptr->state = TASK_DONE;
	}
#endif
}

#endif

// dir, -1 = ccw, 1 = cw
RETVAL _servoTurn(int axis, int mode, int dir, int position)
{
	/* reserved for decoding TURN Servo TURN Servo Extended */
	UINT8  servonum=axis;
	UINT8  command = mode;
	RETVAL parse_status;
	STDVAL value, target;
	UINT8  attributes[2];
	STDVAL values[2];		 

	/* Check for "TURN VELOCITY" */
	if( command & __CTC_SERVO_VELOCITY_MOVE) {
		/* Turn Velocity */
		switch( dir ) {
		case -1:  /* velocity move counter-clockwise */
			return Motion_Simple_Command( servonum,
				__MOTION_COMMAND_MOVE_VEL_REVERSE);
		case 1:  /* velocity move clockwise */
			return Motion_Simple_Command( servonum,
				__MOTION_COMMAND_MOVE_VEL_FORWARD);
		}
		/* end Turn Velocity */
	}
	/* Check for TURN to absolute position */
	if( command & __CTC_SERVO_ABSOLUTE_MOVE) {
		/* Turn to Absolute position */
		target = position;
		attributes[0] = __MOTION_ATTRIBUTE_TARGET;
		values[0] = target;
		/* Write new Target Position */
		parse_status = Motion_Put_Attributes( servonum, 1, 
			attributes, values);
		if( parse_status != SUCCESS) {
			return parse_status;
		}
		/* Begin motion */
		return Motion_Simple_Command( servonum,
			__MOTION_COMMAND_MOVE_TO_TARGET);
		/* End Turn Absolute */
	}
	/* Check for Relative Move */
	if( command & __CTC_SERVO_RELATIVE_MOVE) {
		/* Fetch current Target Position */
		parse_status = Motion_Get_Attribute( servonum, 
			__MOTION_ATTRIBUTE_TARGET, &target);
		if( parse_status != SUCCESS) {
			return parse_status;
		}
		/* Get relative move value */
		value = position;
		if( dir > 0) {
			/* Turn Relative Clockwise */
			target += value;
		}
		else {
			/* Turn Relative Counter-clockwise */
			target -= value;
		}
		/* Write new Target Position */
		attributes[0] = __MOTION_ATTRIBUTE_TARGET;
		values[0] = target;
		parse_status = Motion_Put_Attributes( servonum, 1,
			attributes, values);
		if( parse_status != SUCCESS) {
			return parse_status;
		}
		/* Begin motion */
		return Motion_Simple_Command( servonum,
			__MOTION_COMMAND_MOVE_TO_TARGET);
		/* End Relative Move */
	}
	return ERROR_ILLEGAL_INST;
}

// Get the desired information from the motor
RETVAL _servoInfo(int axis, int cmd)
{
INT32 result;
int r;
int axisNum = axis;
UINT8 attributes[2];
STDVAL values[2];

	axis = axis * 10;

	switch(cmd)
	{
		case __CTC_SERVO_RUNNING:
			r = __CTC_SERVO_STATUS_REG  + axis;
			regRead((UINT16)r, &result);
			if (result > 1)
			{
				return 1;  // moving
			}
			return 0;  // not moving or initialized
		case __CTC_SERVO_STOPPED:
			r = __CTC_SERVO_STATUS_REG  + axis;
			regRead((UINT16)r, &result);
			if (result == 1)
			{
				return 1;  // stopped and ready
			}
			return 0;  // not ready or stopped

		case __CTC_SERVO_ERROR:
			r = __CTC_SERVO_ERROR_REG + axis;
			regRead((UINT16)r, &result);
			return result;
		case __CTC_SERVO_POSITION:
			r = __CTC_SERVO_ERROR_REG + axis;
			regRead((UINT16)r, &result);
			return result;
		case __CTC_MOTION_SOFTSTOP:
		case __CTC_MOTION_HARDSTOP:
		case __CTC_MOTION_SEARCH_AND_HOME:
			if (Motion_Simple_Command(axisNum,cmd) == SUCCESS)
			{
				return 0;
			}
			return -1;
		case __CTC_MOTION_ZERO:
			attributes[0] =__MOTION_ATTRIBUTE_FORCE_POSITION;
			values[0] = 0;
			if (Motion_Put_Attributes((unsigned char)axisNum,1, attributes, values) == SUCCESS)
			{
				return 0;
			}
			return -1;
		default:
			return 0;	// ???
			break;
	}
	return 0;
}

int checkForBreakpoints(STDVAL value, TASK *task) {
	return FALSE;
}

void process_ATABLE(STDVAL value, TASK *task) {
	if (checkForBreakpoints(value, task)) { return; /* stall */ }
	switch(value) {
		case -1: process_INIT(task); return;
		case 0:  /* R20099_ModBusTCPWordSwap=1 */ _IW(task,20099,(int)(0),(int)(0),(int)(1)); return;
		case 1:  /* $REGISTERS[12305]=2 */ _IW(task,-5,(int)((int)(12305)),(int)(0),(int)(2)); return;
		case 2:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 3:  /* R10_Mode=0 */ _IW(task,10,(int)(0),(int)(0),(int)(0)); return;
		case 4: /* INLINE_0 */ { TASK* t; t = CREATETASK(task, 12); _IW(task,36201,(int)((int)(0)),(int)(0),t->taskHandle);  _tx_thread_resume(&TASK_THREADS[Q4T(t)->taskThread_index].thread);t = CREATETASK(task, 62); _IW(task,36201,(int)((int)(1)),(int)(0),t->taskHandle);  _tx_thread_resume(&TASK_THREADS[Q4T(t)->taskThread_index].thread);t = CREATETASK(task, 90); _IW(task,36201,(int)((int)(2)),(int)(0),t->taskHandle);  _tx_thread_resume(&TASK_THREADS[Q4T(t)->taskThread_index].thread);t = CREATETASK(task, 118); _IW(task,36201,(int)((int)(3)),(int)(0),t->taskHandle);  _tx_thread_resume(&TASK_THREADS[Q4T(t)->taskThread_index].thread);_IW(task,36201,(int)((int)(4)),(int)(0),0); };; return;
		case 5: /* INLINE_1 */ { TASK *t;t=CREATETASK(task, 306); _tx_thread_resume(&TASK_THREADS[Q4T(t)->taskThread_index].thread);t=CREATETASK(task, 304); _tx_thread_resume(&TASK_THREADS[Q4T(t)->taskThread_index].thread);t=CREATETASK(task, 119); _tx_thread_resume(&TASK_THREADS[Q4T(t)->taskThread_index].thread);t=CREATETASK(task, 147); _tx_thread_resume(&TASK_THREADS[Q4T(t)->taskThread_index].thread);t=CREATETASK(task, 178); _tx_thread_resume(&TASK_THREADS[Q4T(t)->taskThread_index].thread);t=CREATETASK(task, 206); _tx_thread_resume(&TASK_THREADS[Q4T(t)->taskThread_index].thread);t=CREATETASK(task, 234); _tx_thread_resume(&TASK_THREADS[Q4T(t)->taskThread_index].thread);t=CREATETASK(task, 269); _tx_thread_resume(&TASK_THREADS[Q4T(t)->taskThread_index].thread);};; return;
		case 6:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 7: /* INLINE_2 */ IPM_START_SB(0,0,0);; return;
		case 8: /* INLINE_3 */ IPM_START_SB(1,0,0);; return;
		case 9: /* INLINE_4 */ IPM_START_SB(2,0,0);; return;
		case 10:  /* R510_XAxisCommands=0 */ _IW(task,510,(int)(0),(int)(0),(int)(0)); return;
		case 11:  /* R520_YAxisCommands=0 */ _IW(task,520,(int)(0),(int)(0),(int)(0)); return;
		case 12:  /* R530_ZAxisCommands=0 */ _IW(task,530,(int)(0),(int)(0),(int)(0)); return;
		case 13:  /* R540_ThetaCommands=0 */ _IW(task,540,(int)(0),(int)(0),(int)(0)); return;
		case 14:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 15:  /* R36701_Speed=R501_Speed */ _FW(task,36701,(int)(0),(int)(0),(float)(_I(task,501,(int)(0),(int)(0)))); return;
		case 16:  /* R36702_Accel=R502_Accel */ _FW(task,36702,(int)(0),(int)(0),(float)(_I(task,502,(int)(0),(int)(0)))); return;
		case 17:  /* R36703_Decel=R503_Decel */ _FW(task,36703,(int)(0),(int)(0),(float)(_I(task,503,(int)(0),(int)(0)))); return;
		case 18:  /* R36704_XTarget=R504_Target */ _FW(task,36704,(int)(0),(int)(0),(float)(_I(task,504,(int)(0),(int)(0)))); return;
		case 19:  /* R36705_YTarget=R514_Target */ _FW(task,36705,(int)(0),(int)(0),(float)(_I(task,514,(int)(0),(int)(0)))); return;
		case 20:  /* R36706_ZTarget=R524_Target */ _FW(task,36706,(int)(0),(int)(0),(float)(_I(task,524,(int)(0),(int)(0)))); return;
		case 21:  /* XAxis.speed=R36701_Speed/1000 */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_speed,(double)(_F(task,36701,(int)(0),(int)(0))/1000)); return;
		case 22:  /* XAxis.Accel=R36702_Accel/1000 */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Accel,(double)(_F(task,36702,(int)(0),(int)(0))/1000)); return;
		case 23:  /* XAxis.Decel=R36703_Decel/1000 */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Decel,(double)(_F(task,36703,(int)(0),(int)(0))/1000)); return;
		case 24:  /* XAxis.XTarget=R36704_XTarget/1000 */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_XTarget,(double)(_F(task,36704,(int)(0),(int)(0))/1000)); return;
		case 25:  /* XAxis.YTarget=R36705_YTarget/1000 */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_YTarget,(double)(_F(task,36705,(int)(0),(int)(0))/1000)); return;
		case 26:  /* XAxis.ZTarget=R36706_ZTarget/1000 */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_ZTarget,(double)(_F(task,36706,(int)(0),(int)(0))/1000)); return;
		case 27:  /* XAxis.command=10 */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_command,(double)(10)); return;
		case 28:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 29:  /* F1_Trigger=false */ _IW(task,13201,(int)(0),(int)(0),(int)(____false)); return;
		case 30:  /* R510_XAxisCommands=0 */ _IW(task,510,(int)(0),(int)(0),(int)(0)); return;
		case 31:  /* R500_RestartProgram=0 */ _IW(task,500,(int)(0),(int)(0),(int)(0)); return;
		case 32: /* INLINE_5 */ IPM_STOP_QS4(0,1,0);; return;
		case 33: /* INLINE_6 */ IPM_STOP_QS4(1,1,0);; return;
		case 34: /* INLINE_7 */ IPM_STOP_QS4(2,1,0);; return;
		case 35: /* INLINE_8 */ IPM_STOP_QS4(3,1,0);; return;
		case 36: /* INLINE_9 */ IPM_STOP_QS4(4,1,0);; return;
		case 37: /* INLINE_10 */ IPM_STOP_QS4(5,1,0);; return;
		case 38: /* INLINE_11 */ IPM_STOP_QS4(6,1,0);; return;
		case 39: /* INLINE_12 */ IPM_STOP_QS4(7,1,0);; return;
		case 40: /* INLINE_13 */ IPM_STOP_QS4(8,1,0);; return;
		case 41:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 42:  /* $REGISTERS[10101]=0 */ _IW(task,-5,(int)((int)(10101)),(int)(0),(int)(0)); return;
		case 43:  /* i=0 */ _IW(task,1,(int)(0),(int)(0),(int)(0)); return;
		case 44:  /* R12333_RestartEtherCAT=1 */ _IW(task,12333,(int)(0),(int)(0),(int)(1)); return;
		case 45:  /* R13464_EtherCATStatus=21930 */ _IW(task,13464,(int)(0),(int)(0),(int)(21930)); return;
		case 46:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 47: /* INLINE_14 */ IPM_START_SB(0,1,0);; return;
		case 48:  /* XAxis.command=0 */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_command,(double)(0)); return;
		case 49:  /* R510_XAxisCommands=0 */ _IW(task,510,(int)(0),(int)(0),(int)(0)); return;
		case 50:  /* XAxis.Maxspeed=R501_Speed */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Maxspeed,(double)(_I(task,501,(int)(0),(int)(0)))); return;
		case 51:  /* XAxis.Accel=R502_Accel */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Accel,(double)(_I(task,502,(int)(0),(int)(0)))); return;
		case 52:  /* XAxis.Decel=R503_Decel */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Decel,(double)(_I(task,503,(int)(0),(int)(0)))); return;
		case 53:  /* XAxis.Target=R504_Target */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Target,(double)(_I(task,504,(int)(0),(int)(0)))); return;
		case 54:  /* XAxis.command=(R510_XAxisCommands) */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_command,(double)((_I(task,510,(int)(0),(int)(0))))); return;
		case 55:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 56:  /* running1=true */ _IW(task,20,(int)(0),(int)(0),(int)(____true)); return;
		case 57:  /* XAxis.Maxspeed=R501_Speed */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Maxspeed,(double)(_I(task,501,(int)(0),(int)(0)))); return;
		case 58:  /* XAxis.Accel=R502_Accel */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Accel,(double)(_I(task,502,(int)(0),(int)(0)))); return;
		case 59:  /* XAxis.Decel=R503_Decel */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Decel,(double)(_I(task,503,(int)(0),(int)(0)))); return;
		case 60:  /* XAxis.command=(R510_XAxisCommands) */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_command,(double)((_I(task,510,(int)(0),(int)(0))))); return;
		case 61:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 62:  /* running1=true */ _IW(task,20,(int)(0),(int)(0),(int)(____true)); return;
		case 63:  /* XAxis.Maxspeed=R501_Speed */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Maxspeed,(double)(_I(task,501,(int)(0),(int)(0)))); return;
		case 64:  /* XAxis.Accel=R502_Accel */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Accel,(double)(_I(task,502,(int)(0),(int)(0)))); return;
		case 65:  /* XAxis.Decel=R503_Decel */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Decel,(double)(_I(task,503,(int)(0),(int)(0)))); return;
		case 66:  /* XAxis.Target=R504_Target */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Target,(double)(_I(task,504,(int)(0),(int)(0)))); return;
		case 67:  /* XAxis.OffsetHome=R505_HomeOffset */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_OffsetHome,(double)(_I(task,505,(int)(0),(int)(0)))); return;
		case 68:  /* XAxis.command=5 */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_command,(double)(5)); return;
		case 69:  /* running1=true */ _IW(task,20,(int)(0),(int)(0),(int)(____true)); return;
		case 70:  /* XAxis.command=0 */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_command,(double)(0)); return;
		case 71:  /* running1=false */ _IW(task,20,(int)(0),(int)(0),(int)(____false)); return;
		case 72:  /* XAxis.command=R510_XAxisCommands */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_command,(double)(_I(task,510,(int)(0),(int)(0)))); return;
		case 73:  /* R510_XAxisCommands=0 */ _IW(task,510,(int)(0),(int)(0),(int)(0)); return;
		case 74: /* INLINE_15 */ IPM_START_SB(1,1,0);; return;
		case 75:  /* YAxis.command=0 */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_command,(double)(0)); return;
		case 76:  /* R520_YAxisCommands=0 */ _IW(task,520,(int)(0),(int)(0),(int)(0)); return;
		case 77:  /* YAxis.Maxspeed=R511_Speed */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Maxspeed,(double)(_I(task,511,(int)(0),(int)(0)))); return;
		case 78:  /* YAxis.Accel=R512_Accel */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Accel,(double)(_I(task,512,(int)(0),(int)(0)))); return;
		case 79:  /* YAxis.Decel=R513_Decel */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Decel,(double)(_I(task,513,(int)(0),(int)(0)))); return;
		case 80:  /* YAxis.Target=R514_Target */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Target,(double)(_I(task,514,(int)(0),(int)(0)))); return;
		case 81:  /* YAxis.command=(R520_YAxisCommands) */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_command,(double)((_I(task,520,(int)(0),(int)(0))))); return;
		case 82:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 83:  /* running2=true */ _IW(task,21,(int)(0),(int)(0),(int)(____true)); return;
		case 84:  /* YAxis.Maxspeed=R511_Speed */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Maxspeed,(double)(_I(task,511,(int)(0),(int)(0)))); return;
		case 85:  /* YAxis.Accel=R512_Accel */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Accel,(double)(_I(task,512,(int)(0),(int)(0)))); return;
		case 86:  /* YAxis.Decel=R513_Decel */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Decel,(double)(_I(task,513,(int)(0),(int)(0)))); return;
		case 87:  /* YAxis.command=(R520_YAxisCommands) */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_command,(double)((_I(task,520,(int)(0),(int)(0))))); return;
		case 88:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 89:  /* running2=true */ _IW(task,21,(int)(0),(int)(0),(int)(____true)); return;
		case 90:  /* YAxis.Maxspeed=R511_Speed */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Maxspeed,(double)(_I(task,511,(int)(0),(int)(0)))); return;
		case 91:  /* YAxis.Accel=R512_Accel */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Accel,(double)(_I(task,512,(int)(0),(int)(0)))); return;
		case 92:  /* YAxis.Decel=R513_Decel */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Decel,(double)(_I(task,513,(int)(0),(int)(0)))); return;
		case 93:  /* YAxis.Target=R514_Target */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Target,(double)(_I(task,514,(int)(0),(int)(0)))); return;
		case 94:  /* YAxis.OffsetHome=R515_HomeOffset */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_OffsetHome,(double)(_I(task,515,(int)(0),(int)(0)))); return;
		case 95:  /* YAxis.command=5 */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_command,(double)(5)); return;
		case 96:  /* running2=true */ _IW(task,21,(int)(0),(int)(0),(int)(____true)); return;
		case 97:  /* YAxis.command=0 */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_command,(double)(0)); return;
		case 98:  /* running2=false */ _IW(task,21,(int)(0),(int)(0),(int)(____false)); return;
		case 99:  /* YAxis.command=R520_YAxisCommands */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_command,(double)(_I(task,520,(int)(0),(int)(0)))); return;
		case 100:  /* R520_YAxisCommands=0 */ _IW(task,520,(int)(0),(int)(0),(int)(0)); return;
		case 101: /* INLINE_16 */ IPM_START_SB(2,1,0);; return;
		case 102:  /* ZAxis.command=0 */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_command,(double)(0)); return;
		case 103:  /* R530_ZAxisCommands=0 */ _IW(task,530,(int)(0),(int)(0),(int)(0)); return;
		case 104:  /* ZAxis.Maxspeed=R521_Speed */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Maxspeed,(double)(_I(task,521,(int)(0),(int)(0)))); return;
		case 105:  /* ZAxis.Accel=R522_Accel */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Accel,(double)(_I(task,522,(int)(0),(int)(0)))); return;
		case 106:  /* ZAxis.Decel=R523_Decel */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Decel,(double)(_I(task,523,(int)(0),(int)(0)))); return;
		case 107:  /* ZAxis.Target=R524_Target */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Target,(double)(_I(task,524,(int)(0),(int)(0)))); return;
		case 108:  /* ZAxis.command=(R530_ZAxisCommands) */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_command,(double)((_I(task,530,(int)(0),(int)(0))))); return;
		case 109:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 110:  /* running3=true */ _IW(task,22,(int)(0),(int)(0),(int)(____true)); return;
		case 111:  /* ZAxis.Maxspeed=R521_Speed */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Maxspeed,(double)(_I(task,521,(int)(0),(int)(0)))); return;
		case 112:  /* ZAxis.Accel=R522_Accel */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Accel,(double)(_I(task,522,(int)(0),(int)(0)))); return;
		case 113:  /* ZAxis.Decel=R523_Decel */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Decel,(double)(_I(task,523,(int)(0),(int)(0)))); return;
		case 114:  /* ZAxis.command=(R530_ZAxisCommands) */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_command,(double)((_I(task,530,(int)(0),(int)(0))))); return;
		case 115:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 116:  /* running3=true */ _IW(task,22,(int)(0),(int)(0),(int)(____true)); return;
		case 117:  /* ZAxis.Maxspeed=R521_Speed */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Maxspeed,(double)(_I(task,521,(int)(0),(int)(0)))); return;
		case 118:  /* ZAxis.Accel=R522_Accel */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Accel,(double)(_I(task,522,(int)(0),(int)(0)))); return;
		case 119:  /* ZAxis.Decel=R523_Decel */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Decel,(double)(_I(task,523,(int)(0),(int)(0)))); return;
		case 120:  /* ZAxis.Target=R524_Target */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Target,(double)(_I(task,524,(int)(0),(int)(0)))); return;
		case 121:  /* ZAxis.OffsetHome=R525_HomeOffset */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_OffsetHome,(double)(_I(task,525,(int)(0),(int)(0)))); return;
		case 122:  /* ZAxis.command=5 */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_command,(double)(5)); return;
		case 123:  /* running3=true */ _IW(task,22,(int)(0),(int)(0),(int)(____true)); return;
		case 124:  /* ZAxis.command=0 */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_command,(double)(0)); return;
		case 125:  /* running3=false */ _IW(task,22,(int)(0),(int)(0),(int)(____false)); return;
		case 126:  /* ZAxis.command=R530_ZAxisCommands */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_command,(double)(_I(task,530,(int)(0),(int)(0)))); return;
		case 127:  /* R530_ZAxisCommands=0 */ _IW(task,530,(int)(0),(int)(0),(int)(0)); return;
		case 128: /* INLINE_17 */ IPM_START_SB(3,0,0);; return;
		case 129:  /* ThetaAxis.command=0 */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_command,(double)(0)); return;
		case 130:  /* R540_ThetaCommands=0 */ _IW(task,540,(int)(0),(int)(0),(int)(0)); return;
		case 131:  /* ThetaAxis.Maxspeed=R531_Speed */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Maxspeed,(double)(_I(task,531,(int)(0),(int)(0)))); return;
		case 132:  /* ThetaAxis.Accel=R532_Accel */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Accel,(double)(_I(task,532,(int)(0),(int)(0)))); return;
		case 133:  /* ThetaAxis.Decel=R533_Decel */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Decel,(double)(_I(task,533,(int)(0),(int)(0)))); return;
		case 134:  /* ThetaAxis.Target=R534_Target */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Target,(double)(_I(task,534,(int)(0),(int)(0)))); return;
		case 135:  /* ThetaAxis.command=(R540_ThetaCommands) */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_command,(double)((_I(task,540,(int)(0),(int)(0))))); return;
		case 136:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 137:  /* running4=true */ _IW(task,23,(int)(0),(int)(0),(int)(____true)); return;
		case 138:  /* ThetaAxis.Maxspeed=R531_Speed */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Maxspeed,(double)(_I(task,531,(int)(0),(int)(0)))); return;
		case 139:  /* ThetaAxis.Accel=R532_Accel */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Accel,(double)(_I(task,532,(int)(0),(int)(0)))); return;
		case 140:  /* ThetaAxis.Decel=R533_Decel */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Decel,(double)(_I(task,533,(int)(0),(int)(0)))); return;
		case 141:  /* ThetaAxis.command=(R540_ThetaCommands) */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_command,(double)((_I(task,540,(int)(0),(int)(0))))); return;
		case 142:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 143:  /* running4=true */ _IW(task,23,(int)(0),(int)(0),(int)(____true)); return;
		case 144:  /* ThetaAxis.Maxspeed=R531_Speed */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Maxspeed,(double)(_I(task,531,(int)(0),(int)(0)))); return;
		case 145:  /* ThetaAxis.Accel=R532_Accel */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Accel,(double)(_I(task,532,(int)(0),(int)(0)))); return;
		case 146:  /* ThetaAxis.Decel=R533_Decel */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Decel,(double)(_I(task,533,(int)(0),(int)(0)))); return;
		case 147:  /* ThetaAxis.Target=R534_Target */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Target,(double)(_I(task,534,(int)(0),(int)(0)))); return;
		case 148:  /* ThetaAxis.OffsetHome=R535_HomeOffset */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_OffsetHome,(double)(_I(task,535,(int)(0),(int)(0)))); return;
		case 149:  /* ThetaAxis.command=5 */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_command,(double)(5)); return;
		case 150:  /* running4=true */ _IW(task,23,(int)(0),(int)(0),(int)(____true)); return;
		case 151:  /* ThetaAxis.command=0 */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_command,(double)(0)); return;
		case 152:  /* running4=false */ _IW(task,23,(int)(0),(int)(0),(int)(____false)); return;
		case 153:  /* ThetaAxis.command=R540_ThetaCommands */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_command,(double)(_I(task,540,(int)(0),(int)(0)))); return;
		case 154:  /* R540_ThetaCommands=0 */ _IW(task,540,(int)(0),(int)(0),(int)(0)); return;
		case 155: /* INLINE_18 */ IPM_START_SB(4,0,0);; return;
		case 156:  /* Gripper.command=0 */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_command,(double)(0)); return;
		case 157:  /* R550_GripperCommands=0 */ _IW(task,550,(int)(0),(int)(0),(int)(0)); return;
		case 158:  /* Gripper.Maxspeed=R541_Speed */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_Maxspeed,(double)(_I(task,541,(int)(0),(int)(0)))); return;
		case 159:  /* Gripper.Accel=R542_Accel */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_Accel,(double)(_I(task,542,(int)(0),(int)(0)))); return;
		case 160:  /* Gripper.Decel=R543_Decel */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_Decel,(double)(_I(task,543,(int)(0),(int)(0)))); return;
		case 161:  /* Gripper.Target=R544_Target */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_Target,(double)(_I(task,544,(int)(0),(int)(0)))); return;
		case 162:  /* Gripper.command=(R550_GripperCommands) */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_command,(double)((_I(task,550,(int)(0),(int)(0))))); return;
		case 163:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 164:  /* running5=true */ _IW(task,24,(int)(0),(int)(0),(int)(____true)); return;
		case 165:  /* Gripper.Maxspeed=R541_Speed */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_Maxspeed,(double)(_I(task,541,(int)(0),(int)(0)))); return;
		case 166:  /* Gripper.Accel=R542_Accel */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_Accel,(double)(_I(task,542,(int)(0),(int)(0)))); return;
		case 167:  /* Gripper.Decel=R543_Decel */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_Decel,(double)(_I(task,543,(int)(0),(int)(0)))); return;
		case 168:  /* Gripper.command=(R550_GripperCommands) */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_command,(double)((_I(task,550,(int)(0),(int)(0))))); return;
		case 169:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 170:  /* running5=true */ _IW(task,24,(int)(0),(int)(0),(int)(____true)); return;
		case 171:  /* Gripper.Maxspeed=R541_Speed */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_Maxspeed,(double)(_I(task,541,(int)(0),(int)(0)))); return;
		case 172:  /* Gripper.Accel=R542_Accel */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_Accel,(double)(_I(task,542,(int)(0),(int)(0)))); return;
		case 173:  /* Gripper.Decel=R533_Decel */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_Decel,(double)(_I(task,533,(int)(0),(int)(0)))); return;
		case 174:  /* Gripper.Target=R544_Target */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_Target,(double)(_I(task,544,(int)(0),(int)(0)))); return;
		case 175:  /* Gripper.OffsetHome=R545_HomeOffset */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_OffsetHome,(double)(_I(task,545,(int)(0),(int)(0)))); return;
		case 176:  /* Gripper.command=5 */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_command,(double)(5)); return;
		case 177:  /* running5=true */ _IW(task,24,(int)(0),(int)(0),(int)(____true)); return;
		case 178:  /* Gripper.command=0 */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_command,(double)(0)); return;
		case 179:  /* running5=false */ _IW(task,24,(int)(0),(int)(0),(int)(____false)); return;
		case 180:  /* Gripper.command=R550_GripperCommands */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_command,(double)(_I(task,550,(int)(0),(int)(0)))); return;
		case 181:  /* R550_GripperCommands=0 */ _IW(task,550,(int)(0),(int)(0),(int)(0)); return;
		case 182:  /* Gripper.NewPosition=0 */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_NewPosition,(double)(0)); return;
		case 183:  /* Gripper.command=R550_GripperCommands */ _DW(task,36822,__axisMap[4]-1,__IPMVAR_CTC_Gripper_command,(double)(_I(task,550,(int)(0),(int)(0)))); return;
		case 184:  /* R550_GripperCommands=0 */ _IW(task,550,(int)(0),(int)(0),(int)(0)); return;
		case 185: /* INLINE_19 */ IPM_START_SB(5,0,0);; return;
		case 186:  /* EmptyAxis1.command=0 */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_command,(double)(0)); return;
		case 187:  /* R570_Empty1Commands=0 */ _IW(task,570,(int)(0),(int)(0),(int)(0)); return;
		case 188:  /* EmptyAxis1.Maxspeed=R561_Speed */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_Maxspeed,(double)(_I(task,561,(int)(0),(int)(0)))); return;
		case 189:  /* EmptyAxis1.Accel=R562_Accel */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_Accel,(double)(_I(task,562,(int)(0),(int)(0)))); return;
		case 190:  /* EmptyAxis1.Decel=R563_Decel */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_Decel,(double)(_I(task,563,(int)(0),(int)(0)))); return;
		case 191:  /* EmptyAxis1.Target=R564_Target */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_Target,(double)(_I(task,564,(int)(0),(int)(0)))); return;
		case 192:  /* EmptyAxis1.command=(R570_Empty1Commands) */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_command,(double)((_I(task,570,(int)(0),(int)(0))))); return;
		case 193:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 194:  /* running7=true */ _IW(task,26,(int)(0),(int)(0),(int)(____true)); return;
		case 195:  /* EmptyAxis1.Maxspeed=R561_Speed */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_Maxspeed,(double)(_I(task,561,(int)(0),(int)(0)))); return;
		case 196:  /* EmptyAxis1.Accel=R562_Accel */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_Accel,(double)(_I(task,562,(int)(0),(int)(0)))); return;
		case 197:  /* EmptyAxis1.Decel=R563_Decel */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_Decel,(double)(_I(task,563,(int)(0),(int)(0)))); return;
		case 198:  /* EmptyAxis1.command=(R570_Empty1Commands) */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_command,(double)((_I(task,570,(int)(0),(int)(0))))); return;
		case 199:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 200:  /* running7=true */ _IW(task,26,(int)(0),(int)(0),(int)(____true)); return;
		case 201:  /* EmptyAxis1.Maxspeed=R561_Speed */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_Maxspeed,(double)(_I(task,561,(int)(0),(int)(0)))); return;
		case 202:  /* EmptyAxis1.Accel=R562_Accel */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_Accel,(double)(_I(task,562,(int)(0),(int)(0)))); return;
		case 203:  /* EmptyAxis1.Decel=R563_Decel */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_Decel,(double)(_I(task,563,(int)(0),(int)(0)))); return;
		case 204:  /* EmptyAxis1.Target=R564_Target */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_Target,(double)(_I(task,564,(int)(0),(int)(0)))); return;
		case 205:  /* EmptyAxis1.OffsetHome=R565_HomeOffset */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_OffsetHome,(double)(_I(task,565,(int)(0),(int)(0)))); return;
		case 206:  /* EmptyAxis1.command=5 */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_command,(double)(5)); return;
		case 207:  /* running7=true */ _IW(task,26,(int)(0),(int)(0),(int)(____true)); return;
		case 208:  /* EmptyAxis1.command=0 */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_command,(double)(0)); return;
		case 209:  /* running7=false */ _IW(task,26,(int)(0),(int)(0),(int)(____false)); return;
		case 210:  /* EmptyAxis1.command=R570_Empty1Commands */ _DW(task,36822,__axisMap[5]-1,__IPMVAR_CTC_EmptyAxis1_command,(double)(_I(task,570,(int)(0),(int)(0)))); return;
		case 211:  /* R570_Empty1Commands=0 */ _IW(task,570,(int)(0),(int)(0),(int)(0)); return;
		case 212: /* INLINE_20 */ IPM_START_SB(6,0,0);; return;
		case 213:  /* EmptyAxis2.command=0 */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_command,(double)(0)); return;
		case 214:  /* R580_Empty2Commands=0 */ _IW(task,580,(int)(0),(int)(0),(int)(0)); return;
		case 215:  /* EmptyAxis2.Maxspeed=R571_Speed */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_Maxspeed,(double)(_I(task,571,(int)(0),(int)(0)))); return;
		case 216:  /* EmptyAxis2.Accel=R572_Accel */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_Accel,(double)(_I(task,572,(int)(0),(int)(0)))); return;
		case 217:  /* EmptyAxis2.Decel=R573_Decel */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_Decel,(double)(_I(task,573,(int)(0),(int)(0)))); return;
		case 218:  /* EmptyAxis2.Target=R574_Target */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_Target,(double)(_I(task,574,(int)(0),(int)(0)))); return;
		case 219:  /* EmptyAxis2.command=(R580_Empty2Commands) */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_command,(double)((_I(task,580,(int)(0),(int)(0))))); return;
		case 220:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 221:  /* running8=true */ _IW(task,27,(int)(0),(int)(0),(int)(____true)); return;
		case 222:  /* EmptyAxis2.Maxspeed=R571_Speed */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_Maxspeed,(double)(_I(task,571,(int)(0),(int)(0)))); return;
		case 223:  /* EmptyAxis2.Accel=R572_Accel */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_Accel,(double)(_I(task,572,(int)(0),(int)(0)))); return;
		case 224:  /* EmptyAxis2.Decel=R573_Decel */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_Decel,(double)(_I(task,573,(int)(0),(int)(0)))); return;
		case 225:  /* EmptyAxis2.command=(R580_Empty2Commands) */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_command,(double)((_I(task,580,(int)(0),(int)(0))))); return;
		case 226:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 227:  /* running8=true */ _IW(task,27,(int)(0),(int)(0),(int)(____true)); return;
		case 228:  /* EmptyAxis2.Maxspeed=R571_Speed */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_Maxspeed,(double)(_I(task,571,(int)(0),(int)(0)))); return;
		case 229:  /* EmptyAxis2.Accel=R572_Accel */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_Accel,(double)(_I(task,572,(int)(0),(int)(0)))); return;
		case 230:  /* EmptyAxis2.Decel=R573_Decel */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_Decel,(double)(_I(task,573,(int)(0),(int)(0)))); return;
		case 231:  /* EmptyAxis2.Target=R574_Target */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_Target,(double)(_I(task,574,(int)(0),(int)(0)))); return;
		case 232:  /* EmptyAxis2.OffsetHome=R575_HomeOffset */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_OffsetHome,(double)(_I(task,575,(int)(0),(int)(0)))); return;
		case 233:  /* EmptyAxis2.command=5 */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_command,(double)(5)); return;
		case 234:  /* running8=true */ _IW(task,27,(int)(0),(int)(0),(int)(____true)); return;
		case 235:  /* EmptyAxis2.command=0 */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_command,(double)(0)); return;
		case 236:  /* running8=false */ _IW(task,27,(int)(0),(int)(0),(int)(____false)); return;
		case 237:  /* EmptyAxis2.command=R580_Empty2Commands */ _DW(task,36822,__axisMap[6]-1,__IPMVAR_CTC_EmptyAxis2_command,(double)(_I(task,580,(int)(0),(int)(0)))); return;
		case 238:  /* R580_Empty2Commands=0 */ _IW(task,580,(int)(0),(int)(0),(int)(0)); return;
		case 239: /* INLINE_21 */ IPM_START_SB(7,0,0);; return;
		case 240:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 241:  /* TransferStation.command=0 */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_command,(double)(0)); return;
		case 242:  /* TransferStation.Axisnum=9 */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_Axisnum,(double)(9)); return;
		case 243:  /* R590_TransferStationCommands=0 */ _IW(task,590,(int)(0),(int)(0),(int)(0)); return;
		case 244:  /* TransferStation.Maxspeed=R581_Speed */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_Maxspeed,(double)(_I(task,581,(int)(0),(int)(0)))); return;
		case 245:  /* TransferStation.Accel=R582_Accel */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_Accel,(double)(_I(task,582,(int)(0),(int)(0)))); return;
		case 246:  /* TransferStation.Decel=R583_Decel */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_Decel,(double)(_I(task,583,(int)(0),(int)(0)))); return;
		case 247:  /* TransferStation.Target=R584_Target */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_Target,(double)(_I(task,584,(int)(0),(int)(0)))); return;
		case 248:  /* TransferStation.command=(R590_TransferStationCommands) */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_command,(double)((_I(task,590,(int)(0),(int)(0))))); return;
		case 249:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 250:  /* running9=true */ _IW(task,28,(int)(0),(int)(0),(int)(____true)); return;
		case 251:  /* TransferStation.Maxspeed=R581_Speed */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_Maxspeed,(double)(_I(task,581,(int)(0),(int)(0)))); return;
		case 252:  /* TransferStation.Accel=R582_Accel */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_Accel,(double)(_I(task,582,(int)(0),(int)(0)))); return;
		case 253:  /* TransferStation.Decel=R583_Decel */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_Decel,(double)(_I(task,583,(int)(0),(int)(0)))); return;
		case 254:  /* TransferStation.command=(R590_TransferStationCommands) */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_command,(double)((_I(task,590,(int)(0),(int)(0))))); return;
		case 255:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 256:  /* running9=true */ _IW(task,28,(int)(0),(int)(0),(int)(____true)); return;
		case 257:  /* TransferStation.Maxspeed=R581_Speed */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_Maxspeed,(double)(_I(task,581,(int)(0),(int)(0)))); return;
		case 258:  /* TransferStation.Accel=R582_Accel */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_Accel,(double)(_I(task,582,(int)(0),(int)(0)))); return;
		case 259:  /* TransferStation.Decel=R583_Decel */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_Decel,(double)(_I(task,583,(int)(0),(int)(0)))); return;
		case 260:  /* TransferStation.Target=R584_Target */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_Target,(double)(_I(task,584,(int)(0),(int)(0)))); return;
		case 261:  /* TransferStation.OffsetHome=R585_HomeOffset */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_OffsetHome,(double)(_I(task,585,(int)(0),(int)(0)))); return;
		case 262:  /* TransferStation.command=5 */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_command,(double)(5)); return;
		case 263:  /* running9=true */ _IW(task,28,(int)(0),(int)(0),(int)(____true)); return;
		case 264:  /* TransferStation.command=0 */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_command,(double)(0)); return;
		case 265:  /* running9=false */ _IW(task,28,(int)(0),(int)(0),(int)(____false)); return;
		case 266:  /* TransferStation.command=R590_TransferStationCommands */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_command,(double)(_I(task,590,(int)(0),(int)(0)))); return;
		case 267:  /* R590_TransferStationCommands=0 */ _IW(task,590,(int)(0),(int)(0),(int)(0)); return;
		case 268:  /* TransferStation.command=R590_TransferStationCommands */ _DW(task,36822,__axisMap[7]-1,__IPMVAR_CTC_TransferStation_command,(double)(_I(task,590,(int)(0),(int)(0)))); return;
		case 269:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 270:  /* R590_TransferStationCommands=0 */ _IW(task,590,(int)(0),(int)(0),(int)(0)); return;
		case 271: /* INLINE_22 */ IPM_START_SB(8,0,0);; return;
		case 272:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 273:  /* EmptyAxis3.command=0 */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_command,(double)(0)); return;
		case 274:  /* EmptyAxis3.Axisnum=10 */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_Axisnum,(double)(10)); return;
		case 275:  /* R600_Empty3Commands=0 */ _IW(task,600,(int)(0),(int)(0),(int)(0)); return;
		case 276:  /* EmptyAxis3.Maxspeed=R591_Speed */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_Maxspeed,(double)(_I(task,591,(int)(0),(int)(0)))); return;
		case 277:  /* EmptyAxis3.Accel=R592_Accel */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_Accel,(double)(_I(task,592,(int)(0),(int)(0)))); return;
		case 278:  /* EmptyAxis3.Decel=R593_Decel */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_Decel,(double)(_I(task,593,(int)(0),(int)(0)))); return;
		case 279:  /* EmptyAxis3.Target=R594_Target */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_Target,(double)(_I(task,594,(int)(0),(int)(0)))); return;
		case 280:  /* EmptyAxis3.command=(R600_Empty3Commands) */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_command,(double)((_I(task,600,(int)(0),(int)(0))))); return;
		case 281:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 282:  /* running10=true */ _IW(task,29,(int)(0),(int)(0),(int)(____true)); return;
		case 283:  /* EmptyAxis3.Maxspeed=R591_Speed */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_Maxspeed,(double)(_I(task,591,(int)(0),(int)(0)))); return;
		case 284:  /* EmptyAxis3.Accel=R592_Accel */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_Accel,(double)(_I(task,592,(int)(0),(int)(0)))); return;
		case 285:  /* EmptyAxis3.Decel=R593_Decel */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_Decel,(double)(_I(task,593,(int)(0),(int)(0)))); return;
		case 286:  /* EmptyAxis3.command=(R600_Empty3Commands) */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_command,(double)((_I(task,600,(int)(0),(int)(0))))); return;
		case 287:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 288:  /* running10=true */ _IW(task,29,(int)(0),(int)(0),(int)(____true)); return;
		case 289:  /* EmptyAxis3.Maxspeed=R591_Speed */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_Maxspeed,(double)(_I(task,591,(int)(0),(int)(0)))); return;
		case 290:  /* EmptyAxis3.Accel=R592_Accel */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_Accel,(double)(_I(task,592,(int)(0),(int)(0)))); return;
		case 291:  /* EmptyAxis3.Decel=R593_Decel */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_Decel,(double)(_I(task,593,(int)(0),(int)(0)))); return;
		case 292:  /* EmptyAxis3.Target=R594_Target */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_Target,(double)(_I(task,594,(int)(0),(int)(0)))); return;
		case 293:  /* EmptyAxis3.OffsetHome=R595_HomeOffset */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_OffsetHome,(double)(_I(task,595,(int)(0),(int)(0)))); return;
		case 294:  /* EmptyAxis3.command=5 */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_command,(double)(5)); return;
		case 295:  /* running10=true */ _IW(task,29,(int)(0),(int)(0),(int)(____true)); return;
		case 296:  /* EmptyAxis3.command=0 */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_command,(double)(0)); return;
		case 297:  /* running10=false */ _IW(task,29,(int)(0),(int)(0),(int)(____false)); return;
		case 298:  /* EmptyAxis3.command=R600_Empty3Commands */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_command,(double)(_I(task,600,(int)(0),(int)(0)))); return;
		case 299:  /* R600_Empty3Commands=0 */ _IW(task,600,(int)(0),(int)(0),(int)(0)); return;
		case 300:  /* EmptyAxis3.command=R600_Empty3Commands */ _DW(task,36822,__axisMap[8]-1,__IPMVAR_CTC_EmptyAxis3_command,(double)(_I(task,600,(int)(0),(int)(0)))); return;
		case 301:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 302:  /* R600_Empty3Commands=0 */ _IW(task,600,(int)(0),(int)(0),(int)(0)); return;
		case 303:  /* R9_Dwell=0 */ _IW(task,9,(int)(0),(int)(0),(int)(0)); return;
		case 304:  /* R36711_Ax1Fpos=XAxis.fpos*1000 */ _FW(task,36711,(int)(0),(int)(0),(float)(_D(task,36822,(int)(__axisMap[0]-1),(int)(32))*1000)); return;
		case 305:  /* R36712_Ax1Fpos=YAxis.fpos*1000 */ _FW(task,36712,(int)(0),(int)(0),(float)(_D(task,36822,(int)(__axisMap[1]-1),(int)(32))*1000)); return;
		case 306:  /* R36713_Ax1Fpos=ZAxis.fpos*1000 */ _FW(task,36713,(int)(0),(int)(0),(float)(_D(task,36822,(int)(__axisMap[2]-1),(int)(32))*1000)); return;
		case 307:  /* R36714_Ax1Fpos=ThetaAxis.fpos*1000 */ _FW(task,36714,(int)(0),(int)(0),(float)(_D(task,36822,(int)(__axisMap[3]-1),(int)(32))*1000)); return;
		case 308:  /* R509_X_fpos=R36711_Ax1Fpos */ _IW(task,509,(int)(0),(int)(0),(int)(_F(task,36711,(int)(0),(int)(0)))); return;
		case 309:  /* R519_Y_fpos=R36712_Ax1Fpos */ _IW(task,519,(int)(0),(int)(0),(int)(_F(task,36712,(int)(0),(int)(0)))); return;
		case 310:  /* R529_Z_fpos=R36713_Ax1Fpos */ _IW(task,529,(int)(0),(int)(0),(int)(_F(task,36713,(int)(0),(int)(0)))); return;
		case 311:  /* R539_fpos=R36714_Ax1Fpos */ _IW(task,539,(int)(0),(int)(0),(int)(_F(task,36714,(int)(0),(int)(0)))); return;
		case 312:  /* XAxis.Maxspeed=R501_Speed */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Maxspeed,(double)(_I(task,501,(int)(0),(int)(0)))); return;
		case 313:  /* XAxis.Accel=R502_Accel */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Accel,(double)(_I(task,502,(int)(0),(int)(0)))); return;
		case 314:  /* XAxis.Decel=R503_Decel */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Decel,(double)(_I(task,503,(int)(0),(int)(0)))); return;
		case 315:  /* XAxis.Target=R504_Target */ _DW(task,36822,__axisMap[0]-1,__IPMVAR_CTC_XAxis_Target,(double)(_I(task,504,(int)(0),(int)(0)))); return;
		case 316:  /* YAxis.Maxspeed=R511_Speed */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Maxspeed,(double)(_I(task,511,(int)(0),(int)(0)))); return;
		case 317:  /* YAxis.Accel=R512_Accel */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Accel,(double)(_I(task,512,(int)(0),(int)(0)))); return;
		case 318:  /* YAxis.Decel=R513_Decel */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Decel,(double)(_I(task,513,(int)(0),(int)(0)))); return;
		case 319:  /* YAxis.Target=R514_Target */ _DW(task,36822,__axisMap[1]-1,__IPMVAR_CTC_YAxis_Target,(double)(_I(task,514,(int)(0),(int)(0)))); return;
		case 320:  /* ZAxis.Maxspeed=R521_Speed */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Maxspeed,(double)(_I(task,521,(int)(0),(int)(0)))); return;
		case 321:  /* ZAxis.Accel=R522_Accel */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Accel,(double)(_I(task,522,(int)(0),(int)(0)))); return;
		case 322:  /* ZAxis.Decel=R523_Decel */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Decel,(double)(_I(task,523,(int)(0),(int)(0)))); return;
		case 323:  /* ZAxis.Target=R524_Target */ _DW(task,36822,__axisMap[2]-1,__IPMVAR_CTC_ZAxis_Target,(double)(_I(task,524,(int)(0),(int)(0)))); return;
		case 324:  /* ThetaAxis.Maxspeed=R531_Speed */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Maxspeed,(double)(_I(task,531,(int)(0),(int)(0)))); return;
		case 325:  /* ThetaAxis.Accel=R532_Accel */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Accel,(double)(_I(task,532,(int)(0),(int)(0)))); return;
		case 326:  /* ThetaAxis.Decel=R533_Decel */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Decel,(double)(_I(task,533,(int)(0),(int)(0)))); return;
		case 327:  /* ThetaAxis.Target=R534_Target */ _DW(task,36822,__axisMap[3]-1,__IPMVAR_CTC_ThetaAxis_Target,(double)(_I(task,534,(int)(0),(int)(0)))); return;
		case 328:  /* R9_Dwell=$REGISTERS[13002] */ _IW(task,9,(int)(0),(int)(0),(int)(_I(task,-5,(int)((int)(13002)),(int)(0)))); return;
		case 329:  /* R36101_Temp=ThetaAxis.fpos*1000 */ _FW(task,36101,(int)(0),(int)(0),(float)(_D(task,36822,(int)(__axisMap[3]-1),(int)(32))*1000)); return;
		case 330:  /* R539_fpos=R36101_Temp */ _IW(task,539,(int)(0),(int)(0),(int)(_F(task,36101,(int)(0),(int)(0)))); return;
		case 331:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 332:  /* R36101_Temp=Gripper.fpos*1000 */ _FW(task,36101,(int)(0),(int)(0),(float)(_D(task,36822,(int)(__axisMap[4]-1),(int)(32))*1000)); return;
		case 333:  /* R549_fpos=R36101_Temp */ _IW(task,549,(int)(0),(int)(0),(int)(_F(task,36101,(int)(0),(int)(0)))); return;
		case 334:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 335:  /* R36101_Temp=EmptyAxis1.fpos*1000 */ _FW(task,36101,(int)(0),(int)(0),(float)(_D(task,36822,(int)(__axisMap[5]-1),(int)(32))*1000)); return;
		case 336:  /* R569_fpos=R36101_Temp */ _IW(task,569,(int)(0),(int)(0),(int)(_F(task,36101,(int)(0),(int)(0)))); return;
		case 337:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 338:  /* R36101_Temp=EmptyAxis2.fpos*1000 */ _FW(task,36101,(int)(0),(int)(0),(float)(_D(task,36822,(int)(__axisMap[6]-1),(int)(32))*1000)); return;
		case 339:  /* R579_fpos=R36101_Temp */ _IW(task,579,(int)(0),(int)(0),(int)(_F(task,36101,(int)(0),(int)(0)))); return;
		case 340:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 341:  /* R36101_Temp=TransferStation.fpos*1000 */ _FW(task,36101,(int)(0),(int)(0),(float)(_D(task,36822,(int)(__axisMap[7]-1),(int)(32))*1000)); return;
		case 342:  /* R589_fpos=R36101_Temp */ _IW(task,589,(int)(0),(int)(0),(int)(_F(task,36101,(int)(0),(int)(0)))); return;
		case 343:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
		case 344:  /* R36101_Temp=EmptyAxis3.fpos*1000 */ _FW(task,36101,(int)(0),(int)(0),(float)(_D(task,36822,(int)(__axisMap[8]-1),(int)(32))*1000)); return;
		case 345:  /* R599_fpos=R36101_Temp */ _IW(task,599,(int)(0),(int)(0),(int)(_F(task,36101,(int)(0),(int)(0)))); return;
		case 346:  /* $_DELAYTIMER=0 */ _IW(task,-2,(int)(0),(int)(0),(int)(0)); return;
	}
}

int process_CTABLE(STDVAL value, TASK *task) {
	switch(value) {
		case 0: { /* $_DELAYTIMER<(1000) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(1000));; }
		case 1: { /* R13464_EtherCATStatus!=1 */ return (int)(_I(task,13464,(int)(0),(int)(0))!=1);; }
		case 2: { /* $_DELAYTIMER<(1000) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(1000));; }
		case 3: { /* F1_Trigger==true | R510_XAxisCommands==10 */ return (int)(_I(task,13201,(int)(0),(int)(0))==____true | _I(task,510,(int)(0),(int)(0))==10);; }
		case 4: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 5: { /* $_DELAYTIMER<(20) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(20));; }
		case 6: { /* XAxis.command==0 */ return (int)(_D(task,36822,(int)(__axisMap[0]-1),(int)(__IPMVAR_CTC_XAxis_command))==0);; }
		case 7: { /* R500_RestartProgram==1 */ return (int)(_I(task,500,(int)(0),(int)(0))==1);; }
		case 8: { /* $_DELAYTIMER<(3000) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(3000));; }
		case 9: { /* $_DELAYTIMER<(2000) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2000));; }
		case 10: { /* (R510_XAxisCommands)==1 | (R510_XAxisCommands)==11 */ return (int)((_I(task,510,(int)(0),(int)(0)))==1 | (_I(task,510,(int)(0),(int)(0)))==11);; }
		case 11: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 12: { /* (XAxis.command==1 | XAxis.command==11) & (R510_XAxisCommands==1 | R510_XAxisCommands==11) */ return (int)((_D(task,36822,(int)(__axisMap[0]-1),(int)(__IPMVAR_CTC_XAxis_command))==1 | _D(task,36822,(int)(__axisMap[0]-1),(int)(__IPMVAR_CTC_XAxis_command))==11) & (_I(task,510,(int)(0),(int)(0))==1 | _I(task,510,(int)(0),(int)(0))==11));; }
		case 13: { /* (R510_XAxisCommands)==3 | (R510_XAxisCommands)==4 */ return (int)((_I(task,510,(int)(0),(int)(0)))==3 | (_I(task,510,(int)(0),(int)(0)))==4);; }
		case 14: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 15: { /* XAxis.command==(R510_XAxisCommands) */ return (int)(_D(task,36822,(int)(__axisMap[0]-1),(int)(__IPMVAR_CTC_XAxis_command))==(_I(task,510,(int)(0),(int)(0))));; }
		case 16: { /* (R510_XAxisCommands)==5 */ return (int)((_I(task,510,(int)(0),(int)(0)))==5);; }
		case 17: { /* XAxis.command==5 & (R510_XAxisCommands)==5 */ return (int)(_D(task,36822,(int)(__axisMap[0]-1),(int)(__IPMVAR_CTC_XAxis_command))==5 & (_I(task,510,(int)(0),(int)(0)))==5);; }
		case 18: { /* ((R510_XAxisCommands)==0 & running1==true) */ return (int)(((_I(task,510,(int)(0),(int)(0)))==0 & _I(task,20,(int)(0),(int)(0))==____true));; }
		case 19: { /* ((R510_XAxisCommands)==6 | (R510_XAxisCommands)==7) */ return (int)(((_I(task,510,(int)(0),(int)(0)))==6 | (_I(task,510,(int)(0),(int)(0)))==7));; }
		case 20: { /* (R520_YAxisCommands)==1 | (R520_YAxisCommands)==11 */ return (int)((_I(task,520,(int)(0),(int)(0)))==1 | (_I(task,520,(int)(0),(int)(0)))==11);; }
		case 21: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 22: { /* (YAxis.command==1 | YAxis.command==11) & (R520_YAxisCommands==1 | R520_YAxisCommands==11) */ return (int)((_D(task,36822,(int)(__axisMap[1]-1),(int)(__IPMVAR_CTC_YAxis_command))==1 | _D(task,36822,(int)(__axisMap[1]-1),(int)(__IPMVAR_CTC_YAxis_command))==11) & (_I(task,520,(int)(0),(int)(0))==1 | _I(task,520,(int)(0),(int)(0))==11));; }
		case 23: { /* (R520_YAxisCommands)==3 | (R520_YAxisCommands)==4 */ return (int)((_I(task,520,(int)(0),(int)(0)))==3 | (_I(task,520,(int)(0),(int)(0)))==4);; }
		case 24: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 25: { /* YAxis.command==(R520_YAxisCommands) */ return (int)(_D(task,36822,(int)(__axisMap[1]-1),(int)(__IPMVAR_CTC_YAxis_command))==(_I(task,520,(int)(0),(int)(0))));; }
		case 26: { /* (R520_YAxisCommands)==5 */ return (int)((_I(task,520,(int)(0),(int)(0)))==5);; }
		case 27: { /* YAxis.command==5 & (R520_YAxisCommands)==5 */ return (int)(_D(task,36822,(int)(__axisMap[1]-1),(int)(__IPMVAR_CTC_YAxis_command))==5 & (_I(task,520,(int)(0),(int)(0)))==5);; }
		case 28: { /* ((R520_YAxisCommands)==0 & running2==true) */ return (int)(((_I(task,520,(int)(0),(int)(0)))==0 & _I(task,21,(int)(0),(int)(0))==____true));; }
		case 29: { /* ((R520_YAxisCommands)==6 | (R520_YAxisCommands)==7) */ return (int)(((_I(task,520,(int)(0),(int)(0)))==6 | (_I(task,520,(int)(0),(int)(0)))==7));; }
		case 30: { /* (R530_ZAxisCommands)==1 | (R530_ZAxisCommands)==11 */ return (int)((_I(task,530,(int)(0),(int)(0)))==1 | (_I(task,530,(int)(0),(int)(0)))==11);; }
		case 31: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 32: { /* (ZAxis.command==1 | ZAxis.command==11) & (R530_ZAxisCommands==1 | R530_ZAxisCommands==11) */ return (int)((_D(task,36822,(int)(__axisMap[2]-1),(int)(__IPMVAR_CTC_ZAxis_command))==1 | _D(task,36822,(int)(__axisMap[2]-1),(int)(__IPMVAR_CTC_ZAxis_command))==11) & (_I(task,530,(int)(0),(int)(0))==1 | _I(task,530,(int)(0),(int)(0))==11));; }
		case 33: { /* (R530_ZAxisCommands)==3 | (R530_ZAxisCommands)==4 */ return (int)((_I(task,530,(int)(0),(int)(0)))==3 | (_I(task,530,(int)(0),(int)(0)))==4);; }
		case 34: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 35: { /* ZAxis.command==(R530_ZAxisCommands) */ return (int)(_D(task,36822,(int)(__axisMap[2]-1),(int)(__IPMVAR_CTC_ZAxis_command))==(_I(task,530,(int)(0),(int)(0))));; }
		case 36: { /* (R530_ZAxisCommands)==5 */ return (int)((_I(task,530,(int)(0),(int)(0)))==5);; }
		case 37: { /* ZAxis.command==5 & (R530_ZAxisCommands)==5 */ return (int)(_D(task,36822,(int)(__axisMap[2]-1),(int)(__IPMVAR_CTC_ZAxis_command))==5 & (_I(task,530,(int)(0),(int)(0)))==5);; }
		case 38: { /* ((R530_ZAxisCommands)==0 & running3==true) */ return (int)(((_I(task,530,(int)(0),(int)(0)))==0 & _I(task,22,(int)(0),(int)(0))==____true));; }
		case 39: { /* ((R530_ZAxisCommands)==6 | (R530_ZAxisCommands)==7) */ return (int)(((_I(task,530,(int)(0),(int)(0)))==6 | (_I(task,530,(int)(0),(int)(0)))==7));; }
		case 40: { /* (R540_ThetaCommands)==1 | (R540_ThetaCommands)==11 */ return (int)((_I(task,540,(int)(0),(int)(0)))==1 | (_I(task,540,(int)(0),(int)(0)))==11);; }
		case 41: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 42: { /* (ThetaAxis.command==1 | ThetaAxis.command==11) & (R540_ThetaCommands==1 | R540_ThetaCommands==11) */ return (int)((_D(task,36822,(int)(__axisMap[3]-1),(int)(__IPMVAR_CTC_ThetaAxis_command))==1 | _D(task,36822,(int)(__axisMap[3]-1),(int)(__IPMVAR_CTC_ThetaAxis_command))==11) & (_I(task,540,(int)(0),(int)(0))==1 | _I(task,540,(int)(0),(int)(0))==11));; }
		case 43: { /* (R540_ThetaCommands)==3 | (R540_ThetaCommands)==4 */ return (int)((_I(task,540,(int)(0),(int)(0)))==3 | (_I(task,540,(int)(0),(int)(0)))==4);; }
		case 44: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 45: { /* ThetaAxis.command==(R540_ThetaCommands) */ return (int)(_D(task,36822,(int)(__axisMap[3]-1),(int)(__IPMVAR_CTC_ThetaAxis_command))==(_I(task,540,(int)(0),(int)(0))));; }
		case 46: { /* (R540_ThetaCommands)==5 */ return (int)((_I(task,540,(int)(0),(int)(0)))==5);; }
		case 47: { /* ThetaAxis.command==5 & (R540_ThetaCommands)==5 */ return (int)(_D(task,36822,(int)(__axisMap[3]-1),(int)(__IPMVAR_CTC_ThetaAxis_command))==5 & (_I(task,540,(int)(0),(int)(0)))==5);; }
		case 48: { /* ((R540_ThetaCommands)==0 & running4==true) */ return (int)(((_I(task,540,(int)(0),(int)(0)))==0 & _I(task,23,(int)(0),(int)(0))==____true));; }
		case 49: { /* ((R540_ThetaCommands)==6 | (R540_ThetaCommands)==7) */ return (int)(((_I(task,540,(int)(0),(int)(0)))==6 | (_I(task,540,(int)(0),(int)(0)))==7));; }
		case 50: { /* (R550_GripperCommands)==1 */ return (int)((_I(task,550,(int)(0),(int)(0)))==1);; }
		case 51: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 52: { /* (Gripper.command==1) & (R550_GripperCommands==1) */ return (int)((_D(task,36822,(int)(__axisMap[4]-1),(int)(__IPMVAR_CTC_Gripper_command))==1) & (_I(task,550,(int)(0),(int)(0))==1));; }
		case 53: { /* (R550_GripperCommands)==3 | (R550_GripperCommands)==4 */ return (int)((_I(task,550,(int)(0),(int)(0)))==3 | (_I(task,550,(int)(0),(int)(0)))==4);; }
		case 54: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 55: { /* Gripper.command==(R550_GripperCommands) */ return (int)(_D(task,36822,(int)(__axisMap[4]-1),(int)(__IPMVAR_CTC_Gripper_command))==(_I(task,550,(int)(0),(int)(0))));; }
		case 56: { /* (R550_GripperCommands)==5 */ return (int)((_I(task,550,(int)(0),(int)(0)))==5);; }
		case 57: { /* Gripper.command==5 & (R550_GripperCommands)==5 */ return (int)(_D(task,36822,(int)(__axisMap[4]-1),(int)(__IPMVAR_CTC_Gripper_command))==5 & (_I(task,550,(int)(0),(int)(0)))==5);; }
		case 58: { /* ((R550_GripperCommands)==0 & running5==true) */ return (int)(((_I(task,550,(int)(0),(int)(0)))==0 & _I(task,24,(int)(0),(int)(0))==____true));; }
		case 59: { /* ((R550_GripperCommands)==6 | (R550_GripperCommands)==7) */ return (int)(((_I(task,550,(int)(0),(int)(0)))==6 | (_I(task,550,(int)(0),(int)(0)))==7));; }
		case 60: { /* (R550_GripperCommands)==9 */ return (int)((_I(task,550,(int)(0),(int)(0)))==9);; }
		case 61: { /* (R570_Empty1Commands)==1 */ return (int)((_I(task,570,(int)(0),(int)(0)))==1);; }
		case 62: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 63: { /* (EmptyAxis1.command==1) & (R570_Empty1Commands==1) */ return (int)((_D(task,36822,(int)(__axisMap[5]-1),(int)(__IPMVAR_CTC_EmptyAxis1_command))==1) & (_I(task,570,(int)(0),(int)(0))==1));; }
		case 64: { /* (R570_Empty1Commands)==3 | (R570_Empty1Commands)==4 */ return (int)((_I(task,570,(int)(0),(int)(0)))==3 | (_I(task,570,(int)(0),(int)(0)))==4);; }
		case 65: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 66: { /* EmptyAxis1.command==(R570_Empty1Commands) */ return (int)(_D(task,36822,(int)(__axisMap[5]-1),(int)(__IPMVAR_CTC_EmptyAxis1_command))==(_I(task,570,(int)(0),(int)(0))));; }
		case 67: { /* (R570_Empty1Commands)==5 */ return (int)((_I(task,570,(int)(0),(int)(0)))==5);; }
		case 68: { /* EmptyAxis1.command==5 & (R570_Empty1Commands)==5 */ return (int)(_D(task,36822,(int)(__axisMap[5]-1),(int)(__IPMVAR_CTC_EmptyAxis1_command))==5 & (_I(task,570,(int)(0),(int)(0)))==5);; }
		case 69: { /* ((R570_Empty1Commands)==0 & running7==true) */ return (int)(((_I(task,570,(int)(0),(int)(0)))==0 & _I(task,26,(int)(0),(int)(0))==____true));; }
		case 70: { /* ((R570_Empty1Commands)==6 | (R570_Empty1Commands)==7) */ return (int)(((_I(task,570,(int)(0),(int)(0)))==6 | (_I(task,570,(int)(0),(int)(0)))==7));; }
		case 71: { /* (R580_Empty2Commands)==1 */ return (int)((_I(task,580,(int)(0),(int)(0)))==1);; }
		case 72: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 73: { /* (EmptyAxis2.command==1) & (R580_Empty2Commands==1) */ return (int)((_D(task,36822,(int)(__axisMap[6]-1),(int)(__IPMVAR_CTC_EmptyAxis2_command))==1) & (_I(task,580,(int)(0),(int)(0))==1));; }
		case 74: { /* (R580_Empty2Commands)==3 | (R580_Empty2Commands)==4 */ return (int)((_I(task,580,(int)(0),(int)(0)))==3 | (_I(task,580,(int)(0),(int)(0)))==4);; }
		case 75: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 76: { /* EmptyAxis2.command==(R580_Empty2Commands) */ return (int)(_D(task,36822,(int)(__axisMap[6]-1),(int)(__IPMVAR_CTC_EmptyAxis2_command))==(_I(task,580,(int)(0),(int)(0))));; }
		case 77: { /* (R580_Empty2Commands)==5 */ return (int)((_I(task,580,(int)(0),(int)(0)))==5);; }
		case 78: { /* EmptyAxis2.command==5 & (R580_Empty2Commands)==5 */ return (int)(_D(task,36822,(int)(__axisMap[6]-1),(int)(__IPMVAR_CTC_EmptyAxis2_command))==5 & (_I(task,580,(int)(0),(int)(0)))==5);; }
		case 79: { /* ((R580_Empty2Commands)==0 & running8==true) */ return (int)(((_I(task,580,(int)(0),(int)(0)))==0 & _I(task,27,(int)(0),(int)(0))==____true));; }
		case 80: { /* ((R580_Empty2Commands)==6 | (R580_Empty2Commands)==7) */ return (int)(((_I(task,580,(int)(0),(int)(0)))==6 | (_I(task,580,(int)(0),(int)(0)))==7));; }
		case 81: { /* $_DELAYTIMER<(100) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(100));; }
		case 82: { /* (R590_TransferStationCommands)==1 */ return (int)((_I(task,590,(int)(0),(int)(0)))==1);; }
		case 83: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 84: { /* (TransferStation.command==1) & (R590_TransferStationCommands==1) */ return (int)((_D(task,36822,(int)(__axisMap[7]-1),(int)(__IPMVAR_CTC_TransferStation_command))==1) & (_I(task,590,(int)(0),(int)(0))==1));; }
		case 85: { /* (R590_TransferStationCommands)==3 | (R590_TransferStationCommands)==4 */ return (int)((_I(task,590,(int)(0),(int)(0)))==3 | (_I(task,590,(int)(0),(int)(0)))==4);; }
		case 86: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 87: { /* TransferStation.command==(R590_TransferStationCommands) */ return (int)(_D(task,36822,(int)(__axisMap[7]-1),(int)(__IPMVAR_CTC_TransferStation_command))==(_I(task,590,(int)(0),(int)(0))));; }
		case 88: { /* (R590_TransferStationCommands)==5 */ return (int)((_I(task,590,(int)(0),(int)(0)))==5);; }
		case 89: { /* TransferStation.command==5 & (R590_TransferStationCommands)==5 */ return (int)(_D(task,36822,(int)(__axisMap[7]-1),(int)(__IPMVAR_CTC_TransferStation_command))==5 & (_I(task,590,(int)(0),(int)(0)))==5);; }
		case 90: { /* ((R590_TransferStationCommands)==0 & running9==true) */ return (int)(((_I(task,590,(int)(0),(int)(0)))==0 & _I(task,28,(int)(0),(int)(0))==____true));; }
		case 91: { /* ((R590_TransferStationCommands)==6 | (R590_TransferStationCommands)==7) */ return (int)(((_I(task,590,(int)(0),(int)(0)))==6 | (_I(task,590,(int)(0),(int)(0)))==7));; }
		case 92: { /* (R590_TransferStationCommands)==8 */ return (int)((_I(task,590,(int)(0),(int)(0)))==8);; }
		case 93: { /* $_DELAYTIMER<(10) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(10));; }
		case 94: { /* $_DELAYTIMER<(100) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(100));; }
		case 95: { /* (R600_Empty3Commands)==1 */ return (int)((_I(task,600,(int)(0),(int)(0)))==1);; }
		case 96: { /* $_DELAYTIMER<(20) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(20));; }
		case 97: { /* (EmptyAxis3.command==1) & (R600_Empty3Commands==1) */ return (int)((_D(task,36822,(int)(__axisMap[8]-1),(int)(__IPMVAR_CTC_EmptyAxis3_command))==1) & (_I(task,600,(int)(0),(int)(0))==1));; }
		case 98: { /* (R600_Empty3Commands)==3 | (R600_Empty3Commands)==4 */ return (int)((_I(task,600,(int)(0),(int)(0)))==3 | (_I(task,600,(int)(0),(int)(0)))==4);; }
		case 99: { /* $_DELAYTIMER<(20) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(20));; }
		case 100: { /* EmptyAxis3.command==(R600_Empty3Commands) */ return (int)(_D(task,36822,(int)(__axisMap[8]-1),(int)(__IPMVAR_CTC_EmptyAxis3_command))==(_I(task,600,(int)(0),(int)(0))));; }
		case 101: { /* (R600_Empty3Commands)==5 */ return (int)((_I(task,600,(int)(0),(int)(0)))==5);; }
		case 102: { /* EmptyAxis3.command==5 & (R600_Empty3Commands)==5 */ return (int)(_D(task,36822,(int)(__axisMap[8]-1),(int)(__IPMVAR_CTC_EmptyAxis3_command))==5 & (_I(task,600,(int)(0),(int)(0)))==5);; }
		case 103: { /* ((R600_Empty3Commands)==0 & running10==true) */ return (int)(((_I(task,600,(int)(0),(int)(0)))==0 & _I(task,29,(int)(0),(int)(0))==____true));; }
		case 104: { /* ((R600_Empty3Commands)==6 | (R600_Empty3Commands)==7) */ return (int)(((_I(task,600,(int)(0),(int)(0)))==6 | (_I(task,600,(int)(0),(int)(0)))==7));; }
		case 105: { /* (R600_Empty3Commands)==8 */ return (int)((_I(task,600,(int)(0),(int)(0)))==8);; }
		case 106: { /* $_DELAYTIMER<(10) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(10));; }
		case 107: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 108: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 109: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 110: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 111: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
		case 112: { /* $_DELAYTIMER<(2) */ return (int)(_I(task,-2,(int)(0),(int)(0))<(2));; }
	}
	return 0;
}

void process_INIT(TASK *task) {
	{ __initQS4(256,256,50); }
}

// Main program task loop
void taskloop(unsigned long parameter)
{
TASK *task;
int start_of_step_timeout_flag=0;
extern OPTIMIZED_LINE_ENTRY currentLine[];
TASK_THREAD *thrd;
int stepUnlocked, R36991;
#ifndef ABSTRACT_INTIME
static void *steptable[] = {
	&&X__START__X, &&X__DONE__X, &&kickoff, &&kickoff_Init1, &&__0000, &&__0001, &&__0002, &&__0003, &&__0004, &&__0005, 
	&&__0006, &&StageControl, &&StageControl_Mode_Select, &&StageControl_StageAuto, &&__0008, &&__0007, &&__0009, &&__0010, &&__0011, &&__0013, &&__0015, 
	&&__0016, &&__0012, &&__0014, &&kickoff_Stops, &&__0017, &&__0018, &&__0020, &&__0021, &&__0022, &&__0023, &&__0024, 
	&&__0025, &&__0019, &&AxisX_Init, &&AxisX_AxisXControl, &&__0026, &&__0027, &&__0029, &&__0030, &&__0031, &&__0032, &&__0028, 
	&&__0034, &&__0035, &&__0037, &&__0038, &&__0039, &&__0040, &&__0036, &&__0042, &&__0043, &&__0045, &&__0046, 
	&&__0044, &&__0048, &&__0049, &&__0050, &&__0051, &&__0052, &&__0053, &&AxisX, &&AxisY_Init, &&AxisY_AxisYControl, &&__0054, 
	&&__0055, &&__0057, &&__0058, &&__0059, &&__0060, &&__0056, &&__0062, &&__0063, &&__0065, &&__0066, &&__0067, 
	&&__0068, &&__0064, &&__0070, &&__0071, &&__0073, &&__0074, &&__0072, &&__0076, &&__0077, &&__0078, &&__0079, 
	&&__0080, &&__0081, &&AxisY, &&AxisZ_Init, &&AxisZ_AxisZControl, &&__0082, &&__0083, &&__0085, &&__0086, &&__0087, &&__0088, 
	&&__0084, &&__0090, &&__0091, &&__0093, &&__0094, &&__0095, &&__0096, &&__0092, &&__0098, &&__0099, &&__0101, 
	&&__0102, &&__0100, &&__0104, &&__0105, &&__0106, &&__0107, &&__0108, &&__0109, &&AxisZ, &&AxisTheta, &&AxisTheta_Init, 
	&&AxisTheta_ThetaControl, &&__0110, &&__0111, &&__0113, &&__0114, &&__0115, &&__0116, &&__0112, &&__0118, &&__0119, &&__0121, 
	&&__0122, &&__0123, &&__0124, &&__0120, &&__0126, &&__0127, &&__0129, &&__0130, &&__0128, &&__0132, &&__0133, 
	&&__0134, &&__0135, &&__0136, &&__0137, &&AxisGripper, &&AxisGripper_Init, &&AxisGripper_GripperControl, &&__0138, &&__0139, &&__0141, &&__0142, 
	&&__0143, &&__0144, &&__0140, &&__0146, &&__0147, &&__0149, &&__0150, &&__0151, &&__0152, &&__0148, &&__0154, 
	&&__0155, &&__0157, &&__0158, &&__0156, &&__0160, &&__0161, &&__0162, &&__0163, &&__0164, &&__0165, &&__0166, 
	&&__0167, &&__0168, &&AxisEmpty1, &&AxisEmpty1_Init, &&AxisEmpty1_Empty1Control, &&__0169, &&__0170, &&__0172, &&__0173, &&__0174, &&__0175, 
	&&__0171, &&__0177, &&__0178, &&__0180, &&__0181, &&__0182, &&__0183, &&__0179, &&__0185, &&__0186, &&__0188, 
	&&__0189, &&__0187, &&__0191, &&__0192, &&__0193, &&__0194, &&__0195, &&__0196, &&AxisEmpty2, &&AxisEmpty2_Init, &&AxisEmpty2_Empty2Control, 
	&&__0197, &&__0198, &&__0200, &&__0201, &&__0202, &&__0203, &&__0199, &&__0205, &&__0206, &&__0208, &&__0209, 
	&&__0210, &&__0211, &&__0207, &&__0213, &&__0214, &&__0216, &&__0217, &&__0215, &&__0219, &&__0220, &&__0221, 
	&&__0222, &&__0223, &&__0224, &&AxisTransferStation, &&AxisTransferStation_Init, &&__0225, &&__0226, &&AxisTransferStation_CableElevfControl, &&__0227, &&__0228, &&__0230, 
	&&__0231, &&__0232, &&__0233, &&__0229, &&__0235, &&__0236, &&__0238, &&__0239, &&__0240, &&__0241, &&__0237, 
	&&__0243, &&__0244, &&__0246, &&__0247, &&__0245, &&__0249, &&__0250, &&__0251, &&__0252, &&__0253, &&__0254, 
	&&__0255, &&__0256, &&__0258, &&__0259, &&__0257, &&AxisEmpty3, &&AxisEmpty3_Init, &&__0260, &&__0261, &&AxisEmpty3_Empty3Control, &&__0262, 
	&&__0263, &&__0265, &&__0266, &&__0267, &&__0268, &&__0264, &&__0270, &&__0271, &&__0273, &&__0274, &&__0275, 
	&&__0276, &&__0272, &&__0278, &&__0279, &&__0281, &&__0282, &&__0280, &&__0284, &&__0285, &&__0286, &&__0287, 
	&&__0288, &&__0289, &&__0290, &&__0291, &&__0293, &&__0294, &&__0292, &&FastUpdates, &&FastUpdates_Update, &&Updates, &&Updates_Update, 
	&&__0295, &&__0296, &&__0297, &&__0298, &&__0299, &&__0300, &&__0301, &&__0302, &&__0303, &&__0304, &&__0305, 
	&&__0306 };
#endif

		// set not locked and branch table init
		stepUnlocked = 1;
		start_of_step_timeout_flag = 0;
		R36991 = 0;
		// get thread block pointer
		thrd = &TASK_THREADS[parameter];
		task = thrd->task;
		// Branch to start of requested step
#if 0
		while(TASK_THREADS[parameter].initialized == 0)
		{
			taskSetBranch(task,-1); // Yield
		};
#endif
		if (Q4T(task) == NULL) {
			/* ERROR */
			_IW(NULL, 202, 0, 0, 8888);
			stepDone(task);
			goto ___exitThread;
		}

		if (task->state != TASK_DONE) {
			if (task->state == TASK_START) { task->state = TASK_RUNSTEP; } 
			task->step_num = 1;
		};
		// MODULE(++++++):LINE 1->*** STARTING ****
		Q4T(task)->currentStep = (void *)&currentLine[529];
#ifdef ABSTRACT_INTIME
		switch(thrd->stepStart - 1)
		{
		case 0:
			goto X__START__X;
		case 1:
			goto X__DONE__X;
		case 2:
			goto kickoff;
		case 3:
			goto kickoff_Init1;
		case 4:
			goto __0000;
		case 5:
			goto __0001;
		case 6:
			goto __0002;
		case 7:
			goto __0003;
		case 8:
			goto __0004;
		case 9:
			goto __0005;
		case 10:
			goto __0006;
		case 11:
			goto StageControl;
		case 12:
			goto StageControl_Mode_Select;
		case 13:
			goto StageControl_StageAuto;
		case 14:
			goto __0008;
		case 15:
			goto __0007;
		case 16:
			goto __0009;
		case 17:
			goto __0010;
		case 18:
			goto __0011;
		case 19:
			goto __0013;
		case 20:
			goto __0015;
		case 21:
			goto __0016;
		case 22:
			goto __0012;
		case 23:
			goto __0014;
		case 24:
			goto kickoff_Stops;
		case 25:
			goto __0017;
		case 26:
			goto __0018;
		case 27:
			goto __0020;
		case 28:
			goto __0021;
		case 29:
			goto __0022;
		case 30:
			goto __0023;
		case 31:
			goto __0024;
		case 32:
			goto __0025;
		case 33:
			goto __0019;
		case 34:
			goto AxisX_Init;
		case 35:
			goto AxisX_AxisXControl;
		case 36:
			goto __0026;
		case 37:
			goto __0027;
		case 38:
			goto __0029;
		case 39:
			goto __0030;
		case 40:
			goto __0031;
		case 41:
			goto __0032;
		case 42:
			goto __0028;
		case 43:
			goto __0034;
		case 44:
			goto __0035;
		case 45:
			goto __0037;
		case 46:
			goto __0038;
		case 47:
			goto __0039;
		case 48:
			goto __0040;
		case 49:
			goto __0036;
		case 50:
			goto __0042;
		case 51:
			goto __0043;
		case 52:
			goto __0045;
		case 53:
			goto __0046;
		case 54:
			goto __0044;
		case 55:
			goto __0048;
		case 56:
			goto __0049;
		case 57:
			goto __0050;
		case 58:
			goto __0051;
		case 59:
			goto __0052;
		case 60:
			goto __0053;
		case 61:
			goto AxisX;
		case 62:
			goto AxisY_Init;
		case 63:
			goto AxisY_AxisYControl;
		case 64:
			goto __0054;
		case 65:
			goto __0055;
		case 66:
			goto __0057;
		case 67:
			goto __0058;
		case 68:
			goto __0059;
		case 69:
			goto __0060;
		case 70:
			goto __0056;
		case 71:
			goto __0062;
		case 72:
			goto __0063;
		case 73:
			goto __0065;
		case 74:
			goto __0066;
		case 75:
			goto __0067;
		case 76:
			goto __0068;
		case 77:
			goto __0064;
		case 78:
			goto __0070;
		case 79:
			goto __0071;
		case 80:
			goto __0073;
		case 81:
			goto __0074;
		case 82:
			goto __0072;
		case 83:
			goto __0076;
		case 84:
			goto __0077;
		case 85:
			goto __0078;
		case 86:
			goto __0079;
		case 87:
			goto __0080;
		case 88:
			goto __0081;
		case 89:
			goto AxisY;
		case 90:
			goto AxisZ_Init;
		case 91:
			goto AxisZ_AxisZControl;
		case 92:
			goto __0082;
		case 93:
			goto __0083;
		case 94:
			goto __0085;
		case 95:
			goto __0086;
		case 96:
			goto __0087;
		case 97:
			goto __0088;
		case 98:
			goto __0084;
		case 99:
			goto __0090;
		case 100:
			goto __0091;
		case 101:
			goto __0093;
		case 102:
			goto __0094;
		case 103:
			goto __0095;
		case 104:
			goto __0096;
		case 105:
			goto __0092;
		case 106:
			goto __0098;
		case 107:
			goto __0099;
		case 108:
			goto __0101;
		case 109:
			goto __0102;
		case 110:
			goto __0100;
		case 111:
			goto __0104;
		case 112:
			goto __0105;
		case 113:
			goto __0106;
		case 114:
			goto __0107;
		case 115:
			goto __0108;
		case 116:
			goto __0109;
		case 117:
			goto AxisZ;
		case 118:
			goto AxisTheta;
		case 119:
			goto AxisTheta_Init;
		case 120:
			goto AxisTheta_ThetaControl;
		case 121:
			goto __0110;
		case 122:
			goto __0111;
		case 123:
			goto __0113;
		case 124:
			goto __0114;
		case 125:
			goto __0115;
		case 126:
			goto __0116;
		case 127:
			goto __0112;
		case 128:
			goto __0118;
		case 129:
			goto __0119;
		case 130:
			goto __0121;
		case 131:
			goto __0122;
		case 132:
			goto __0123;
		case 133:
			goto __0124;
		case 134:
			goto __0120;
		case 135:
			goto __0126;
		case 136:
			goto __0127;
		case 137:
			goto __0129;
		case 138:
			goto __0130;
		case 139:
			goto __0128;
		case 140:
			goto __0132;
		case 141:
			goto __0133;
		case 142:
			goto __0134;
		case 143:
			goto __0135;
		case 144:
			goto __0136;
		case 145:
			goto __0137;
		case 146:
			goto AxisGripper;
		case 147:
			goto AxisGripper_Init;
		case 148:
			goto AxisGripper_GripperControl;
		case 149:
			goto __0138;
		case 150:
			goto __0139;
		case 151:
			goto __0141;
		case 152:
			goto __0142;
		case 153:
			goto __0143;
		case 154:
			goto __0144;
		case 155:
			goto __0140;
		case 156:
			goto __0146;
		case 157:
			goto __0147;
		case 158:
			goto __0149;
		case 159:
			goto __0150;
		case 160:
			goto __0151;
		case 161:
			goto __0152;
		case 162:
			goto __0148;
		case 163:
			goto __0154;
		case 164:
			goto __0155;
		case 165:
			goto __0157;
		case 166:
			goto __0158;
		case 167:
			goto __0156;
		case 168:
			goto __0160;
		case 169:
			goto __0161;
		case 170:
			goto __0162;
		case 171:
			goto __0163;
		case 172:
			goto __0164;
		case 173:
			goto __0165;
		case 174:
			goto __0166;
		case 175:
			goto __0167;
		case 176:
			goto __0168;
		case 177:
			goto AxisEmpty1;
		case 178:
			goto AxisEmpty1_Init;
		case 179:
			goto AxisEmpty1_Empty1Control;
		case 180:
			goto __0169;
		case 181:
			goto __0170;
		case 182:
			goto __0172;
		case 183:
			goto __0173;
		case 184:
			goto __0174;
		case 185:
			goto __0175;
		case 186:
			goto __0171;
		case 187:
			goto __0177;
		case 188:
			goto __0178;
		case 189:
			goto __0180;
		case 190:
			goto __0181;
		case 191:
			goto __0182;
		case 192:
			goto __0183;
		case 193:
			goto __0179;
		case 194:
			goto __0185;
		case 195:
			goto __0186;
		case 196:
			goto __0188;
		case 197:
			goto __0189;
		case 198:
			goto __0187;
		case 199:
			goto __0191;
		case 200:
			goto __0192;
		case 201:
			goto __0193;
		case 202:
			goto __0194;
		case 203:
			goto __0195;
		case 204:
			goto __0196;
		case 205:
			goto AxisEmpty2;
		case 206:
			goto AxisEmpty2_Init;
		case 207:
			goto AxisEmpty2_Empty2Control;
		case 208:
			goto __0197;
		case 209:
			goto __0198;
		case 210:
			goto __0200;
		case 211:
			goto __0201;
		case 212:
			goto __0202;
		case 213:
			goto __0203;
		case 214:
			goto __0199;
		case 215:
			goto __0205;
		case 216:
			goto __0206;
		case 217:
			goto __0208;
		case 218:
			goto __0209;
		case 219:
			goto __0210;
		case 220:
			goto __0211;
		case 221:
			goto __0207;
		case 222:
			goto __0213;
		case 223:
			goto __0214;
		case 224:
			goto __0216;
		case 225:
			goto __0217;
		case 226:
			goto __0215;
		case 227:
			goto __0219;
		case 228:
			goto __0220;
		case 229:
			goto __0221;
		case 230:
			goto __0222;
		case 231:
			goto __0223;
		case 232:
			goto __0224;
		case 233:
			goto AxisTransferStation;
		case 234:
			goto AxisTransferStation_Init;
		case 235:
			goto __0225;
		case 236:
			goto __0226;
		case 237:
			goto AxisTransferStation_CableElevfControl;
		case 238:
			goto __0227;
		case 239:
			goto __0228;
		case 240:
			goto __0230;
		case 241:
			goto __0231;
		case 242:
			goto __0232;
		case 243:
			goto __0233;
		case 244:
			goto __0229;
		case 245:
			goto __0235;
		case 246:
			goto __0236;
		case 247:
			goto __0238;
		case 248:
			goto __0239;
		case 249:
			goto __0240;
		case 250:
			goto __0241;
		case 251:
			goto __0237;
		case 252:
			goto __0243;
		case 253:
			goto __0244;
		case 254:
			goto __0246;
		case 255:
			goto __0247;
		case 256:
			goto __0245;
		case 257:
			goto __0249;
		case 258:
			goto __0250;
		case 259:
			goto __0251;
		case 260:
			goto __0252;
		case 261:
			goto __0253;
		case 262:
			goto __0254;
		case 263:
			goto __0255;
		case 264:
			goto __0256;
		case 265:
			goto __0258;
		case 266:
			goto __0259;
		case 267:
			goto __0257;
		case 268:
			goto AxisEmpty3;
		case 269:
			goto AxisEmpty3_Init;
		case 270:
			goto __0260;
		case 271:
			goto __0261;
		case 272:
			goto AxisEmpty3_Empty3Control;
		case 273:
			goto __0262;
		case 274:
			goto __0263;
		case 275:
			goto __0265;
		case 276:
			goto __0266;
		case 277:
			goto __0267;
		case 278:
			goto __0268;
		case 279:
			goto __0264;
		case 280:
			goto __0270;
		case 281:
			goto __0271;
		case 282:
			goto __0273;
		case 283:
			goto __0274;
		case 284:
			goto __0275;
		case 285:
			goto __0276;
		case 286:
			goto __0272;
		case 287:
			goto __0278;
		case 288:
			goto __0279;
		case 289:
			goto __0281;
		case 290:
			goto __0282;
		case 291:
			goto __0280;
		case 292:
			goto __0284;
		case 293:
			goto __0285;
		case 294:
			goto __0286;
		case 295:
			goto __0287;
		case 296:
			goto __0288;
		case 297:
			goto __0289;
		case 298:
			goto __0290;
		case 299:
			goto __0291;
		case 300:
			goto __0293;
		case 301:
			goto __0294;
		case 302:
			goto __0292;
		case 303:
			goto FastUpdates;
		case 304:
			goto FastUpdates_Update;
		case 305:
			goto Updates;
		case 306:
			goto Updates_Update;
		case 307:
			goto __0295;
		case 308:
			goto __0296;
		case 309:
			goto __0297;
		case 310:
			goto __0298;
		case 311:
			goto __0299;
		case 312:
			goto __0300;
		case 313:
			goto __0301;
		case 314:
			goto __0302;
		case 315:
			goto __0303;
		case 316:
			goto __0304;
		case 317:
			goto __0305;
		case 318:
			goto __0306;
		default:
			goto ___exitThread;
		}
#else
		goto *steptable[thrd->stepStart-1];
#endif
// [0001]
X__START__X:
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		goto kickoff;
		// GOTO X__DONE__X
		goto X__DONE__X;
// [0002]
X__DONE__X:
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// DONE
		stepDone(task);
// [0003]
kickoff:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
kickoff_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE -1 TO REG#36990
		process_ATABLE(-1, task);
		// MODULE(kickoff):LINE 2->goto Init1
		Q4T(task)->currentStep = (void *)&currentLine[0]; lineYield(task,0);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO kickoff_Init1
		goto kickoff_Init1;
// [0004]
kickoff_Init1:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
kickoff_Init1_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Init1):LINE 4->R20099_ModBusTCPWordSwap = 1
		Q4T(task)->currentStep = (void *)&currentLine[1]; lineYield(task,1);
		// STORE 0 TO REG#36990
		process_ATABLE(0, task);
		// MODULE(kickoff):STEP(Init1):LINE 6->$REGISTERS[12305] = 2
		Q4T(task)->currentStep = (void *)&currentLine[2]; lineYield(task,2);
		// STORE 1 TO REG#36990
		process_ATABLE(1, task);
		// MODULE(kickoff):STEP(Init1):LINE 9->delay = 1000
		Q4T(task)->currentStep = (void *)&currentLine[3];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 2 TO REG#36990
		process_ATABLE(2, task); start_of_step_timeout_flag = 0;
		// GOTO __0000
		goto __0000;
// [0005]
__0000:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Init1):LINE 9->delay = 1000
		Q4T(task)->currentStep = (void *)&currentLine[4]; lineYield(task,4);
		// STORE 0 TO REG#36991
		R36991 = 0;
		// IF REG#36991=0 GOTO __0001
		if (process_CTABLE(R36991, task) == 0) goto __0001;
		// GOTO __0000
		goto __0000;
// [0006]
__0001:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Init1):LINE 14->while R13464_EtherCATStatus!=1 repeat
		Q4T(task)->currentStep = (void *)&currentLine[5];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0002
		goto __0002;
// [0007]
__0002:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Init1):LINE 14->while R13464_EtherCATStatus!=1 repeat
		Q4T(task)->currentStep = (void *)&currentLine[6]; lineYield(task,6);
		// STORE 1 TO REG#36991
		R36991 = 1;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0004
		if (process_CTABLE(R36991, task) == 0) goto __0004;
		// GOTO __0003
		goto __0003;
// [0008]
__0003:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0002
		goto __0002;
// [0009]
__0004:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Init1):LINE 15->R10_Mode = 0
		Q4T(task)->currentStep = (void *)&currentLine[7]; lineYield(task,7);
		// STORE 3 TO REG#36990
		process_ATABLE(3, task);
		// MODULE(kickoff):STEP(Init1):LINE 17->begin (System.String[]) tasks to StageTasks
		Q4T(task)->currentStep = (void *)&currentLine[8]; lineYield(task,8);
		// STORE 4 TO REG#36990
		process_ATABLE(4, task);
		// MODULE(kickoff):STEP(Init1):LINE 19->begin (Updates)
		Q4T(task)->currentStep = (void *)&currentLine[9]; lineYield(task,9);
		// STORE 5 TO REG#36990
		process_ATABLE(5, task);
		// MODULE(kickoff):STEP(Init1):LINE 22->delay = 1000
		Q4T(task)->currentStep = (void *)&currentLine[10];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 6 TO REG#36990
		process_ATABLE(6, task); start_of_step_timeout_flag = 0;
		// GOTO __0005
		goto __0005;
// [0010]
__0005:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Init1):LINE 22->delay = 1000
		Q4T(task)->currentStep = (void *)&currentLine[11]; lineYield(task,11);
		// STORE 2 TO REG#36991
		R36991 = 2;
		// IF REG#36991=0 GOTO __0006
		if (process_CTABLE(R36991, task) == 0) goto __0006;
		// GOTO __0005
		goto __0005;
// [0011]
__0006:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Init1):LINE 24->start XAxis axis_X0
		Q4T(task)->currentStep = (void *)&currentLine[12]; lineYield(task,12);
		// STORE 7 TO REG#36990
		process_ATABLE(7, task);
		// MODULE(kickoff):STEP(Init1):LINE 25->start YAxis axis_Y0
		Q4T(task)->currentStep = (void *)&currentLine[13]; lineYield(task,13);
		// STORE 8 TO REG#36990
		process_ATABLE(8, task);
		// MODULE(kickoff):STEP(Init1):LINE 26->start ZAxis axis_Z0
		Q4T(task)->currentStep = (void *)&currentLine[14]; lineYield(task,14);
		// STORE 9 TO REG#36990
		process_ATABLE(9, task);
		// MODULE(kickoff):STEP(Init1):LINE 28->goto Stops
		Q4T(task)->currentStep = (void *)&currentLine[15]; lineYield(task,15);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO kickoff_Stops
		goto kickoff_Stops;
// [0012]
StageControl:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
StageControl_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(StageControl):LINE 2->goto Mode_Select
		Q4T(task)->currentStep = (void *)&currentLine[16]; lineYield(task,16);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO StageControl_Mode_Select
		goto StageControl_Mode_Select;
// [0013]
StageControl_Mode_Select:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
StageControl_Mode_Select_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(StageControl):STEP(Mode_Select):LINE 2->R510_XAxisCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[17]; lineYield(task,17);
		// STORE 10 TO REG#36990
		process_ATABLE(10, task);
		// MODULE(StageControl):STEP(Mode_Select):LINE 5->goto StageAuto
		Q4T(task)->currentStep = (void *)&currentLine[18]; lineYield(task,18);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO StageControl_StageAuto
		goto StageControl_StageAuto;
// [0014]
StageControl_StageAuto:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
StageControl_StageAuto_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(StageControl):STEP(StageAuto):LINE 3->repeat ( 
		Q4T(task)->currentStep = (void *)&currentLine[19]; lineYield(task,19);
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0008
		goto __0008;
// [0015]
__0008:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0007
		goto __0007;
// [0016]
__0007:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 3 TO REG#36991
		R36991 = 3;
		// IF REG#36991=0 GOTO __0008
		if (process_CTABLE(R36991, task) == 0) goto __0008;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0009
		goto __0009;
// [0017]
__0009:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(StageControl):STEP(StageAuto):LINE 6->R520_YAxisCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[20]; lineYield(task,20);
		// STORE 11 TO REG#36990
		process_ATABLE(11, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 7->R530_ZAxisCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[21]; lineYield(task,21);
		// STORE 12 TO REG#36990
		process_ATABLE(12, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 8->R540_ThetaCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[22]; lineYield(task,22);
		// STORE 13 TO REG#36990
		process_ATABLE(13, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 10->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[23];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 14 TO REG#36990
		process_ATABLE(14, task); start_of_step_timeout_flag = 0;
		// GOTO __0010
		goto __0010;
// [0018]
__0010:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(StageControl):STEP(StageAuto):LINE 10->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[24]; lineYield(task,24);
		// STORE 4 TO REG#36991
		R36991 = 4;
		// IF REG#36991=0 GOTO __0011
		if (process_CTABLE(R36991, task) == 0) goto __0011;
		// GOTO __0010
		goto __0010;
// [0019]
__0011:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(StageControl):STEP(StageAuto):LINE 12->R36701_Speed = R501_Speed
		Q4T(task)->currentStep = (void *)&currentLine[25]; lineYield(task,25);
		// STORE 15 TO REG#36990
		process_ATABLE(15, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 13->R36702_Accel = R502_Accel
		Q4T(task)->currentStep = (void *)&currentLine[26]; lineYield(task,26);
		// STORE 16 TO REG#36990
		process_ATABLE(16, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 14->R36703_Decel = R503_Decel
		Q4T(task)->currentStep = (void *)&currentLine[27]; lineYield(task,27);
		// STORE 17 TO REG#36990
		process_ATABLE(17, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 16->R36704_XTarget = R504_Target
		Q4T(task)->currentStep = (void *)&currentLine[28]; lineYield(task,28);
		// STORE 18 TO REG#36990
		process_ATABLE(18, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 17->R36705_YTarget = R514_Target
		Q4T(task)->currentStep = (void *)&currentLine[29]; lineYield(task,29);
		// STORE 19 TO REG#36990
		process_ATABLE(19, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 18->R36706_ZTarget = R524_Target
		Q4T(task)->currentStep = (void *)&currentLine[30]; lineYield(task,30);
		// STORE 20 TO REG#36990
		process_ATABLE(20, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 21->XAxis.speed = R36701_Speed/1000
		Q4T(task)->currentStep = (void *)&currentLine[31]; lineYield(task,31);
		// STORE 21 TO REG#36990
		process_ATABLE(21, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 22->XAxis.Accel = R36702_Accel/1000
		Q4T(task)->currentStep = (void *)&currentLine[32]; lineYield(task,32);
		// STORE 22 TO REG#36990
		process_ATABLE(22, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 23->XAxis.Decel = R36703_Decel/1000
		Q4T(task)->currentStep = (void *)&currentLine[33]; lineYield(task,33);
		// STORE 23 TO REG#36990
		process_ATABLE(23, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 25->XAxis.XTarget = R36704_XTarget/1000
		Q4T(task)->currentStep = (void *)&currentLine[34]; lineYield(task,34);
		// STORE 24 TO REG#36990
		process_ATABLE(24, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 26->XAxis.YTarget = R36705_YTarget/1000
		Q4T(task)->currentStep = (void *)&currentLine[35]; lineYield(task,35);
		// STORE 25 TO REG#36990
		process_ATABLE(25, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 27->XAxis.ZTarget = R36706_ZTarget/1000
		Q4T(task)->currentStep = (void *)&currentLine[36]; lineYield(task,36);
		// STORE 26 TO REG#36990
		process_ATABLE(26, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 29->XAxis.command = 10
		Q4T(task)->currentStep = (void *)&currentLine[37]; lineYield(task,37);
		// STORE 27 TO REG#36990
		process_ATABLE(27, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 31->repeat ( 
		Q4T(task)->currentStep = (void *)&currentLine[38]; lineYield(task,38);
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0013
		goto __0013;
// [0020]
__0013:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(StageControl):STEP(StageAuto):LINE 32->delay = 20
		Q4T(task)->currentStep = (void *)&currentLine[39];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 28 TO REG#36990
		process_ATABLE(28, task); start_of_step_timeout_flag = 0;
		// GOTO __0015
		goto __0015;
// [0021]
__0015:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(StageControl):STEP(StageAuto):LINE 32->delay = 20
		Q4T(task)->currentStep = (void *)&currentLine[40]; lineYield(task,40);
		// STORE 5 TO REG#36991
		R36991 = 5;
		// IF REG#36991=0 GOTO __0016
		if (process_CTABLE(R36991, task) == 0) goto __0016;
		// GOTO __0015
		goto __0015;
// [0022]
__0016:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0012
		goto __0012;
// [0023]
__0012:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 6 TO REG#36991
		R36991 = 6;
		// MODULE(StageControl):STEP(StageAuto):LINE 31->repeat ( 
		Q4T(task)->currentStep = (void *)&currentLine[41]; lineYield(task,41);
		// IF REG#36991=0 GOTO __0013
		if (process_CTABLE(R36991, task) == 0) goto __0013;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0014
		goto __0014;
// [0024]
__0014:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(StageControl):STEP(StageAuto):LINE 34->F1_Trigger = false
		Q4T(task)->currentStep = (void *)&currentLine[42]; lineYield(task,42);
		// STORE 29 TO REG#36990
		process_ATABLE(29, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 35->R510_XAxisCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[43]; lineYield(task,43);
		// STORE 30 TO REG#36990
		process_ATABLE(30, task);
		// MODULE(StageControl):STEP(StageAuto):LINE 37->goto StageAuto
		Q4T(task)->currentStep = (void *)&currentLine[44]; lineYield(task,44);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO StageControl_StageAuto
		goto StageControl_StageAuto;
		// MODULE(StageControl):STEP(StageAuto):LINE 39->goto StageAuto
		Q4T(task)->currentStep = (void *)&currentLine[45]; lineYield(task,45);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
// [0025]
kickoff_Stops:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
kickoff_Stops_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0017
		goto __0017;
// [0026]
__0017:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Stops):LINE 4->if R500_RestartProgram==1 then 
		Q4T(task)->currentStep = (void *)&currentLine[46]; lineYield(task,46);
		// STORE 7 TO REG#36991
		R36991 = 7;
		// IF REG#36991<>0 GOTO __0018
		if (process_CTABLE(R36991, task) != 0) goto __0018;
		// GOTO __0019
		goto __0019;
// [0027]
__0018:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Stops):LINE 5->R500_RestartProgram = 0
		Q4T(task)->currentStep = (void *)&currentLine[47]; lineYield(task,47);
		// STORE 31 TO REG#36990
		process_ATABLE(31, task);
		// MODULE(kickoff):STEP(Stops):LINE 7->cancel other tasks
		Q4T(task)->currentStep = (void *)&currentLine[48]; lineYield(task,48);
		// GOTO __0020
		goto __0020;
// [0028]
__0020:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// CANCEL OTHER TASKS
		stepCancelOtherTasks(task);
		// GOTO __0021
		goto __0021;
// [0029]
__0021:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Stops):LINE 8->stop XAxis 0
		Q4T(task)->currentStep = (void *)&currentLine[49]; lineYield(task,49);
		// STORE 32 TO REG#36990
		process_ATABLE(32, task);
		// MODULE(kickoff):STEP(Stops):LINE 9->stop YAxis 0
		Q4T(task)->currentStep = (void *)&currentLine[50]; lineYield(task,50);
		// STORE 33 TO REG#36990
		process_ATABLE(33, task);
		// MODULE(kickoff):STEP(Stops):LINE 10->stop ZAxis 0
		Q4T(task)->currentStep = (void *)&currentLine[51]; lineYield(task,51);
		// STORE 34 TO REG#36990
		process_ATABLE(34, task);
		// MODULE(kickoff):STEP(Stops):LINE 11->stop ThetaAxis 0
		Q4T(task)->currentStep = (void *)&currentLine[52]; lineYield(task,52);
		// STORE 35 TO REG#36990
		process_ATABLE(35, task);
		// MODULE(kickoff):STEP(Stops):LINE 12->stop Gripper 0
		Q4T(task)->currentStep = (void *)&currentLine[53]; lineYield(task,53);
		// STORE 36 TO REG#36990
		process_ATABLE(36, task);
		// MODULE(kickoff):STEP(Stops):LINE 14->stop EmptyAxis1 0
		Q4T(task)->currentStep = (void *)&currentLine[54]; lineYield(task,54);
		// STORE 37 TO REG#36990
		process_ATABLE(37, task);
		// MODULE(kickoff):STEP(Stops):LINE 15->stop EmptyAxis2 0
		Q4T(task)->currentStep = (void *)&currentLine[55]; lineYield(task,55);
		// STORE 38 TO REG#36990
		process_ATABLE(38, task);
		// MODULE(kickoff):STEP(Stops):LINE 16->stop TransferStation 0
		Q4T(task)->currentStep = (void *)&currentLine[56]; lineYield(task,56);
		// STORE 39 TO REG#36990
		process_ATABLE(39, task);
		// MODULE(kickoff):STEP(Stops):LINE 17->stop EmptyAxis3 0
		Q4T(task)->currentStep = (void *)&currentLine[57]; lineYield(task,57);
		// STORE 40 TO REG#36990
		process_ATABLE(40, task);
		// MODULE(kickoff):STEP(Stops):LINE 18->delay = 3000
		Q4T(task)->currentStep = (void *)&currentLine[58];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 41 TO REG#36990
		process_ATABLE(41, task); start_of_step_timeout_flag = 0;
		// GOTO __0022
		goto __0022;
// [0030]
__0022:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Stops):LINE 18->delay = 3000
		Q4T(task)->currentStep = (void *)&currentLine[59]; lineYield(task,59);
		// STORE 8 TO REG#36991
		R36991 = 8;
		// IF REG#36991=0 GOTO __0023
		if (process_CTABLE(R36991, task) == 0) goto __0023;
		// GOTO __0022
		goto __0022;
// [0031]
__0023:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Stops):LINE 21->$REGISTERS[10101] = 0
		Q4T(task)->currentStep = (void *)&currentLine[60]; lineYield(task,60);
		// STORE 42 TO REG#36990
		process_ATABLE(42, task);
		// MODULE(kickoff):STEP(Stops):LINE 30->i = 0
		Q4T(task)->currentStep = (void *)&currentLine[61]; lineYield(task,61);
		// STORE 43 TO REG#36990
		process_ATABLE(43, task);
		// MODULE(kickoff):STEP(Stops):LINE 33->R12333_RestartEtherCAT = 1
		Q4T(task)->currentStep = (void *)&currentLine[62]; lineYield(task,62);
		// STORE 44 TO REG#36990
		process_ATABLE(44, task);
		// MODULE(kickoff):STEP(Stops):LINE 34->R13464_EtherCATStatus = 21930
		Q4T(task)->currentStep = (void *)&currentLine[63]; lineYield(task,63);
		// STORE 45 TO REG#36990
		process_ATABLE(45, task);
		// MODULE(kickoff):STEP(Stops):LINE 35->delay = 2000
		Q4T(task)->currentStep = (void *)&currentLine[64];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 46 TO REG#36990
		process_ATABLE(46, task); start_of_step_timeout_flag = 0;
		// GOTO __0024
		goto __0024;
// [0032]
__0024:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Stops):LINE 35->delay = 2000
		Q4T(task)->currentStep = (void *)&currentLine[65]; lineYield(task,65);
		// STORE 9 TO REG#36991
		R36991 = 9;
		// IF REG#36991=0 GOTO __0025
		if (process_CTABLE(R36991, task) == 0) goto __0025;
		// GOTO __0024
		goto __0024;
// [0033]
__0025:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Stops):LINE 36->goto Init1
		Q4T(task)->currentStep = (void *)&currentLine[66]; lineYield(task,66);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO kickoff_Init1
		goto kickoff_Init1;
// [0034]
__0019:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(kickoff):STEP(Stops):LINE 41->goto Stops
		Q4T(task)->currentStep = (void *)&currentLine[67]; lineYield(task,67);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO kickoff_Stops
		goto kickoff_Stops;
// [0035]
AxisX_Init:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisX_Init_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(Init):LINE 3->start XAxis Motion0
		Q4T(task)->currentStep = (void *)&currentLine[68]; lineYield(task,68);
		// STORE 47 TO REG#36990
		process_ATABLE(47, task);
		// MODULE(AxisX):STEP(Init):LINE 4->XAxis.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[69]; lineYield(task,69);
		// STORE 48 TO REG#36990
		process_ATABLE(48, task);
		// MODULE(AxisX):STEP(Init):LINE 5->R510_XAxisCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[70]; lineYield(task,70);
		// STORE 49 TO REG#36990
		process_ATABLE(49, task);
		// MODULE(AxisX):STEP(Init):LINE 9->goto AxisXControl
		Q4T(task)->currentStep = (void *)&currentLine[71]; lineYield(task,71);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisX_AxisXControl
		goto AxisX_AxisXControl;
// [0036]
AxisX_AxisXControl:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisX_AxisXControl_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0026
		goto __0026;
// [0037]
__0026:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 9->if (R510_XAxisCommands)==1 | (R510_XAxisCommands)==11 then 
		Q4T(task)->currentStep = (void *)&currentLine[72]; lineYield(task,72);
		// STORE 10 TO REG#36991
		R36991 = 10;
		// IF REG#36991<>0 GOTO __0027
		if (process_CTABLE(R36991, task) != 0) goto __0027;
		// GOTO __0028
		goto __0028;
// [0038]
__0027:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 10->XAxis.Maxspeed = R501_Speed
		Q4T(task)->currentStep = (void *)&currentLine[73]; lineYield(task,73);
		// STORE 50 TO REG#36990
		process_ATABLE(50, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 11->XAxis.Accel = R502_Accel
		Q4T(task)->currentStep = (void *)&currentLine[74]; lineYield(task,74);
		// STORE 51 TO REG#36990
		process_ATABLE(51, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 12->XAxis.Decel = R503_Decel
		Q4T(task)->currentStep = (void *)&currentLine[75]; lineYield(task,75);
		// STORE 52 TO REG#36990
		process_ATABLE(52, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 13->XAxis.Target = R504_Target
		Q4T(task)->currentStep = (void *)&currentLine[76]; lineYield(task,76);
		// STORE 53 TO REG#36990
		process_ATABLE(53, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 15->XAxis.command = (R510_XAxisCommands)
		Q4T(task)->currentStep = (void *)&currentLine[77]; lineYield(task,77);
		// STORE 54 TO REG#36990
		process_ATABLE(54, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 17->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[78];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 55 TO REG#36990
		process_ATABLE(55, task); start_of_step_timeout_flag = 0;
		// GOTO __0029
		goto __0029;
// [0039]
__0029:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 17->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[79]; lineYield(task,79);
		// STORE 11 TO REG#36991
		R36991 = 11;
		// IF REG#36991=0 GOTO __0030
		if (process_CTABLE(R36991, task) == 0) goto __0030;
		// GOTO __0029
		goto __0029;
// [0040]
__0030:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 20->while (XAxis.command==1 | XAxis.command==11) & (R510_XAxisCommands==1 | R510_XAxisCommands==11) repeat
		Q4T(task)->currentStep = (void *)&currentLine[80];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0031
		goto __0031;
// [0041]
__0031:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 20->while (XAxis.command==1 | XAxis.command==11) & (R510_XAxisCommands==1 | R510_XAxisCommands==11) repeat
		Q4T(task)->currentStep = (void *)&currentLine[81]; lineYield(task,81);
		// STORE 12 TO REG#36991
		R36991 = 12;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0033
		if (process_CTABLE(R36991, task) == 0) goto __0028;
		// GOTO __0032
		goto __0032;
// [0042]
__0032:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 21->running1 = true
		Q4T(task)->currentStep = (void *)&currentLine[82]; lineYield(task,82);
		// STORE 56 TO REG#36990
		process_ATABLE(56, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0031
		goto __0031;
// [0043]
__0028:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0034
		goto __0034;
// [0044]
__0034:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 27->if (R510_XAxisCommands)==3 | (R510_XAxisCommands)==4 then 
		Q4T(task)->currentStep = (void *)&currentLine[83]; lineYield(task,83);
		// STORE 13 TO REG#36991
		R36991 = 13;
		// IF REG#36991<>0 GOTO __0035
		if (process_CTABLE(R36991, task) != 0) goto __0035;
		// GOTO __0036
		goto __0036;
// [0045]
__0035:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 28->XAxis.Maxspeed = R501_Speed
		Q4T(task)->currentStep = (void *)&currentLine[84]; lineYield(task,84);
		// STORE 57 TO REG#36990
		process_ATABLE(57, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 29->XAxis.Accel = R502_Accel
		Q4T(task)->currentStep = (void *)&currentLine[85]; lineYield(task,85);
		// STORE 58 TO REG#36990
		process_ATABLE(58, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 30->XAxis.Decel = R503_Decel
		Q4T(task)->currentStep = (void *)&currentLine[86]; lineYield(task,86);
		// STORE 59 TO REG#36990
		process_ATABLE(59, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 32->XAxis.command = (R510_XAxisCommands)
		Q4T(task)->currentStep = (void *)&currentLine[87]; lineYield(task,87);
		// STORE 60 TO REG#36990
		process_ATABLE(60, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 34->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[88];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 61 TO REG#36990
		process_ATABLE(61, task); start_of_step_timeout_flag = 0;
		// GOTO __0037
		goto __0037;
// [0046]
__0037:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 34->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[89]; lineYield(task,89);
		// STORE 14 TO REG#36991
		R36991 = 14;
		// IF REG#36991=0 GOTO __0038
		if (process_CTABLE(R36991, task) == 0) goto __0038;
		// GOTO __0037
		goto __0037;
// [0047]
__0038:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 35->while XAxis.command==(R510_XAxisCommands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[90];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0039
		goto __0039;
// [0048]
__0039:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 35->while XAxis.command==(R510_XAxisCommands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[91]; lineYield(task,91);
		// STORE 15 TO REG#36991
		R36991 = 15;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0041
		if (process_CTABLE(R36991, task) == 0) goto __0036;
		// GOTO __0040
		goto __0040;
// [0049]
__0040:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 36->running1 = true
		Q4T(task)->currentStep = (void *)&currentLine[92]; lineYield(task,92);
		// STORE 62 TO REG#36990
		process_ATABLE(62, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0039
		goto __0039;
// [0050]
__0036:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0042
		goto __0042;
// [0051]
__0042:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 41->if (R510_XAxisCommands)==5 then 
		Q4T(task)->currentStep = (void *)&currentLine[93]; lineYield(task,93);
		// STORE 16 TO REG#36991
		R36991 = 16;
		// IF REG#36991<>0 GOTO __0043
		if (process_CTABLE(R36991, task) != 0) goto __0043;
		// GOTO __0044
		goto __0044;
// [0052]
__0043:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 42->XAxis.Maxspeed = R501_Speed
		Q4T(task)->currentStep = (void *)&currentLine[94]; lineYield(task,94);
		// STORE 63 TO REG#36990
		process_ATABLE(63, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 43->XAxis.Accel = R502_Accel
		Q4T(task)->currentStep = (void *)&currentLine[95]; lineYield(task,95);
		// STORE 64 TO REG#36990
		process_ATABLE(64, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 44->XAxis.Decel = R503_Decel
		Q4T(task)->currentStep = (void *)&currentLine[96]; lineYield(task,96);
		// STORE 65 TO REG#36990
		process_ATABLE(65, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 47->XAxis.Target = R504_Target
		Q4T(task)->currentStep = (void *)&currentLine[97]; lineYield(task,97);
		// STORE 66 TO REG#36990
		process_ATABLE(66, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 48->XAxis.OffsetHome = R505_HomeOffset
		Q4T(task)->currentStep = (void *)&currentLine[98]; lineYield(task,98);
		// STORE 67 TO REG#36990
		process_ATABLE(67, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 49->XAxis.command = 5
		Q4T(task)->currentStep = (void *)&currentLine[99]; lineYield(task,99);
		// STORE 68 TO REG#36990
		process_ATABLE(68, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 51->while XAxis.command==5 & (R510_XAxisCommands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[100];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0045
		goto __0045;
// [0053]
__0045:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 51->while XAxis.command==5 & (R510_XAxisCommands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[101]; lineYield(task,101);
		// STORE 17 TO REG#36991
		R36991 = 17;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0047
		if (process_CTABLE(R36991, task) == 0) goto __0044;
		// GOTO __0046
		goto __0046;
// [0054]
__0046:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 52->running1 = true
		Q4T(task)->currentStep = (void *)&currentLine[102]; lineYield(task,102);
		// STORE 69 TO REG#36990
		process_ATABLE(69, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0045
		goto __0045;
// [0055]
__0044:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0048
		goto __0048;
// [0056]
__0048:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 58->if ((R510_XAxisCommands)==0 & running1==true) then 
		Q4T(task)->currentStep = (void *)&currentLine[103]; lineYield(task,103);
		// STORE 18 TO REG#36991
		R36991 = 18;
		// IF REG#36991<>0 GOTO __0049
		if (process_CTABLE(R36991, task) != 0) goto __0049;
		// GOTO __0050
		goto __0050;
// [0057]
__0049:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 59->XAxis.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[104]; lineYield(task,104);
		// STORE 70 TO REG#36990
		process_ATABLE(70, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 60->running1 = false
		Q4T(task)->currentStep = (void *)&currentLine[105]; lineYield(task,105);
		// STORE 71 TO REG#36990
		process_ATABLE(71, task);
		// GOTO __0050
		goto __0050;
// [0058]
__0050:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0051
		goto __0051;
// [0059]
__0051:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 64->if ((R510_XAxisCommands)==6 | (R510_XAxisCommands)==7) then 
		Q4T(task)->currentStep = (void *)&currentLine[106]; lineYield(task,106);
		// STORE 19 TO REG#36991
		R36991 = 19;
		// IF REG#36991<>0 GOTO __0052
		if (process_CTABLE(R36991, task) != 0) goto __0052;
		// GOTO __0053
		goto __0053;
// [0060]
__0052:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 65->XAxis.command = R510_XAxisCommands
		Q4T(task)->currentStep = (void *)&currentLine[107]; lineYield(task,107);
		// STORE 72 TO REG#36990
		process_ATABLE(72, task);
		// MODULE(AxisX):STEP(AxisXControl):LINE 66->R510_XAxisCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[108]; lineYield(task,108);
		// STORE 73 TO REG#36990
		process_ATABLE(73, task);
		// GOTO __0053
		goto __0053;
// [0061]
__0053:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):STEP(AxisXControl):LINE 73->goto AxisXControl
		Q4T(task)->currentStep = (void *)&currentLine[109]; lineYield(task,109);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisX_AxisXControl
		goto AxisX_AxisXControl;
// [0062]
AxisX:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisX_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisX):LINE 2->goto Init
		Q4T(task)->currentStep = (void *)&currentLine[110]; lineYield(task,110);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisX_Init
		goto AxisX_Init;
// [0063]
AxisY_Init:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisY_Init_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(Init):LINE 3->start YAxis Motion0
		Q4T(task)->currentStep = (void *)&currentLine[111]; lineYield(task,111);
		// STORE 74 TO REG#36990
		process_ATABLE(74, task);
		// MODULE(AxisY):STEP(Init):LINE 4->YAxis.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[112]; lineYield(task,112);
		// STORE 75 TO REG#36990
		process_ATABLE(75, task);
		// MODULE(AxisY):STEP(Init):LINE 5->R520_YAxisCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[113]; lineYield(task,113);
		// STORE 76 TO REG#36990
		process_ATABLE(76, task);
		// MODULE(AxisY):STEP(Init):LINE 8->goto AxisYControl
		Q4T(task)->currentStep = (void *)&currentLine[114]; lineYield(task,114);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisY_AxisYControl
		goto AxisY_AxisYControl;
// [0064]
AxisY_AxisYControl:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisY_AxisYControl_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0054
		goto __0054;
// [0065]
__0054:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 8->if (R520_YAxisCommands)==1 | (R520_YAxisCommands)==11 then 
		Q4T(task)->currentStep = (void *)&currentLine[115]; lineYield(task,115);
		// STORE 20 TO REG#36991
		R36991 = 20;
		// IF REG#36991<>0 GOTO __0055
		if (process_CTABLE(R36991, task) != 0) goto __0055;
		// GOTO __0056
		goto __0056;
// [0066]
__0055:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 9->YAxis.Maxspeed = R511_Speed
		Q4T(task)->currentStep = (void *)&currentLine[116]; lineYield(task,116);
		// STORE 77 TO REG#36990
		process_ATABLE(77, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 10->YAxis.Accel = R512_Accel
		Q4T(task)->currentStep = (void *)&currentLine[117]; lineYield(task,117);
		// STORE 78 TO REG#36990
		process_ATABLE(78, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 11->YAxis.Decel = R513_Decel
		Q4T(task)->currentStep = (void *)&currentLine[118]; lineYield(task,118);
		// STORE 79 TO REG#36990
		process_ATABLE(79, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 12->YAxis.Target = R514_Target
		Q4T(task)->currentStep = (void *)&currentLine[119]; lineYield(task,119);
		// STORE 80 TO REG#36990
		process_ATABLE(80, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 14->YAxis.command = (R520_YAxisCommands)
		Q4T(task)->currentStep = (void *)&currentLine[120]; lineYield(task,120);
		// STORE 81 TO REG#36990
		process_ATABLE(81, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 16->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[121];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 82 TO REG#36990
		process_ATABLE(82, task); start_of_step_timeout_flag = 0;
		// GOTO __0057
		goto __0057;
// [0067]
__0057:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 16->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[122]; lineYield(task,122);
		// STORE 21 TO REG#36991
		R36991 = 21;
		// IF REG#36991=0 GOTO __0058
		if (process_CTABLE(R36991, task) == 0) goto __0058;
		// GOTO __0057
		goto __0057;
// [0068]
__0058:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 17->while (YAxis.command==1 | YAxis.command==11) & (R520_YAxisCommands==1 | R520_YAxisCommands==11) repeat
		Q4T(task)->currentStep = (void *)&currentLine[123];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0059
		goto __0059;
// [0069]
__0059:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 17->while (YAxis.command==1 | YAxis.command==11) & (R520_YAxisCommands==1 | R520_YAxisCommands==11) repeat
		Q4T(task)->currentStep = (void *)&currentLine[124]; lineYield(task,124);
		// STORE 22 TO REG#36991
		R36991 = 22;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0061
		if (process_CTABLE(R36991, task) == 0) goto __0056;
		// GOTO __0060
		goto __0060;
// [0070]
__0060:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 18->running2 = true
		Q4T(task)->currentStep = (void *)&currentLine[125]; lineYield(task,125);
		// STORE 83 TO REG#36990
		process_ATABLE(83, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0059
		goto __0059;
// [0071]
__0056:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0062
		goto __0062;
// [0072]
__0062:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 24->if (R520_YAxisCommands)==3 | (R520_YAxisCommands)==4 then 
		Q4T(task)->currentStep = (void *)&currentLine[126]; lineYield(task,126);
		// STORE 23 TO REG#36991
		R36991 = 23;
		// IF REG#36991<>0 GOTO __0063
		if (process_CTABLE(R36991, task) != 0) goto __0063;
		// GOTO __0064
		goto __0064;
// [0073]
__0063:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 25->YAxis.Maxspeed = R511_Speed
		Q4T(task)->currentStep = (void *)&currentLine[127]; lineYield(task,127);
		// STORE 84 TO REG#36990
		process_ATABLE(84, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 26->YAxis.Accel = R512_Accel
		Q4T(task)->currentStep = (void *)&currentLine[128]; lineYield(task,128);
		// STORE 85 TO REG#36990
		process_ATABLE(85, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 27->YAxis.Decel = R513_Decel
		Q4T(task)->currentStep = (void *)&currentLine[129]; lineYield(task,129);
		// STORE 86 TO REG#36990
		process_ATABLE(86, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 28->YAxis.command = (R520_YAxisCommands)
		Q4T(task)->currentStep = (void *)&currentLine[130]; lineYield(task,130);
		// STORE 87 TO REG#36990
		process_ATABLE(87, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 31->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[131];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 88 TO REG#36990
		process_ATABLE(88, task); start_of_step_timeout_flag = 0;
		// GOTO __0065
		goto __0065;
// [0074]
__0065:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 31->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[132]; lineYield(task,132);
		// STORE 24 TO REG#36991
		R36991 = 24;
		// IF REG#36991=0 GOTO __0066
		if (process_CTABLE(R36991, task) == 0) goto __0066;
		// GOTO __0065
		goto __0065;
// [0075]
__0066:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 32->while YAxis.command==(R520_YAxisCommands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[133];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0067
		goto __0067;
// [0076]
__0067:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 32->while YAxis.command==(R520_YAxisCommands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[134]; lineYield(task,134);
		// STORE 25 TO REG#36991
		R36991 = 25;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0069
		if (process_CTABLE(R36991, task) == 0) goto __0064;
		// GOTO __0068
		goto __0068;
// [0077]
__0068:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 33->running2 = true
		Q4T(task)->currentStep = (void *)&currentLine[135]; lineYield(task,135);
		// STORE 89 TO REG#36990
		process_ATABLE(89, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0067
		goto __0067;
// [0078]
__0064:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0070
		goto __0070;
// [0079]
__0070:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 38->if (R520_YAxisCommands)==5 then 
		Q4T(task)->currentStep = (void *)&currentLine[136]; lineYield(task,136);
		// STORE 26 TO REG#36991
		R36991 = 26;
		// IF REG#36991<>0 GOTO __0071
		if (process_CTABLE(R36991, task) != 0) goto __0071;
		// GOTO __0072
		goto __0072;
// [0080]
__0071:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 39->YAxis.Maxspeed = R511_Speed
		Q4T(task)->currentStep = (void *)&currentLine[137]; lineYield(task,137);
		// STORE 90 TO REG#36990
		process_ATABLE(90, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 40->YAxis.Accel = R512_Accel
		Q4T(task)->currentStep = (void *)&currentLine[138]; lineYield(task,138);
		// STORE 91 TO REG#36990
		process_ATABLE(91, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 41->YAxis.Decel = R513_Decel
		Q4T(task)->currentStep = (void *)&currentLine[139]; lineYield(task,139);
		// STORE 92 TO REG#36990
		process_ATABLE(92, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 42->YAxis.Target = R514_Target
		Q4T(task)->currentStep = (void *)&currentLine[140]; lineYield(task,140);
		// STORE 93 TO REG#36990
		process_ATABLE(93, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 43->YAxis.OffsetHome = R515_HomeOffset
		Q4T(task)->currentStep = (void *)&currentLine[141]; lineYield(task,141);
		// STORE 94 TO REG#36990
		process_ATABLE(94, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 44->YAxis.command = 5
		Q4T(task)->currentStep = (void *)&currentLine[142]; lineYield(task,142);
		// STORE 95 TO REG#36990
		process_ATABLE(95, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 46->while YAxis.command==5 & (R520_YAxisCommands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[143];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0073
		goto __0073;
// [0081]
__0073:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 46->while YAxis.command==5 & (R520_YAxisCommands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[144]; lineYield(task,144);
		// STORE 27 TO REG#36991
		R36991 = 27;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0075
		if (process_CTABLE(R36991, task) == 0) goto __0072;
		// GOTO __0074
		goto __0074;
// [0082]
__0074:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 47->running2 = true
		Q4T(task)->currentStep = (void *)&currentLine[145]; lineYield(task,145);
		// STORE 96 TO REG#36990
		process_ATABLE(96, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0073
		goto __0073;
// [0083]
__0072:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0076
		goto __0076;
// [0084]
__0076:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 53->if ((R520_YAxisCommands)==0 & running2==true) then 
		Q4T(task)->currentStep = (void *)&currentLine[146]; lineYield(task,146);
		// STORE 28 TO REG#36991
		R36991 = 28;
		// IF REG#36991<>0 GOTO __0077
		if (process_CTABLE(R36991, task) != 0) goto __0077;
		// GOTO __0078
		goto __0078;
// [0085]
__0077:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 54->YAxis.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[147]; lineYield(task,147);
		// STORE 97 TO REG#36990
		process_ATABLE(97, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 55->running2 = false
		Q4T(task)->currentStep = (void *)&currentLine[148]; lineYield(task,148);
		// STORE 98 TO REG#36990
		process_ATABLE(98, task);
		// GOTO __0078
		goto __0078;
// [0086]
__0078:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0079
		goto __0079;
// [0087]
__0079:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 60->if ((R520_YAxisCommands)==6 | (R520_YAxisCommands)==7) then 
		Q4T(task)->currentStep = (void *)&currentLine[149]; lineYield(task,149);
		// STORE 29 TO REG#36991
		R36991 = 29;
		// IF REG#36991<>0 GOTO __0080
		if (process_CTABLE(R36991, task) != 0) goto __0080;
		// GOTO __0081
		goto __0081;
// [0088]
__0080:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 61->YAxis.command = R520_YAxisCommands
		Q4T(task)->currentStep = (void *)&currentLine[150]; lineYield(task,150);
		// STORE 99 TO REG#36990
		process_ATABLE(99, task);
		// MODULE(AxisY):STEP(AxisYControl):LINE 62->R520_YAxisCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[151]; lineYield(task,151);
		// STORE 100 TO REG#36990
		process_ATABLE(100, task);
		// GOTO __0081
		goto __0081;
// [0089]
__0081:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):STEP(AxisYControl):LINE 68->goto AxisYControl
		Q4T(task)->currentStep = (void *)&currentLine[152]; lineYield(task,152);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisY_AxisYControl
		goto AxisY_AxisYControl;
// [0090]
AxisY:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisY_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisY):LINE 2->goto Init
		Q4T(task)->currentStep = (void *)&currentLine[153]; lineYield(task,153);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisY_Init
		goto AxisY_Init;
// [0091]
AxisZ_Init:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisZ_Init_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(Init):LINE 2->start ZAxis Motion0
		Q4T(task)->currentStep = (void *)&currentLine[154]; lineYield(task,154);
		// STORE 101 TO REG#36990
		process_ATABLE(101, task);
		// MODULE(AxisZ):STEP(Init):LINE 3->ZAxis.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[155]; lineYield(task,155);
		// STORE 102 TO REG#36990
		process_ATABLE(102, task);
		// MODULE(AxisZ):STEP(Init):LINE 4->R530_ZAxisCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[156]; lineYield(task,156);
		// STORE 103 TO REG#36990
		process_ATABLE(103, task);
		// MODULE(AxisZ):STEP(Init):LINE 8->goto AxisZControl
		Q4T(task)->currentStep = (void *)&currentLine[157]; lineYield(task,157);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisZ_AxisZControl
		goto AxisZ_AxisZControl;
// [0092]
AxisZ_AxisZControl:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisZ_AxisZControl_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0082
		goto __0082;
// [0093]
__0082:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 10->if (R530_ZAxisCommands)==1 | (R530_ZAxisCommands)==11 then 
		Q4T(task)->currentStep = (void *)&currentLine[158]; lineYield(task,158);
		// STORE 30 TO REG#36991
		R36991 = 30;
		// IF REG#36991<>0 GOTO __0083
		if (process_CTABLE(R36991, task) != 0) goto __0083;
		// GOTO __0084
		goto __0084;
// [0094]
__0083:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 13->ZAxis.Maxspeed = R521_Speed
		Q4T(task)->currentStep = (void *)&currentLine[159]; lineYield(task,159);
		// STORE 104 TO REG#36990
		process_ATABLE(104, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 14->ZAxis.Accel = R522_Accel
		Q4T(task)->currentStep = (void *)&currentLine[160]; lineYield(task,160);
		// STORE 105 TO REG#36990
		process_ATABLE(105, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 15->ZAxis.Decel = R523_Decel
		Q4T(task)->currentStep = (void *)&currentLine[161]; lineYield(task,161);
		// STORE 106 TO REG#36990
		process_ATABLE(106, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 16->ZAxis.Target = R524_Target
		Q4T(task)->currentStep = (void *)&currentLine[162]; lineYield(task,162);
		// STORE 107 TO REG#36990
		process_ATABLE(107, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 18->ZAxis.command = (R530_ZAxisCommands)
		Q4T(task)->currentStep = (void *)&currentLine[163]; lineYield(task,163);
		// STORE 108 TO REG#36990
		process_ATABLE(108, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 20->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[164];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 109 TO REG#36990
		process_ATABLE(109, task); start_of_step_timeout_flag = 0;
		// GOTO __0085
		goto __0085;
// [0095]
__0085:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 20->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[165]; lineYield(task,165);
		// STORE 31 TO REG#36991
		R36991 = 31;
		// IF REG#36991=0 GOTO __0086
		if (process_CTABLE(R36991, task) == 0) goto __0086;
		// GOTO __0085
		goto __0085;
// [0096]
__0086:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 21->while (ZAxis.command==1 | ZAxis.command==11) & (R530_ZAxisCommands==1 | R530_ZAxisCommands==11) repeat
		Q4T(task)->currentStep = (void *)&currentLine[166];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0087
		goto __0087;
// [0097]
__0087:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 21->while (ZAxis.command==1 | ZAxis.command==11) & (R530_ZAxisCommands==1 | R530_ZAxisCommands==11) repeat
		Q4T(task)->currentStep = (void *)&currentLine[167]; lineYield(task,167);
		// STORE 32 TO REG#36991
		R36991 = 32;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0089
		if (process_CTABLE(R36991, task) == 0) goto __0084;
		// GOTO __0088
		goto __0088;
// [0098]
__0088:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 22->running3 = true
		Q4T(task)->currentStep = (void *)&currentLine[168]; lineYield(task,168);
		// STORE 110 TO REG#36990
		process_ATABLE(110, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0087
		goto __0087;
// [0099]
__0084:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0090
		goto __0090;
// [0100]
__0090:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 28->if (R530_ZAxisCommands)==3 | (R530_ZAxisCommands)==4 then 
		Q4T(task)->currentStep = (void *)&currentLine[169]; lineYield(task,169);
		// STORE 33 TO REG#36991
		R36991 = 33;
		// IF REG#36991<>0 GOTO __0091
		if (process_CTABLE(R36991, task) != 0) goto __0091;
		// GOTO __0092
		goto __0092;
// [0101]
__0091:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 30->ZAxis.Maxspeed = R521_Speed
		Q4T(task)->currentStep = (void *)&currentLine[170]; lineYield(task,170);
		// STORE 111 TO REG#36990
		process_ATABLE(111, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 31->ZAxis.Accel = R522_Accel
		Q4T(task)->currentStep = (void *)&currentLine[171]; lineYield(task,171);
		// STORE 112 TO REG#36990
		process_ATABLE(112, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 32->ZAxis.Decel = R523_Decel
		Q4T(task)->currentStep = (void *)&currentLine[172]; lineYield(task,172);
		// STORE 113 TO REG#36990
		process_ATABLE(113, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 34->ZAxis.command = (R530_ZAxisCommands)
		Q4T(task)->currentStep = (void *)&currentLine[173]; lineYield(task,173);
		// STORE 114 TO REG#36990
		process_ATABLE(114, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 36->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[174];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 115 TO REG#36990
		process_ATABLE(115, task); start_of_step_timeout_flag = 0;
		// GOTO __0093
		goto __0093;
// [0102]
__0093:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 36->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[175]; lineYield(task,175);
		// STORE 34 TO REG#36991
		R36991 = 34;
		// IF REG#36991=0 GOTO __0094
		if (process_CTABLE(R36991, task) == 0) goto __0094;
		// GOTO __0093
		goto __0093;
// [0103]
__0094:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 37->while ZAxis.command==(R530_ZAxisCommands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[176];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0095
		goto __0095;
// [0104]
__0095:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 37->while ZAxis.command==(R530_ZAxisCommands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[177]; lineYield(task,177);
		// STORE 35 TO REG#36991
		R36991 = 35;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0097
		if (process_CTABLE(R36991, task) == 0) goto __0092;
		// GOTO __0096
		goto __0096;
// [0105]
__0096:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 38->running3 = true
		Q4T(task)->currentStep = (void *)&currentLine[178]; lineYield(task,178);
		// STORE 116 TO REG#36990
		process_ATABLE(116, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0095
		goto __0095;
// [0106]
__0092:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0098
		goto __0098;
// [0107]
__0098:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 43->if (R530_ZAxisCommands)==5 then 
		Q4T(task)->currentStep = (void *)&currentLine[179]; lineYield(task,179);
		// STORE 36 TO REG#36991
		R36991 = 36;
		// IF REG#36991<>0 GOTO __0099
		if (process_CTABLE(R36991, task) != 0) goto __0099;
		// GOTO __0100
		goto __0100;
// [0108]
__0099:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 44->ZAxis.Maxspeed = R521_Speed
		Q4T(task)->currentStep = (void *)&currentLine[180]; lineYield(task,180);
		// STORE 117 TO REG#36990
		process_ATABLE(117, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 45->ZAxis.Accel = R522_Accel
		Q4T(task)->currentStep = (void *)&currentLine[181]; lineYield(task,181);
		// STORE 118 TO REG#36990
		process_ATABLE(118, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 46->ZAxis.Decel = R523_Decel
		Q4T(task)->currentStep = (void *)&currentLine[182]; lineYield(task,182);
		// STORE 119 TO REG#36990
		process_ATABLE(119, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 47->ZAxis.Target = R524_Target
		Q4T(task)->currentStep = (void *)&currentLine[183]; lineYield(task,183);
		// STORE 120 TO REG#36990
		process_ATABLE(120, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 48->ZAxis.OffsetHome = R525_HomeOffset
		Q4T(task)->currentStep = (void *)&currentLine[184]; lineYield(task,184);
		// STORE 121 TO REG#36990
		process_ATABLE(121, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 49->ZAxis.command = 5
		Q4T(task)->currentStep = (void *)&currentLine[185]; lineYield(task,185);
		// STORE 122 TO REG#36990
		process_ATABLE(122, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 51->while ZAxis.command==5 & (R530_ZAxisCommands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[186];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0101
		goto __0101;
// [0109]
__0101:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 51->while ZAxis.command==5 & (R530_ZAxisCommands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[187]; lineYield(task,187);
		// STORE 37 TO REG#36991
		R36991 = 37;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0103
		if (process_CTABLE(R36991, task) == 0) goto __0100;
		// GOTO __0102
		goto __0102;
// [0110]
__0102:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 52->running3 = true
		Q4T(task)->currentStep = (void *)&currentLine[188]; lineYield(task,188);
		// STORE 123 TO REG#36990
		process_ATABLE(123, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0101
		goto __0101;
// [0111]
__0100:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0104
		goto __0104;
// [0112]
__0104:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 58->if ((R530_ZAxisCommands)==0 & running3==true) then 
		Q4T(task)->currentStep = (void *)&currentLine[189]; lineYield(task,189);
		// STORE 38 TO REG#36991
		R36991 = 38;
		// IF REG#36991<>0 GOTO __0105
		if (process_CTABLE(R36991, task) != 0) goto __0105;
		// GOTO __0106
		goto __0106;
// [0113]
__0105:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 59->ZAxis.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[190]; lineYield(task,190);
		// STORE 124 TO REG#36990
		process_ATABLE(124, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 60->running3 = false
		Q4T(task)->currentStep = (void *)&currentLine[191]; lineYield(task,191);
		// STORE 125 TO REG#36990
		process_ATABLE(125, task);
		// GOTO __0106
		goto __0106;
// [0114]
__0106:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0107
		goto __0107;
// [0115]
__0107:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 64->if ((R530_ZAxisCommands)==6 | (R530_ZAxisCommands)==7) then 
		Q4T(task)->currentStep = (void *)&currentLine[192]; lineYield(task,192);
		// STORE 39 TO REG#36991
		R36991 = 39;
		// IF REG#36991<>0 GOTO __0108
		if (process_CTABLE(R36991, task) != 0) goto __0108;
		// GOTO __0109
		goto __0109;
// [0116]
__0108:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 65->ZAxis.command = R530_ZAxisCommands
		Q4T(task)->currentStep = (void *)&currentLine[193]; lineYield(task,193);
		// STORE 126 TO REG#36990
		process_ATABLE(126, task);
		// MODULE(AxisZ):STEP(AxisZControl):LINE 66->R530_ZAxisCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[194]; lineYield(task,194);
		// STORE 127 TO REG#36990
		process_ATABLE(127, task);
		// GOTO __0109
		goto __0109;
// [0117]
__0109:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):STEP(AxisZControl):LINE 71->goto AxisZControl
		Q4T(task)->currentStep = (void *)&currentLine[195]; lineYield(task,195);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisZ_AxisZControl
		goto AxisZ_AxisZControl;
// [0118]
AxisZ:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisZ_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisZ):LINE 2->goto Init
		Q4T(task)->currentStep = (void *)&currentLine[196]; lineYield(task,196);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisZ_Init
		goto AxisZ_Init;
// [0119]
AxisTheta:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisTheta_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):LINE 2->goto Init
		Q4T(task)->currentStep = (void *)&currentLine[197]; lineYield(task,197);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisTheta_Init
		goto AxisTheta_Init;
// [0120]
AxisTheta_Init:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisTheta_Init_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(Init):LINE 2->start ThetaAxis Motion0
		Q4T(task)->currentStep = (void *)&currentLine[198]; lineYield(task,198);
		// STORE 128 TO REG#36990
		process_ATABLE(128, task);
		// MODULE(AxisTheta):STEP(Init):LINE 3->ThetaAxis.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[199]; lineYield(task,199);
		// STORE 129 TO REG#36990
		process_ATABLE(129, task);
		// MODULE(AxisTheta):STEP(Init):LINE 4->R540_ThetaCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[200]; lineYield(task,200);
		// STORE 130 TO REG#36990
		process_ATABLE(130, task);
		// MODULE(AxisTheta):STEP(Init):LINE 8->goto ThetaControl
		Q4T(task)->currentStep = (void *)&currentLine[201]; lineYield(task,201);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisTheta_ThetaControl
		goto AxisTheta_ThetaControl;
// [0121]
AxisTheta_ThetaControl:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisTheta_ThetaControl_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0110
		goto __0110;
// [0122]
__0110:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 10->if (R540_ThetaCommands)==1 | (R540_ThetaCommands)==11 then 
		Q4T(task)->currentStep = (void *)&currentLine[202]; lineYield(task,202);
		// STORE 40 TO REG#36991
		R36991 = 40;
		// IF REG#36991<>0 GOTO __0111
		if (process_CTABLE(R36991, task) != 0) goto __0111;
		// GOTO __0112
		goto __0112;
// [0123]
__0111:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 13->ThetaAxis.Maxspeed = R531_Speed
		Q4T(task)->currentStep = (void *)&currentLine[203]; lineYield(task,203);
		// STORE 131 TO REG#36990
		process_ATABLE(131, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 14->ThetaAxis.Accel = R532_Accel
		Q4T(task)->currentStep = (void *)&currentLine[204]; lineYield(task,204);
		// STORE 132 TO REG#36990
		process_ATABLE(132, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 15->ThetaAxis.Decel = R533_Decel
		Q4T(task)->currentStep = (void *)&currentLine[205]; lineYield(task,205);
		// STORE 133 TO REG#36990
		process_ATABLE(133, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 16->ThetaAxis.Target = R534_Target
		Q4T(task)->currentStep = (void *)&currentLine[206]; lineYield(task,206);
		// STORE 134 TO REG#36990
		process_ATABLE(134, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 18->ThetaAxis.command = (R540_ThetaCommands)
		Q4T(task)->currentStep = (void *)&currentLine[207]; lineYield(task,207);
		// STORE 135 TO REG#36990
		process_ATABLE(135, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 20->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[208];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 136 TO REG#36990
		process_ATABLE(136, task); start_of_step_timeout_flag = 0;
		// GOTO __0113
		goto __0113;
// [0124]
__0113:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 20->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[209]; lineYield(task,209);
		// STORE 41 TO REG#36991
		R36991 = 41;
		// IF REG#36991=0 GOTO __0114
		if (process_CTABLE(R36991, task) == 0) goto __0114;
		// GOTO __0113
		goto __0113;
// [0125]
__0114:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 21->while (ThetaAxis.command==1 | ThetaAxis.command==11) & (R540_ThetaCommands==1 | R540_ThetaCommands==11) repeat
		Q4T(task)->currentStep = (void *)&currentLine[210];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0115
		goto __0115;
// [0126]
__0115:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 21->while (ThetaAxis.command==1 | ThetaAxis.command==11) & (R540_ThetaCommands==1 | R540_ThetaCommands==11) repeat
		Q4T(task)->currentStep = (void *)&currentLine[211]; lineYield(task,211);
		// STORE 42 TO REG#36991
		R36991 = 42;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0117
		if (process_CTABLE(R36991, task) == 0) goto __0112;
		// GOTO __0116
		goto __0116;
// [0127]
__0116:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 22->running4 = true
		Q4T(task)->currentStep = (void *)&currentLine[212]; lineYield(task,212);
		// STORE 137 TO REG#36990
		process_ATABLE(137, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0115
		goto __0115;
// [0128]
__0112:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0118
		goto __0118;
// [0129]
__0118:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 28->if (R540_ThetaCommands)==3 | (R540_ThetaCommands)==4 then 
		Q4T(task)->currentStep = (void *)&currentLine[213]; lineYield(task,213);
		// STORE 43 TO REG#36991
		R36991 = 43;
		// IF REG#36991<>0 GOTO __0119
		if (process_CTABLE(R36991, task) != 0) goto __0119;
		// GOTO __0120
		goto __0120;
// [0130]
__0119:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 30->ThetaAxis.Maxspeed = R531_Speed
		Q4T(task)->currentStep = (void *)&currentLine[214]; lineYield(task,214);
		// STORE 138 TO REG#36990
		process_ATABLE(138, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 31->ThetaAxis.Accel = R532_Accel
		Q4T(task)->currentStep = (void *)&currentLine[215]; lineYield(task,215);
		// STORE 139 TO REG#36990
		process_ATABLE(139, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 32->ThetaAxis.Decel = R533_Decel
		Q4T(task)->currentStep = (void *)&currentLine[216]; lineYield(task,216);
		// STORE 140 TO REG#36990
		process_ATABLE(140, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 34->ThetaAxis.command = (R540_ThetaCommands)
		Q4T(task)->currentStep = (void *)&currentLine[217]; lineYield(task,217);
		// STORE 141 TO REG#36990
		process_ATABLE(141, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 36->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[218];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 142 TO REG#36990
		process_ATABLE(142, task); start_of_step_timeout_flag = 0;
		// GOTO __0121
		goto __0121;
// [0131]
__0121:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 36->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[219]; lineYield(task,219);
		// STORE 44 TO REG#36991
		R36991 = 44;
		// IF REG#36991=0 GOTO __0122
		if (process_CTABLE(R36991, task) == 0) goto __0122;
		// GOTO __0121
		goto __0121;
// [0132]
__0122:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 37->while ThetaAxis.command==(R540_ThetaCommands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[220];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0123
		goto __0123;
// [0133]
__0123:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 37->while ThetaAxis.command==(R540_ThetaCommands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[221]; lineYield(task,221);
		// STORE 45 TO REG#36991
		R36991 = 45;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0125
		if (process_CTABLE(R36991, task) == 0) goto __0120;
		// GOTO __0124
		goto __0124;
// [0134]
__0124:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 38->running4 = true
		Q4T(task)->currentStep = (void *)&currentLine[222]; lineYield(task,222);
		// STORE 143 TO REG#36990
		process_ATABLE(143, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0123
		goto __0123;
// [0135]
__0120:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0126
		goto __0126;
// [0136]
__0126:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 43->if (R540_ThetaCommands)==5 then 
		Q4T(task)->currentStep = (void *)&currentLine[223]; lineYield(task,223);
		// STORE 46 TO REG#36991
		R36991 = 46;
		// IF REG#36991<>0 GOTO __0127
		if (process_CTABLE(R36991, task) != 0) goto __0127;
		// GOTO __0128
		goto __0128;
// [0137]
__0127:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 44->ThetaAxis.Maxspeed = R531_Speed
		Q4T(task)->currentStep = (void *)&currentLine[224]; lineYield(task,224);
		// STORE 144 TO REG#36990
		process_ATABLE(144, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 45->ThetaAxis.Accel = R532_Accel
		Q4T(task)->currentStep = (void *)&currentLine[225]; lineYield(task,225);
		// STORE 145 TO REG#36990
		process_ATABLE(145, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 46->ThetaAxis.Decel = R533_Decel
		Q4T(task)->currentStep = (void *)&currentLine[226]; lineYield(task,226);
		// STORE 146 TO REG#36990
		process_ATABLE(146, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 47->ThetaAxis.Target = R534_Target
		Q4T(task)->currentStep = (void *)&currentLine[227]; lineYield(task,227);
		// STORE 147 TO REG#36990
		process_ATABLE(147, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 48->ThetaAxis.OffsetHome = R535_HomeOffset
		Q4T(task)->currentStep = (void *)&currentLine[228]; lineYield(task,228);
		// STORE 148 TO REG#36990
		process_ATABLE(148, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 49->ThetaAxis.command = 5
		Q4T(task)->currentStep = (void *)&currentLine[229]; lineYield(task,229);
		// STORE 149 TO REG#36990
		process_ATABLE(149, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 51->while ThetaAxis.command==5 & (R540_ThetaCommands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[230];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0129
		goto __0129;
// [0138]
__0129:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 51->while ThetaAxis.command==5 & (R540_ThetaCommands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[231]; lineYield(task,231);
		// STORE 47 TO REG#36991
		R36991 = 47;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0131
		if (process_CTABLE(R36991, task) == 0) goto __0128;
		// GOTO __0130
		goto __0130;
// [0139]
__0130:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 52->running4 = true
		Q4T(task)->currentStep = (void *)&currentLine[232]; lineYield(task,232);
		// STORE 150 TO REG#36990
		process_ATABLE(150, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0129
		goto __0129;
// [0140]
__0128:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0132
		goto __0132;
// [0141]
__0132:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 58->if ((R540_ThetaCommands)==0 & running4==true) then 
		Q4T(task)->currentStep = (void *)&currentLine[233]; lineYield(task,233);
		// STORE 48 TO REG#36991
		R36991 = 48;
		// IF REG#36991<>0 GOTO __0133
		if (process_CTABLE(R36991, task) != 0) goto __0133;
		// GOTO __0134
		goto __0134;
// [0142]
__0133:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 59->ThetaAxis.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[234]; lineYield(task,234);
		// STORE 151 TO REG#36990
		process_ATABLE(151, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 60->running4 = false
		Q4T(task)->currentStep = (void *)&currentLine[235]; lineYield(task,235);
		// STORE 152 TO REG#36990
		process_ATABLE(152, task);
		// GOTO __0134
		goto __0134;
// [0143]
__0134:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0135
		goto __0135;
// [0144]
__0135:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 65->if ((R540_ThetaCommands)==6 | (R540_ThetaCommands)==7) then 
		Q4T(task)->currentStep = (void *)&currentLine[236]; lineYield(task,236);
		// STORE 49 TO REG#36991
		R36991 = 49;
		// IF REG#36991<>0 GOTO __0136
		if (process_CTABLE(R36991, task) != 0) goto __0136;
		// GOTO __0137
		goto __0137;
// [0145]
__0136:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 66->ThetaAxis.command = R540_ThetaCommands
		Q4T(task)->currentStep = (void *)&currentLine[237]; lineYield(task,237);
		// STORE 153 TO REG#36990
		process_ATABLE(153, task);
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 67->R540_ThetaCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[238]; lineYield(task,238);
		// STORE 154 TO REG#36990
		process_ATABLE(154, task);
		// GOTO __0137
		goto __0137;
// [0146]
__0137:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTheta):STEP(ThetaControl):LINE 72->goto ThetaControl
		Q4T(task)->currentStep = (void *)&currentLine[239]; lineYield(task,239);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisTheta_ThetaControl
		goto AxisTheta_ThetaControl;
// [0147]
AxisGripper:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisGripper_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):LINE 2->goto Init
		Q4T(task)->currentStep = (void *)&currentLine[240]; lineYield(task,240);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisGripper_Init
		goto AxisGripper_Init;
// [0148]
AxisGripper_Init:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisGripper_Init_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(Init):LINE 2->start Gripper MaxonMotion0
		Q4T(task)->currentStep = (void *)&currentLine[241]; lineYield(task,241);
		// STORE 155 TO REG#36990
		process_ATABLE(155, task);
		// MODULE(AxisGripper):STEP(Init):LINE 4->Gripper.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[242]; lineYield(task,242);
		// STORE 156 TO REG#36990
		process_ATABLE(156, task);
		// MODULE(AxisGripper):STEP(Init):LINE 5->R550_GripperCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[243]; lineYield(task,243);
		// STORE 157 TO REG#36990
		process_ATABLE(157, task);
		// MODULE(AxisGripper):STEP(Init):LINE 9->goto GripperControl
		Q4T(task)->currentStep = (void *)&currentLine[244]; lineYield(task,244);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisGripper_GripperControl
		goto AxisGripper_GripperControl;
// [0149]
AxisGripper_GripperControl:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisGripper_GripperControl_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0138
		goto __0138;
// [0150]
__0138:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 10->if (R550_GripperCommands)==1 then 
		Q4T(task)->currentStep = (void *)&currentLine[245]; lineYield(task,245);
		// STORE 50 TO REG#36991
		R36991 = 50;
		// IF REG#36991<>0 GOTO __0139
		if (process_CTABLE(R36991, task) != 0) goto __0139;
		// GOTO __0140
		goto __0140;
// [0151]
__0139:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 12->Gripper.Maxspeed = R541_Speed
		Q4T(task)->currentStep = (void *)&currentLine[246]; lineYield(task,246);
		// STORE 158 TO REG#36990
		process_ATABLE(158, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 13->Gripper.Accel = R542_Accel
		Q4T(task)->currentStep = (void *)&currentLine[247]; lineYield(task,247);
		// STORE 159 TO REG#36990
		process_ATABLE(159, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 14->Gripper.Decel = R543_Decel
		Q4T(task)->currentStep = (void *)&currentLine[248]; lineYield(task,248);
		// STORE 160 TO REG#36990
		process_ATABLE(160, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 15->Gripper.Target = R544_Target
		Q4T(task)->currentStep = (void *)&currentLine[249]; lineYield(task,249);
		// STORE 161 TO REG#36990
		process_ATABLE(161, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 17->Gripper.command = (R550_GripperCommands)
		Q4T(task)->currentStep = (void *)&currentLine[250]; lineYield(task,250);
		// STORE 162 TO REG#36990
		process_ATABLE(162, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 19->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[251];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 163 TO REG#36990
		process_ATABLE(163, task); start_of_step_timeout_flag = 0;
		// GOTO __0141
		goto __0141;
// [0152]
__0141:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 19->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[252]; lineYield(task,252);
		// STORE 51 TO REG#36991
		R36991 = 51;
		// IF REG#36991=0 GOTO __0142
		if (process_CTABLE(R36991, task) == 0) goto __0142;
		// GOTO __0141
		goto __0141;
// [0153]
__0142:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 20->while (Gripper.command==1) & (R550_GripperCommands==1) repeat
		Q4T(task)->currentStep = (void *)&currentLine[253];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0143
		goto __0143;
// [0154]
__0143:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 20->while (Gripper.command==1) & (R550_GripperCommands==1) repeat
		Q4T(task)->currentStep = (void *)&currentLine[254]; lineYield(task,254);
		// STORE 52 TO REG#36991
		R36991 = 52;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0145
		if (process_CTABLE(R36991, task) == 0) goto __0140;
		// GOTO __0144
		goto __0144;
// [0155]
__0144:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 21->running5 = true
		Q4T(task)->currentStep = (void *)&currentLine[255]; lineYield(task,255);
		// STORE 164 TO REG#36990
		process_ATABLE(164, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0143
		goto __0143;
// [0156]
__0140:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0146
		goto __0146;
// [0157]
__0146:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 27->if (R550_GripperCommands)==3 | (R550_GripperCommands)==4 then 
		Q4T(task)->currentStep = (void *)&currentLine[256]; lineYield(task,256);
		// STORE 53 TO REG#36991
		R36991 = 53;
		// IF REG#36991<>0 GOTO __0147
		if (process_CTABLE(R36991, task) != 0) goto __0147;
		// GOTO __0148
		goto __0148;
// [0158]
__0147:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 29->Gripper.Maxspeed = R541_Speed
		Q4T(task)->currentStep = (void *)&currentLine[257]; lineYield(task,257);
		// STORE 165 TO REG#36990
		process_ATABLE(165, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 30->Gripper.Accel = R542_Accel
		Q4T(task)->currentStep = (void *)&currentLine[258]; lineYield(task,258);
		// STORE 166 TO REG#36990
		process_ATABLE(166, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 31->Gripper.Decel = R543_Decel
		Q4T(task)->currentStep = (void *)&currentLine[259]; lineYield(task,259);
		// STORE 167 TO REG#36990
		process_ATABLE(167, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 33->Gripper.command = (R550_GripperCommands)
		Q4T(task)->currentStep = (void *)&currentLine[260]; lineYield(task,260);
		// STORE 168 TO REG#36990
		process_ATABLE(168, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 35->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[261];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 169 TO REG#36990
		process_ATABLE(169, task); start_of_step_timeout_flag = 0;
		// GOTO __0149
		goto __0149;
// [0159]
__0149:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 35->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[262]; lineYield(task,262);
		// STORE 54 TO REG#36991
		R36991 = 54;
		// IF REG#36991=0 GOTO __0150
		if (process_CTABLE(R36991, task) == 0) goto __0150;
		// GOTO __0149
		goto __0149;
// [0160]
__0150:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 36->while Gripper.command==(R550_GripperCommands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[263];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0151
		goto __0151;
// [0161]
__0151:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 36->while Gripper.command==(R550_GripperCommands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[264]; lineYield(task,264);
		// STORE 55 TO REG#36991
		R36991 = 55;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0153
		if (process_CTABLE(R36991, task) == 0) goto __0148;
		// GOTO __0152
		goto __0152;
// [0162]
__0152:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 37->running5 = true
		Q4T(task)->currentStep = (void *)&currentLine[265]; lineYield(task,265);
		// STORE 170 TO REG#36990
		process_ATABLE(170, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0151
		goto __0151;
// [0163]
__0148:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0154
		goto __0154;
// [0164]
__0154:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 42->if (R550_GripperCommands)==5 then 
		Q4T(task)->currentStep = (void *)&currentLine[266]; lineYield(task,266);
		// STORE 56 TO REG#36991
		R36991 = 56;
		// IF REG#36991<>0 GOTO __0155
		if (process_CTABLE(R36991, task) != 0) goto __0155;
		// GOTO __0156
		goto __0156;
// [0165]
__0155:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 43->Gripper.Maxspeed = R541_Speed
		Q4T(task)->currentStep = (void *)&currentLine[267]; lineYield(task,267);
		// STORE 171 TO REG#36990
		process_ATABLE(171, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 44->Gripper.Accel = R542_Accel
		Q4T(task)->currentStep = (void *)&currentLine[268]; lineYield(task,268);
		// STORE 172 TO REG#36990
		process_ATABLE(172, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 45->Gripper.Decel = R533_Decel
		Q4T(task)->currentStep = (void *)&currentLine[269]; lineYield(task,269);
		// STORE 173 TO REG#36990
		process_ATABLE(173, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 46->Gripper.Target = R544_Target
		Q4T(task)->currentStep = (void *)&currentLine[270]; lineYield(task,270);
		// STORE 174 TO REG#36990
		process_ATABLE(174, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 47->Gripper.OffsetHome = R545_HomeOffset
		Q4T(task)->currentStep = (void *)&currentLine[271]; lineYield(task,271);
		// STORE 175 TO REG#36990
		process_ATABLE(175, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 48->Gripper.command = 5
		Q4T(task)->currentStep = (void *)&currentLine[272]; lineYield(task,272);
		// STORE 176 TO REG#36990
		process_ATABLE(176, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 50->while Gripper.command==5 & (R550_GripperCommands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[273];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0157
		goto __0157;
// [0166]
__0157:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 50->while Gripper.command==5 & (R550_GripperCommands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[274]; lineYield(task,274);
		// STORE 57 TO REG#36991
		R36991 = 57;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0159
		if (process_CTABLE(R36991, task) == 0) goto __0156;
		// GOTO __0158
		goto __0158;
// [0167]
__0158:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 51->running5 = true
		Q4T(task)->currentStep = (void *)&currentLine[275]; lineYield(task,275);
		// STORE 177 TO REG#36990
		process_ATABLE(177, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0157
		goto __0157;
// [0168]
__0156:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0160
		goto __0160;
// [0169]
__0160:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 57->if ((R550_GripperCommands)==0 & running5==true) then 
		Q4T(task)->currentStep = (void *)&currentLine[276]; lineYield(task,276);
		// STORE 58 TO REG#36991
		R36991 = 58;
		// IF REG#36991<>0 GOTO __0161
		if (process_CTABLE(R36991, task) != 0) goto __0161;
		// GOTO __0162
		goto __0162;
// [0170]
__0161:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 58->Gripper.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[277]; lineYield(task,277);
		// STORE 178 TO REG#36990
		process_ATABLE(178, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 59->running5 = false
		Q4T(task)->currentStep = (void *)&currentLine[278]; lineYield(task,278);
		// STORE 179 TO REG#36990
		process_ATABLE(179, task);
		// GOTO __0162
		goto __0162;
// [0171]
__0162:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0163
		goto __0163;
// [0172]
__0163:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 62->if ((R550_GripperCommands)==6 | (R550_GripperCommands)==7) then 
		Q4T(task)->currentStep = (void *)&currentLine[279]; lineYield(task,279);
		// STORE 59 TO REG#36991
		R36991 = 59;
		// IF REG#36991<>0 GOTO __0164
		if (process_CTABLE(R36991, task) != 0) goto __0164;
		// GOTO __0165
		goto __0165;
// [0173]
__0164:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 63->Gripper.command = R550_GripperCommands
		Q4T(task)->currentStep = (void *)&currentLine[280]; lineYield(task,280);
		// STORE 180 TO REG#36990
		process_ATABLE(180, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 64->R550_GripperCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[281]; lineYield(task,281);
		// STORE 181 TO REG#36990
		process_ATABLE(181, task);
		// GOTO __0165
		goto __0165;
// [0174]
__0165:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0166
		goto __0166;
// [0175]
__0166:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 68->if (R550_GripperCommands)==9 then 
		Q4T(task)->currentStep = (void *)&currentLine[282]; lineYield(task,282);
		// STORE 60 TO REG#36991
		R36991 = 60;
		// IF REG#36991<>0 GOTO __0167
		if (process_CTABLE(R36991, task) != 0) goto __0167;
		// GOTO __0168
		goto __0168;
// [0176]
__0167:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 69->Gripper.NewPosition = 0
		Q4T(task)->currentStep = (void *)&currentLine[283]; lineYield(task,283);
		// STORE 182 TO REG#36990
		process_ATABLE(182, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 70->Gripper.command = R550_GripperCommands
		Q4T(task)->currentStep = (void *)&currentLine[284]; lineYield(task,284);
		// STORE 183 TO REG#36990
		process_ATABLE(183, task);
		// MODULE(AxisGripper):STEP(GripperControl):LINE 71->R550_GripperCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[285]; lineYield(task,285);
		// STORE 184 TO REG#36990
		process_ATABLE(184, task);
		// GOTO __0168
		goto __0168;
// [0177]
__0168:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisGripper):STEP(GripperControl):LINE 73->goto GripperControl
		Q4T(task)->currentStep = (void *)&currentLine[286]; lineYield(task,286);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisGripper_GripperControl
		goto AxisGripper_GripperControl;
// [0178]
AxisEmpty1:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisEmpty1_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):LINE 2->goto Init
		Q4T(task)->currentStep = (void *)&currentLine[287]; lineYield(task,287);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisEmpty1_Init
		goto AxisEmpty1_Init;
// [0179]
AxisEmpty1_Init:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisEmpty1_Init_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Init):LINE 2->start EmptyAxis1 MaxonMotion0
		Q4T(task)->currentStep = (void *)&currentLine[288]; lineYield(task,288);
		// STORE 185 TO REG#36990
		process_ATABLE(185, task);
		// MODULE(AxisEmpty1):STEP(Init):LINE 4->EmptyAxis1.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[289]; lineYield(task,289);
		// STORE 186 TO REG#36990
		process_ATABLE(186, task);
		// MODULE(AxisEmpty1):STEP(Init):LINE 5->R570_Empty1Commands = 0
		Q4T(task)->currentStep = (void *)&currentLine[290]; lineYield(task,290);
		// STORE 187 TO REG#36990
		process_ATABLE(187, task);
		// MODULE(AxisEmpty1):STEP(Init):LINE 9->goto Empty1Control
		Q4T(task)->currentStep = (void *)&currentLine[291]; lineYield(task,291);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisEmpty1_Empty1Control
		goto AxisEmpty1_Empty1Control;
// [0180]
AxisEmpty1_Empty1Control:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisEmpty1_Empty1Control_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0169
		goto __0169;
// [0181]
__0169:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 10->if (R570_Empty1Commands)==1 then 
		Q4T(task)->currentStep = (void *)&currentLine[292]; lineYield(task,292);
		// STORE 61 TO REG#36991
		R36991 = 61;
		// IF REG#36991<>0 GOTO __0170
		if (process_CTABLE(R36991, task) != 0) goto __0170;
		// GOTO __0171
		goto __0171;
// [0182]
__0170:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 12->EmptyAxis1.Maxspeed = R561_Speed
		Q4T(task)->currentStep = (void *)&currentLine[293]; lineYield(task,293);
		// STORE 188 TO REG#36990
		process_ATABLE(188, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 13->EmptyAxis1.Accel = R562_Accel
		Q4T(task)->currentStep = (void *)&currentLine[294]; lineYield(task,294);
		// STORE 189 TO REG#36990
		process_ATABLE(189, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 14->EmptyAxis1.Decel = R563_Decel
		Q4T(task)->currentStep = (void *)&currentLine[295]; lineYield(task,295);
		// STORE 190 TO REG#36990
		process_ATABLE(190, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 15->EmptyAxis1.Target = R564_Target
		Q4T(task)->currentStep = (void *)&currentLine[296]; lineYield(task,296);
		// STORE 191 TO REG#36990
		process_ATABLE(191, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 17->EmptyAxis1.command = (R570_Empty1Commands)
		Q4T(task)->currentStep = (void *)&currentLine[297]; lineYield(task,297);
		// STORE 192 TO REG#36990
		process_ATABLE(192, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 19->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[298];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 193 TO REG#36990
		process_ATABLE(193, task); start_of_step_timeout_flag = 0;
		// GOTO __0172
		goto __0172;
// [0183]
__0172:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 19->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[299]; lineYield(task,299);
		// STORE 62 TO REG#36991
		R36991 = 62;
		// IF REG#36991=0 GOTO __0173
		if (process_CTABLE(R36991, task) == 0) goto __0173;
		// GOTO __0172
		goto __0172;
// [0184]
__0173:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 20->while (EmptyAxis1.command==1) & (R570_Empty1Commands==1) repeat
		Q4T(task)->currentStep = (void *)&currentLine[300];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0174
		goto __0174;
// [0185]
__0174:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 20->while (EmptyAxis1.command==1) & (R570_Empty1Commands==1) repeat
		Q4T(task)->currentStep = (void *)&currentLine[301]; lineYield(task,301);
		// STORE 63 TO REG#36991
		R36991 = 63;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0176
		if (process_CTABLE(R36991, task) == 0) goto __0171;
		// GOTO __0175
		goto __0175;
// [0186]
__0175:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 21->running7 = true
		Q4T(task)->currentStep = (void *)&currentLine[302]; lineYield(task,302);
		// STORE 194 TO REG#36990
		process_ATABLE(194, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0174
		goto __0174;
// [0187]
__0171:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0177
		goto __0177;
// [0188]
__0177:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 27->if (R570_Empty1Commands)==3 | (R570_Empty1Commands)==4 then 
		Q4T(task)->currentStep = (void *)&currentLine[303]; lineYield(task,303);
		// STORE 64 TO REG#36991
		R36991 = 64;
		// IF REG#36991<>0 GOTO __0178
		if (process_CTABLE(R36991, task) != 0) goto __0178;
		// GOTO __0179
		goto __0179;
// [0189]
__0178:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 29->EmptyAxis1.Maxspeed = R561_Speed
		Q4T(task)->currentStep = (void *)&currentLine[304]; lineYield(task,304);
		// STORE 195 TO REG#36990
		process_ATABLE(195, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 30->EmptyAxis1.Accel = R562_Accel
		Q4T(task)->currentStep = (void *)&currentLine[305]; lineYield(task,305);
		// STORE 196 TO REG#36990
		process_ATABLE(196, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 31->EmptyAxis1.Decel = R563_Decel
		Q4T(task)->currentStep = (void *)&currentLine[306]; lineYield(task,306);
		// STORE 197 TO REG#36990
		process_ATABLE(197, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 33->EmptyAxis1.command = (R570_Empty1Commands)
		Q4T(task)->currentStep = (void *)&currentLine[307]; lineYield(task,307);
		// STORE 198 TO REG#36990
		process_ATABLE(198, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 35->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[308];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 199 TO REG#36990
		process_ATABLE(199, task); start_of_step_timeout_flag = 0;
		// GOTO __0180
		goto __0180;
// [0190]
__0180:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 35->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[309]; lineYield(task,309);
		// STORE 65 TO REG#36991
		R36991 = 65;
		// IF REG#36991=0 GOTO __0181
		if (process_CTABLE(R36991, task) == 0) goto __0181;
		// GOTO __0180
		goto __0180;
// [0191]
__0181:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 36->while EmptyAxis1.command==(R570_Empty1Commands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[310];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0182
		goto __0182;
// [0192]
__0182:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 36->while EmptyAxis1.command==(R570_Empty1Commands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[311]; lineYield(task,311);
		// STORE 66 TO REG#36991
		R36991 = 66;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0184
		if (process_CTABLE(R36991, task) == 0) goto __0179;
		// GOTO __0183
		goto __0183;
// [0193]
__0183:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 37->running7 = true
		Q4T(task)->currentStep = (void *)&currentLine[312]; lineYield(task,312);
		// STORE 200 TO REG#36990
		process_ATABLE(200, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0182
		goto __0182;
// [0194]
__0179:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0185
		goto __0185;
// [0195]
__0185:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 42->if (R570_Empty1Commands)==5 then 
		Q4T(task)->currentStep = (void *)&currentLine[313]; lineYield(task,313);
		// STORE 67 TO REG#36991
		R36991 = 67;
		// IF REG#36991<>0 GOTO __0186
		if (process_CTABLE(R36991, task) != 0) goto __0186;
		// GOTO __0187
		goto __0187;
// [0196]
__0186:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 43->EmptyAxis1.Maxspeed = R561_Speed
		Q4T(task)->currentStep = (void *)&currentLine[314]; lineYield(task,314);
		// STORE 201 TO REG#36990
		process_ATABLE(201, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 44->EmptyAxis1.Accel = R562_Accel
		Q4T(task)->currentStep = (void *)&currentLine[315]; lineYield(task,315);
		// STORE 202 TO REG#36990
		process_ATABLE(202, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 45->EmptyAxis1.Decel = R563_Decel
		Q4T(task)->currentStep = (void *)&currentLine[316]; lineYield(task,316);
		// STORE 203 TO REG#36990
		process_ATABLE(203, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 46->EmptyAxis1.Target = R564_Target
		Q4T(task)->currentStep = (void *)&currentLine[317]; lineYield(task,317);
		// STORE 204 TO REG#36990
		process_ATABLE(204, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 47->EmptyAxis1.OffsetHome = R565_HomeOffset
		Q4T(task)->currentStep = (void *)&currentLine[318]; lineYield(task,318);
		// STORE 205 TO REG#36990
		process_ATABLE(205, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 48->EmptyAxis1.command = 5
		Q4T(task)->currentStep = (void *)&currentLine[319]; lineYield(task,319);
		// STORE 206 TO REG#36990
		process_ATABLE(206, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 50->while EmptyAxis1.command==5 & (R570_Empty1Commands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[320];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0188
		goto __0188;
// [0197]
__0188:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 50->while EmptyAxis1.command==5 & (R570_Empty1Commands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[321]; lineYield(task,321);
		// STORE 68 TO REG#36991
		R36991 = 68;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0190
		if (process_CTABLE(R36991, task) == 0) goto __0187;
		// GOTO __0189
		goto __0189;
// [0198]
__0189:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 51->running7 = true
		Q4T(task)->currentStep = (void *)&currentLine[322]; lineYield(task,322);
		// STORE 207 TO REG#36990
		process_ATABLE(207, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0188
		goto __0188;
// [0199]
__0187:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0191
		goto __0191;
// [0200]
__0191:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 57->if ((R570_Empty1Commands)==0 & running7==true) then 
		Q4T(task)->currentStep = (void *)&currentLine[323]; lineYield(task,323);
		// STORE 69 TO REG#36991
		R36991 = 69;
		// IF REG#36991<>0 GOTO __0192
		if (process_CTABLE(R36991, task) != 0) goto __0192;
		// GOTO __0193
		goto __0193;
// [0201]
__0192:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 58->EmptyAxis1.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[324]; lineYield(task,324);
		// STORE 208 TO REG#36990
		process_ATABLE(208, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 59->running7 = false
		Q4T(task)->currentStep = (void *)&currentLine[325]; lineYield(task,325);
		// STORE 209 TO REG#36990
		process_ATABLE(209, task);
		// GOTO __0193
		goto __0193;
// [0202]
__0193:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0194
		goto __0194;
// [0203]
__0194:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 62->if ((R570_Empty1Commands)==6 | (R570_Empty1Commands)==7) then 
		Q4T(task)->currentStep = (void *)&currentLine[326]; lineYield(task,326);
		// STORE 70 TO REG#36991
		R36991 = 70;
		// IF REG#36991<>0 GOTO __0195
		if (process_CTABLE(R36991, task) != 0) goto __0195;
		// GOTO __0196
		goto __0196;
// [0204]
__0195:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 63->EmptyAxis1.command = R570_Empty1Commands
		Q4T(task)->currentStep = (void *)&currentLine[327]; lineYield(task,327);
		// STORE 210 TO REG#36990
		process_ATABLE(210, task);
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 64->R570_Empty1Commands = 0
		Q4T(task)->currentStep = (void *)&currentLine[328]; lineYield(task,328);
		// STORE 211 TO REG#36990
		process_ATABLE(211, task);
		// GOTO __0196
		goto __0196;
// [0205]
__0196:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty1):STEP(Empty1Control):LINE 69->goto Empty1Control
		Q4T(task)->currentStep = (void *)&currentLine[329]; lineYield(task,329);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisEmpty1_Empty1Control
		goto AxisEmpty1_Empty1Control;
// [0206]
AxisEmpty2:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisEmpty2_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):LINE 2->goto Init
		Q4T(task)->currentStep = (void *)&currentLine[330]; lineYield(task,330);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisEmpty2_Init
		goto AxisEmpty2_Init;
// [0207]
AxisEmpty2_Init:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisEmpty2_Init_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Init):LINE 2->start EmptyAxis2 MaxonMotion0
		Q4T(task)->currentStep = (void *)&currentLine[331]; lineYield(task,331);
		// STORE 212 TO REG#36990
		process_ATABLE(212, task);
		// MODULE(AxisEmpty2):STEP(Init):LINE 4->EmptyAxis2.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[332]; lineYield(task,332);
		// STORE 213 TO REG#36990
		process_ATABLE(213, task);
		// MODULE(AxisEmpty2):STEP(Init):LINE 5->R580_Empty2Commands = 0
		Q4T(task)->currentStep = (void *)&currentLine[333]; lineYield(task,333);
		// STORE 214 TO REG#36990
		process_ATABLE(214, task);
		// MODULE(AxisEmpty2):STEP(Init):LINE 9->goto Empty2Control
		Q4T(task)->currentStep = (void *)&currentLine[334]; lineYield(task,334);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisEmpty2_Empty2Control
		goto AxisEmpty2_Empty2Control;
// [0208]
AxisEmpty2_Empty2Control:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisEmpty2_Empty2Control_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0197
		goto __0197;
// [0209]
__0197:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 10->if (R580_Empty2Commands)==1 then 
		Q4T(task)->currentStep = (void *)&currentLine[335]; lineYield(task,335);
		// STORE 71 TO REG#36991
		R36991 = 71;
		// IF REG#36991<>0 GOTO __0198
		if (process_CTABLE(R36991, task) != 0) goto __0198;
		// GOTO __0199
		goto __0199;
// [0210]
__0198:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 12->EmptyAxis2.Maxspeed = R571_Speed
		Q4T(task)->currentStep = (void *)&currentLine[336]; lineYield(task,336);
		// STORE 215 TO REG#36990
		process_ATABLE(215, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 13->EmptyAxis2.Accel = R572_Accel
		Q4T(task)->currentStep = (void *)&currentLine[337]; lineYield(task,337);
		// STORE 216 TO REG#36990
		process_ATABLE(216, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 14->EmptyAxis2.Decel = R573_Decel
		Q4T(task)->currentStep = (void *)&currentLine[338]; lineYield(task,338);
		// STORE 217 TO REG#36990
		process_ATABLE(217, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 15->EmptyAxis2.Target = R574_Target
		Q4T(task)->currentStep = (void *)&currentLine[339]; lineYield(task,339);
		// STORE 218 TO REG#36990
		process_ATABLE(218, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 17->EmptyAxis2.command = (R580_Empty2Commands)
		Q4T(task)->currentStep = (void *)&currentLine[340]; lineYield(task,340);
		// STORE 219 TO REG#36990
		process_ATABLE(219, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 19->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[341];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 220 TO REG#36990
		process_ATABLE(220, task); start_of_step_timeout_flag = 0;
		// GOTO __0200
		goto __0200;
// [0211]
__0200:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 19->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[342]; lineYield(task,342);
		// STORE 72 TO REG#36991
		R36991 = 72;
		// IF REG#36991=0 GOTO __0201
		if (process_CTABLE(R36991, task) == 0) goto __0201;
		// GOTO __0200
		goto __0200;
// [0212]
__0201:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 20->while (EmptyAxis2.command==1) & (R580_Empty2Commands==1) repeat
		Q4T(task)->currentStep = (void *)&currentLine[343];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0202
		goto __0202;
// [0213]
__0202:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 20->while (EmptyAxis2.command==1) & (R580_Empty2Commands==1) repeat
		Q4T(task)->currentStep = (void *)&currentLine[344]; lineYield(task,344);
		// STORE 73 TO REG#36991
		R36991 = 73;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0204
		if (process_CTABLE(R36991, task) == 0) goto __0199;
		// GOTO __0203
		goto __0203;
// [0214]
__0203:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 21->running8 = true
		Q4T(task)->currentStep = (void *)&currentLine[345]; lineYield(task,345);
		// STORE 221 TO REG#36990
		process_ATABLE(221, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0202
		goto __0202;
// [0215]
__0199:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0205
		goto __0205;
// [0216]
__0205:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 27->if (R580_Empty2Commands)==3 | (R580_Empty2Commands)==4 then 
		Q4T(task)->currentStep = (void *)&currentLine[346]; lineYield(task,346);
		// STORE 74 TO REG#36991
		R36991 = 74;
		// IF REG#36991<>0 GOTO __0206
		if (process_CTABLE(R36991, task) != 0) goto __0206;
		// GOTO __0207
		goto __0207;
// [0217]
__0206:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 29->EmptyAxis2.Maxspeed = R571_Speed
		Q4T(task)->currentStep = (void *)&currentLine[347]; lineYield(task,347);
		// STORE 222 TO REG#36990
		process_ATABLE(222, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 30->EmptyAxis2.Accel = R572_Accel
		Q4T(task)->currentStep = (void *)&currentLine[348]; lineYield(task,348);
		// STORE 223 TO REG#36990
		process_ATABLE(223, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 31->EmptyAxis2.Decel = R573_Decel
		Q4T(task)->currentStep = (void *)&currentLine[349]; lineYield(task,349);
		// STORE 224 TO REG#36990
		process_ATABLE(224, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 33->EmptyAxis2.command = (R580_Empty2Commands)
		Q4T(task)->currentStep = (void *)&currentLine[350]; lineYield(task,350);
		// STORE 225 TO REG#36990
		process_ATABLE(225, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 35->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[351];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 226 TO REG#36990
		process_ATABLE(226, task); start_of_step_timeout_flag = 0;
		// GOTO __0208
		goto __0208;
// [0218]
__0208:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 35->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[352]; lineYield(task,352);
		// STORE 75 TO REG#36991
		R36991 = 75;
		// IF REG#36991=0 GOTO __0209
		if (process_CTABLE(R36991, task) == 0) goto __0209;
		// GOTO __0208
		goto __0208;
// [0219]
__0209:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 36->while EmptyAxis2.command==(R580_Empty2Commands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[353];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0210
		goto __0210;
// [0220]
__0210:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 36->while EmptyAxis2.command==(R580_Empty2Commands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[354]; lineYield(task,354);
		// STORE 76 TO REG#36991
		R36991 = 76;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0212
		if (process_CTABLE(R36991, task) == 0) goto __0207;
		// GOTO __0211
		goto __0211;
// [0221]
__0211:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 37->running8 = true
		Q4T(task)->currentStep = (void *)&currentLine[355]; lineYield(task,355);
		// STORE 227 TO REG#36990
		process_ATABLE(227, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0210
		goto __0210;
// [0222]
__0207:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0213
		goto __0213;
// [0223]
__0213:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 42->if (R580_Empty2Commands)==5 then 
		Q4T(task)->currentStep = (void *)&currentLine[356]; lineYield(task,356);
		// STORE 77 TO REG#36991
		R36991 = 77;
		// IF REG#36991<>0 GOTO __0214
		if (process_CTABLE(R36991, task) != 0) goto __0214;
		// GOTO __0215
		goto __0215;
// [0224]
__0214:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 43->EmptyAxis2.Maxspeed = R571_Speed
		Q4T(task)->currentStep = (void *)&currentLine[357]; lineYield(task,357);
		// STORE 228 TO REG#36990
		process_ATABLE(228, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 44->EmptyAxis2.Accel = R572_Accel
		Q4T(task)->currentStep = (void *)&currentLine[358]; lineYield(task,358);
		// STORE 229 TO REG#36990
		process_ATABLE(229, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 45->EmptyAxis2.Decel = R573_Decel
		Q4T(task)->currentStep = (void *)&currentLine[359]; lineYield(task,359);
		// STORE 230 TO REG#36990
		process_ATABLE(230, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 46->EmptyAxis2.Target = R574_Target
		Q4T(task)->currentStep = (void *)&currentLine[360]; lineYield(task,360);
		// STORE 231 TO REG#36990
		process_ATABLE(231, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 47->EmptyAxis2.OffsetHome = R575_HomeOffset
		Q4T(task)->currentStep = (void *)&currentLine[361]; lineYield(task,361);
		// STORE 232 TO REG#36990
		process_ATABLE(232, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 48->EmptyAxis2.command = 5
		Q4T(task)->currentStep = (void *)&currentLine[362]; lineYield(task,362);
		// STORE 233 TO REG#36990
		process_ATABLE(233, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 50->while EmptyAxis2.command==5 & (R580_Empty2Commands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[363];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0216
		goto __0216;
// [0225]
__0216:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 50->while EmptyAxis2.command==5 & (R580_Empty2Commands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[364]; lineYield(task,364);
		// STORE 78 TO REG#36991
		R36991 = 78;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0218
		if (process_CTABLE(R36991, task) == 0) goto __0215;
		// GOTO __0217
		goto __0217;
// [0226]
__0217:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 51->running8 = true
		Q4T(task)->currentStep = (void *)&currentLine[365]; lineYield(task,365);
		// STORE 234 TO REG#36990
		process_ATABLE(234, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0216
		goto __0216;
// [0227]
__0215:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0219
		goto __0219;
// [0228]
__0219:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 57->if ((R580_Empty2Commands)==0 & running8==true) then 
		Q4T(task)->currentStep = (void *)&currentLine[366]; lineYield(task,366);
		// STORE 79 TO REG#36991
		R36991 = 79;
		// IF REG#36991<>0 GOTO __0220
		if (process_CTABLE(R36991, task) != 0) goto __0220;
		// GOTO __0221
		goto __0221;
// [0229]
__0220:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 58->EmptyAxis2.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[367]; lineYield(task,367);
		// STORE 235 TO REG#36990
		process_ATABLE(235, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 59->running8 = false
		Q4T(task)->currentStep = (void *)&currentLine[368]; lineYield(task,368);
		// STORE 236 TO REG#36990
		process_ATABLE(236, task);
		// GOTO __0221
		goto __0221;
// [0230]
__0221:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0222
		goto __0222;
// [0231]
__0222:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 62->if ((R580_Empty2Commands)==6 | (R580_Empty2Commands)==7) then 
		Q4T(task)->currentStep = (void *)&currentLine[369]; lineYield(task,369);
		// STORE 80 TO REG#36991
		R36991 = 80;
		// IF REG#36991<>0 GOTO __0223
		if (process_CTABLE(R36991, task) != 0) goto __0223;
		// GOTO __0224
		goto __0224;
// [0232]
__0223:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 63->EmptyAxis2.command = R580_Empty2Commands
		Q4T(task)->currentStep = (void *)&currentLine[370]; lineYield(task,370);
		// STORE 237 TO REG#36990
		process_ATABLE(237, task);
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 64->R580_Empty2Commands = 0
		Q4T(task)->currentStep = (void *)&currentLine[371]; lineYield(task,371);
		// STORE 238 TO REG#36990
		process_ATABLE(238, task);
		// GOTO __0224
		goto __0224;
// [0233]
__0224:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty2):STEP(Empty2Control):LINE 69->goto Empty2Control
		Q4T(task)->currentStep = (void *)&currentLine[372]; lineYield(task,372);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisEmpty2_Empty2Control
		goto AxisEmpty2_Empty2Control;
// [0234]
AxisTransferStation:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisTransferStation_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):LINE 2->goto Init
		Q4T(task)->currentStep = (void *)&currentLine[373]; lineYield(task,373);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisTransferStation_Init
		goto AxisTransferStation_Init;
// [0235]
AxisTransferStation_Init:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisTransferStation_Init_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(Init):LINE 2->start TransferStation StepperMotion0
		Q4T(task)->currentStep = (void *)&currentLine[374]; lineYield(task,374);
		// STORE 239 TO REG#36990
		process_ATABLE(239, task);
		// MODULE(AxisTransferStation):STEP(Init):LINE 3->delay = 100
		Q4T(task)->currentStep = (void *)&currentLine[375];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 240 TO REG#36990
		process_ATABLE(240, task); start_of_step_timeout_flag = 0;
		// GOTO __0225
		goto __0225;
// [0236]
__0225:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(Init):LINE 3->delay = 100
		Q4T(task)->currentStep = (void *)&currentLine[376]; lineYield(task,376);
		// STORE 81 TO REG#36991
		R36991 = 81;
		// IF REG#36991=0 GOTO __0226
		if (process_CTABLE(R36991, task) == 0) goto __0226;
		// GOTO __0225
		goto __0225;
// [0237]
__0226:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(Init):LINE 5->TransferStation.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[377]; lineYield(task,377);
		// STORE 241 TO REG#36990
		process_ATABLE(241, task);
		// MODULE(AxisTransferStation):STEP(Init):LINE 6->TransferStation.Axisnum = 9
		Q4T(task)->currentStep = (void *)&currentLine[378]; lineYield(task,378);
		// STORE 242 TO REG#36990
		process_ATABLE(242, task);
		// MODULE(AxisTransferStation):STEP(Init):LINE 8->R590_TransferStationCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[379]; lineYield(task,379);
		// STORE 243 TO REG#36990
		process_ATABLE(243, task);
		// MODULE(AxisTransferStation):STEP(Init):LINE 12->goto CableElevfControl
		Q4T(task)->currentStep = (void *)&currentLine[380]; lineYield(task,380);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisTransferStation_CableElevfControl
		goto AxisTransferStation_CableElevfControl;
// [0238]
AxisTransferStation_CableElevfControl:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisTransferStation_CableElevfControl_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0227
		goto __0227;
// [0239]
__0227:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 10->if (R590_TransferStationCommands)==1 then 
		Q4T(task)->currentStep = (void *)&currentLine[381]; lineYield(task,381);
		// STORE 82 TO REG#36991
		R36991 = 82;
		// IF REG#36991<>0 GOTO __0228
		if (process_CTABLE(R36991, task) != 0) goto __0228;
		// GOTO __0229
		goto __0229;
// [0240]
__0228:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 12->TransferStation.Maxspeed = R581_Speed
		Q4T(task)->currentStep = (void *)&currentLine[382]; lineYield(task,382);
		// STORE 244 TO REG#36990
		process_ATABLE(244, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 13->TransferStation.Accel = R582_Accel
		Q4T(task)->currentStep = (void *)&currentLine[383]; lineYield(task,383);
		// STORE 245 TO REG#36990
		process_ATABLE(245, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 14->TransferStation.Decel = R583_Decel
		Q4T(task)->currentStep = (void *)&currentLine[384]; lineYield(task,384);
		// STORE 246 TO REG#36990
		process_ATABLE(246, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 15->TransferStation.Target = R584_Target
		Q4T(task)->currentStep = (void *)&currentLine[385]; lineYield(task,385);
		// STORE 247 TO REG#36990
		process_ATABLE(247, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 17->TransferStation.command = (R590_TransferStationCommands)
		Q4T(task)->currentStep = (void *)&currentLine[386]; lineYield(task,386);
		// STORE 248 TO REG#36990
		process_ATABLE(248, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 19->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[387];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 249 TO REG#36990
		process_ATABLE(249, task); start_of_step_timeout_flag = 0;
		// GOTO __0230
		goto __0230;
// [0241]
__0230:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 19->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[388]; lineYield(task,388);
		// STORE 83 TO REG#36991
		R36991 = 83;
		// IF REG#36991=0 GOTO __0231
		if (process_CTABLE(R36991, task) == 0) goto __0231;
		// GOTO __0230
		goto __0230;
// [0242]
__0231:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 20->while (TransferStation.command==1) & (R590_TransferStationCommands==1) repeat
		Q4T(task)->currentStep = (void *)&currentLine[389];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0232
		goto __0232;
// [0243]
__0232:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 20->while (TransferStation.command==1) & (R590_TransferStationCommands==1) repeat
		Q4T(task)->currentStep = (void *)&currentLine[390]; lineYield(task,390);
		// STORE 84 TO REG#36991
		R36991 = 84;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0234
		if (process_CTABLE(R36991, task) == 0) goto __0229;
		// GOTO __0233
		goto __0233;
// [0244]
__0233:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 21->running9 = true
		Q4T(task)->currentStep = (void *)&currentLine[391]; lineYield(task,391);
		// STORE 250 TO REG#36990
		process_ATABLE(250, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0232
		goto __0232;
// [0245]
__0229:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0235
		goto __0235;
// [0246]
__0235:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 27->if (R590_TransferStationCommands)==3 | (R590_TransferStationCommands)==4 then 
		Q4T(task)->currentStep = (void *)&currentLine[392]; lineYield(task,392);
		// STORE 85 TO REG#36991
		R36991 = 85;
		// IF REG#36991<>0 GOTO __0236
		if (process_CTABLE(R36991, task) != 0) goto __0236;
		// GOTO __0237
		goto __0237;
// [0247]
__0236:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 29->TransferStation.Maxspeed = R581_Speed
		Q4T(task)->currentStep = (void *)&currentLine[393]; lineYield(task,393);
		// STORE 251 TO REG#36990
		process_ATABLE(251, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 30->TransferStation.Accel = R582_Accel
		Q4T(task)->currentStep = (void *)&currentLine[394]; lineYield(task,394);
		// STORE 252 TO REG#36990
		process_ATABLE(252, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 31->TransferStation.Decel = R583_Decel
		Q4T(task)->currentStep = (void *)&currentLine[395]; lineYield(task,395);
		// STORE 253 TO REG#36990
		process_ATABLE(253, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 33->TransferStation.command = (R590_TransferStationCommands)
		Q4T(task)->currentStep = (void *)&currentLine[396]; lineYield(task,396);
		// STORE 254 TO REG#36990
		process_ATABLE(254, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 35->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[397];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 255 TO REG#36990
		process_ATABLE(255, task); start_of_step_timeout_flag = 0;
		// GOTO __0238
		goto __0238;
// [0248]
__0238:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 35->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[398]; lineYield(task,398);
		// STORE 86 TO REG#36991
		R36991 = 86;
		// IF REG#36991=0 GOTO __0239
		if (process_CTABLE(R36991, task) == 0) goto __0239;
		// GOTO __0238
		goto __0238;
// [0249]
__0239:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 36->while TransferStation.command==(R590_TransferStationCommands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[399];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0240
		goto __0240;
// [0250]
__0240:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 36->while TransferStation.command==(R590_TransferStationCommands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[400]; lineYield(task,400);
		// STORE 87 TO REG#36991
		R36991 = 87;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0242
		if (process_CTABLE(R36991, task) == 0) goto __0237;
		// GOTO __0241
		goto __0241;
// [0251]
__0241:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 37->running9 = true
		Q4T(task)->currentStep = (void *)&currentLine[401]; lineYield(task,401);
		// STORE 256 TO REG#36990
		process_ATABLE(256, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0240
		goto __0240;
// [0252]
__0237:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0243
		goto __0243;
// [0253]
__0243:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 42->if (R590_TransferStationCommands)==5 then 
		Q4T(task)->currentStep = (void *)&currentLine[402]; lineYield(task,402);
		// STORE 88 TO REG#36991
		R36991 = 88;
		// IF REG#36991<>0 GOTO __0244
		if (process_CTABLE(R36991, task) != 0) goto __0244;
		// GOTO __0245
		goto __0245;
// [0254]
__0244:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 43->TransferStation.Maxspeed = R581_Speed
		Q4T(task)->currentStep = (void *)&currentLine[403]; lineYield(task,403);
		// STORE 257 TO REG#36990
		process_ATABLE(257, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 44->TransferStation.Accel = R582_Accel
		Q4T(task)->currentStep = (void *)&currentLine[404]; lineYield(task,404);
		// STORE 258 TO REG#36990
		process_ATABLE(258, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 45->TransferStation.Decel = R583_Decel
		Q4T(task)->currentStep = (void *)&currentLine[405]; lineYield(task,405);
		// STORE 259 TO REG#36990
		process_ATABLE(259, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 46->TransferStation.Target = R584_Target
		Q4T(task)->currentStep = (void *)&currentLine[406]; lineYield(task,406);
		// STORE 260 TO REG#36990
		process_ATABLE(260, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 47->TransferStation.OffsetHome = R585_HomeOffset
		Q4T(task)->currentStep = (void *)&currentLine[407]; lineYield(task,407);
		// STORE 261 TO REG#36990
		process_ATABLE(261, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 48->TransferStation.command = 5
		Q4T(task)->currentStep = (void *)&currentLine[408]; lineYield(task,408);
		// STORE 262 TO REG#36990
		process_ATABLE(262, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 50->while TransferStation.command==5 & (R590_TransferStationCommands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[409];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0246
		goto __0246;
// [0255]
__0246:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 50->while TransferStation.command==5 & (R590_TransferStationCommands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[410]; lineYield(task,410);
		// STORE 89 TO REG#36991
		R36991 = 89;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0248
		if (process_CTABLE(R36991, task) == 0) goto __0245;
		// GOTO __0247
		goto __0247;
// [0256]
__0247:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 51->running9 = true
		Q4T(task)->currentStep = (void *)&currentLine[411]; lineYield(task,411);
		// STORE 263 TO REG#36990
		process_ATABLE(263, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0246
		goto __0246;
// [0257]
__0245:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0249
		goto __0249;
// [0258]
__0249:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 57->if ((R590_TransferStationCommands)==0 & running9==true) then 
		Q4T(task)->currentStep = (void *)&currentLine[412]; lineYield(task,412);
		// STORE 90 TO REG#36991
		R36991 = 90;
		// IF REG#36991<>0 GOTO __0250
		if (process_CTABLE(R36991, task) != 0) goto __0250;
		// GOTO __0251
		goto __0251;
// [0259]
__0250:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 58->TransferStation.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[413]; lineYield(task,413);
		// STORE 264 TO REG#36990
		process_ATABLE(264, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 59->running9 = false
		Q4T(task)->currentStep = (void *)&currentLine[414]; lineYield(task,414);
		// STORE 265 TO REG#36990
		process_ATABLE(265, task);
		// GOTO __0251
		goto __0251;
// [0260]
__0251:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0252
		goto __0252;
// [0261]
__0252:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 62->if ((R590_TransferStationCommands)==6 | (R590_TransferStationCommands)==7) then 
		Q4T(task)->currentStep = (void *)&currentLine[415]; lineYield(task,415);
		// STORE 91 TO REG#36991
		R36991 = 91;
		// IF REG#36991<>0 GOTO __0253
		if (process_CTABLE(R36991, task) != 0) goto __0253;
		// GOTO __0254
		goto __0254;
// [0262]
__0253:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 63->TransferStation.command = R590_TransferStationCommands
		Q4T(task)->currentStep = (void *)&currentLine[416]; lineYield(task,416);
		// STORE 266 TO REG#36990
		process_ATABLE(266, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 64->R590_TransferStationCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[417]; lineYield(task,417);
		// STORE 267 TO REG#36990
		process_ATABLE(267, task);
		// GOTO __0254
		goto __0254;
// [0263]
__0254:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0255
		goto __0255;
// [0264]
__0255:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 66->if (R590_TransferStationCommands)==8 then 
		Q4T(task)->currentStep = (void *)&currentLine[418]; lineYield(task,418);
		// STORE 92 TO REG#36991
		R36991 = 92;
		// IF REG#36991<>0 GOTO __0256
		if (process_CTABLE(R36991, task) != 0) goto __0256;
		// GOTO __0257
		goto __0257;
// [0265]
__0256:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 67->TransferStation.command = R590_TransferStationCommands
		Q4T(task)->currentStep = (void *)&currentLine[419]; lineYield(task,419);
		// STORE 268 TO REG#36990
		process_ATABLE(268, task);
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 68->delay = 10
		Q4T(task)->currentStep = (void *)&currentLine[420];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 269 TO REG#36990
		process_ATABLE(269, task); start_of_step_timeout_flag = 0;
		// GOTO __0258
		goto __0258;
// [0266]
__0258:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 68->delay = 10
		Q4T(task)->currentStep = (void *)&currentLine[421]; lineYield(task,421);
		// STORE 93 TO REG#36991
		R36991 = 93;
		// IF REG#36991=0 GOTO __0259
		if (process_CTABLE(R36991, task) == 0) goto __0259;
		// GOTO __0258
		goto __0258;
// [0267]
__0259:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 69->R590_TransferStationCommands = 0
		Q4T(task)->currentStep = (void *)&currentLine[422]; lineYield(task,422);
		// STORE 270 TO REG#36990
		process_ATABLE(270, task);
		// GOTO __0257
		goto __0257;
// [0268]
__0257:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 73->goto CableElevfControl
		Q4T(task)->currentStep = (void *)&currentLine[423]; lineYield(task,423);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisTransferStation_CableElevfControl
		goto AxisTransferStation_CableElevfControl;
// [0269]
AxisEmpty3:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisEmpty3_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):LINE 2->goto Init
		Q4T(task)->currentStep = (void *)&currentLine[424]; lineYield(task,424);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisEmpty3_Init
		goto AxisEmpty3_Init;
// [0270]
AxisEmpty3_Init:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisEmpty3_Init_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Init):LINE 2->start EmptyAxis3 StepperMotion0
		Q4T(task)->currentStep = (void *)&currentLine[425]; lineYield(task,425);
		// STORE 271 TO REG#36990
		process_ATABLE(271, task);
		// MODULE(AxisEmpty3):STEP(Init):LINE 3->delay = 100
		Q4T(task)->currentStep = (void *)&currentLine[426];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 272 TO REG#36990
		process_ATABLE(272, task); start_of_step_timeout_flag = 0;
		// GOTO __0260
		goto __0260;
// [0271]
__0260:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Init):LINE 3->delay = 100
		Q4T(task)->currentStep = (void *)&currentLine[427]; lineYield(task,427);
		// STORE 94 TO REG#36991
		R36991 = 94;
		// IF REG#36991=0 GOTO __0261
		if (process_CTABLE(R36991, task) == 0) goto __0261;
		// GOTO __0260
		goto __0260;
// [0272]
__0261:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Init):LINE 5->EmptyAxis3.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[428]; lineYield(task,428);
		// STORE 273 TO REG#36990
		process_ATABLE(273, task);
		// MODULE(AxisEmpty3):STEP(Init):LINE 6->EmptyAxis3.Axisnum = 10
		Q4T(task)->currentStep = (void *)&currentLine[429]; lineYield(task,429);
		// STORE 274 TO REG#36990
		process_ATABLE(274, task);
		// MODULE(AxisEmpty3):STEP(Init):LINE 8->R600_Empty3Commands = 0
		Q4T(task)->currentStep = (void *)&currentLine[430]; lineYield(task,430);
		// STORE 275 TO REG#36990
		process_ATABLE(275, task);
		// MODULE(AxisEmpty3):STEP(Init):LINE 12->goto Empty3Control
		Q4T(task)->currentStep = (void *)&currentLine[431]; lineYield(task,431);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisEmpty3_Empty3Control
		goto AxisEmpty3_Empty3Control;
// [0273]
AxisEmpty3_Empty3Control:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
AxisEmpty3_Empty3Control_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0262
		goto __0262;
// [0274]
__0262:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 11->if (R600_Empty3Commands)==1 then 
		Q4T(task)->currentStep = (void *)&currentLine[432]; lineYield(task,432);
		// STORE 95 TO REG#36991
		R36991 = 95;
		// IF REG#36991<>0 GOTO __0263
		if (process_CTABLE(R36991, task) != 0) goto __0263;
		// GOTO __0264
		goto __0264;
// [0275]
__0263:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 13->EmptyAxis3.Maxspeed = R591_Speed
		Q4T(task)->currentStep = (void *)&currentLine[433]; lineYield(task,433);
		// STORE 276 TO REG#36990
		process_ATABLE(276, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 14->EmptyAxis3.Accel = R592_Accel
		Q4T(task)->currentStep = (void *)&currentLine[434]; lineYield(task,434);
		// STORE 277 TO REG#36990
		process_ATABLE(277, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 15->EmptyAxis3.Decel = R593_Decel
		Q4T(task)->currentStep = (void *)&currentLine[435]; lineYield(task,435);
		// STORE 278 TO REG#36990
		process_ATABLE(278, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 16->EmptyAxis3.Target = R594_Target
		Q4T(task)->currentStep = (void *)&currentLine[436]; lineYield(task,436);
		// STORE 279 TO REG#36990
		process_ATABLE(279, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 18->EmptyAxis3.command = (R600_Empty3Commands)
		Q4T(task)->currentStep = (void *)&currentLine[437]; lineYield(task,437);
		// STORE 280 TO REG#36990
		process_ATABLE(280, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 19->delay = 20
		Q4T(task)->currentStep = (void *)&currentLine[438];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 281 TO REG#36990
		process_ATABLE(281, task); start_of_step_timeout_flag = 0;
		// GOTO __0265
		goto __0265;
// [0276]
__0265:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 19->delay = 20
		Q4T(task)->currentStep = (void *)&currentLine[439]; lineYield(task,439);
		// STORE 96 TO REG#36991
		R36991 = 96;
		// IF REG#36991=0 GOTO __0266
		if (process_CTABLE(R36991, task) == 0) goto __0266;
		// GOTO __0265
		goto __0265;
// [0277]
__0266:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 20->while (EmptyAxis3.command==1) & (R600_Empty3Commands==1) repeat
		Q4T(task)->currentStep = (void *)&currentLine[440];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0267
		goto __0267;
// [0278]
__0267:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 20->while (EmptyAxis3.command==1) & (R600_Empty3Commands==1) repeat
		Q4T(task)->currentStep = (void *)&currentLine[441]; lineYield(task,441);
		// STORE 97 TO REG#36991
		R36991 = 97;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0269
		if (process_CTABLE(R36991, task) == 0) goto __0264;
		// GOTO __0268
		goto __0268;
// [0279]
__0268:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 21->running10 = true
		Q4T(task)->currentStep = (void *)&currentLine[442]; lineYield(task,442);
		// STORE 282 TO REG#36990
		process_ATABLE(282, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0267
		goto __0267;
// [0280]
__0264:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0270
		goto __0270;
// [0281]
__0270:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 27->if (R600_Empty3Commands)==3 | (R600_Empty3Commands)==4 then 
		Q4T(task)->currentStep = (void *)&currentLine[443]; lineYield(task,443);
		// STORE 98 TO REG#36991
		R36991 = 98;
		// IF REG#36991<>0 GOTO __0271
		if (process_CTABLE(R36991, task) != 0) goto __0271;
		// GOTO __0272
		goto __0272;
// [0282]
__0271:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 29->EmptyAxis3.Maxspeed = R591_Speed
		Q4T(task)->currentStep = (void *)&currentLine[444]; lineYield(task,444);
		// STORE 283 TO REG#36990
		process_ATABLE(283, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 30->EmptyAxis3.Accel = R592_Accel
		Q4T(task)->currentStep = (void *)&currentLine[445]; lineYield(task,445);
		// STORE 284 TO REG#36990
		process_ATABLE(284, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 31->EmptyAxis3.Decel = R593_Decel
		Q4T(task)->currentStep = (void *)&currentLine[446]; lineYield(task,446);
		// STORE 285 TO REG#36990
		process_ATABLE(285, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 33->EmptyAxis3.command = (R600_Empty3Commands)
		Q4T(task)->currentStep = (void *)&currentLine[447]; lineYield(task,447);
		// STORE 286 TO REG#36990
		process_ATABLE(286, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 34->delay = 20
		Q4T(task)->currentStep = (void *)&currentLine[448];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 287 TO REG#36990
		process_ATABLE(287, task); start_of_step_timeout_flag = 0;
		// GOTO __0273
		goto __0273;
// [0283]
__0273:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 34->delay = 20
		Q4T(task)->currentStep = (void *)&currentLine[449]; lineYield(task,449);
		// STORE 99 TO REG#36991
		R36991 = 99;
		// IF REG#36991=0 GOTO __0274
		if (process_CTABLE(R36991, task) == 0) goto __0274;
		// GOTO __0273
		goto __0273;
// [0284]
__0274:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 35->while EmptyAxis3.command==(R600_Empty3Commands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[450];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0275
		goto __0275;
// [0285]
__0275:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 35->while EmptyAxis3.command==(R600_Empty3Commands) repeat
		Q4T(task)->currentStep = (void *)&currentLine[451]; lineYield(task,451);
		// STORE 100 TO REG#36991
		R36991 = 100;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0277
		if (process_CTABLE(R36991, task) == 0) goto __0272;
		// GOTO __0276
		goto __0276;
// [0286]
__0276:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 36->running10 = true
		Q4T(task)->currentStep = (void *)&currentLine[452]; lineYield(task,452);
		// STORE 288 TO REG#36990
		process_ATABLE(288, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0275
		goto __0275;
// [0287]
__0272:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0278
		goto __0278;
// [0288]
__0278:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 41->if (R600_Empty3Commands)==5 then 
		Q4T(task)->currentStep = (void *)&currentLine[453]; lineYield(task,453);
		// STORE 101 TO REG#36991
		R36991 = 101;
		// IF REG#36991<>0 GOTO __0279
		if (process_CTABLE(R36991, task) != 0) goto __0279;
		// GOTO __0280
		goto __0280;
// [0289]
__0279:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 42->EmptyAxis3.Maxspeed = R591_Speed
		Q4T(task)->currentStep = (void *)&currentLine[454]; lineYield(task,454);
		// STORE 289 TO REG#36990
		process_ATABLE(289, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 43->EmptyAxis3.Accel = R592_Accel
		Q4T(task)->currentStep = (void *)&currentLine[455]; lineYield(task,455);
		// STORE 290 TO REG#36990
		process_ATABLE(290, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 44->EmptyAxis3.Decel = R593_Decel
		Q4T(task)->currentStep = (void *)&currentLine[456]; lineYield(task,456);
		// STORE 291 TO REG#36990
		process_ATABLE(291, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 45->EmptyAxis3.Target = R594_Target
		Q4T(task)->currentStep = (void *)&currentLine[457]; lineYield(task,457);
		// STORE 292 TO REG#36990
		process_ATABLE(292, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 46->EmptyAxis3.OffsetHome = R595_HomeOffset
		Q4T(task)->currentStep = (void *)&currentLine[458]; lineYield(task,458);
		// STORE 293 TO REG#36990
		process_ATABLE(293, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 47->EmptyAxis3.command = 5
		Q4T(task)->currentStep = (void *)&currentLine[459]; lineYield(task,459);
		// STORE 294 TO REG#36990
		process_ATABLE(294, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 49->while EmptyAxis3.command==5 & (R600_Empty3Commands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[460];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0281
		goto __0281;
// [0290]
__0281:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 49->while EmptyAxis3.command==5 & (R600_Empty3Commands)==5 repeat
		Q4T(task)->currentStep = (void *)&currentLine[461]; lineYield(task,461);
		// STORE 102 TO REG#36991
		R36991 = 102;
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// IF REG#36991=0 GOTO __0283
		if (process_CTABLE(R36991, task) == 0) goto __0280;
		// GOTO __0282
		goto __0282;
// [0291]
__0282:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 50->running10 = true
		Q4T(task)->currentStep = (void *)&currentLine[462]; lineYield(task,462);
		// STORE 295 TO REG#36990
		process_ATABLE(295, task);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO __0281
		goto __0281;
// [0292]
__0280:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0284
		goto __0284;
// [0293]
__0284:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 56->if ((R600_Empty3Commands)==0 & running10==true) then 
		Q4T(task)->currentStep = (void *)&currentLine[463]; lineYield(task,463);
		// STORE 103 TO REG#36991
		R36991 = 103;
		// IF REG#36991<>0 GOTO __0285
		if (process_CTABLE(R36991, task) != 0) goto __0285;
		// GOTO __0286
		goto __0286;
// [0294]
__0285:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 57->EmptyAxis3.command = 0
		Q4T(task)->currentStep = (void *)&currentLine[464]; lineYield(task,464);
		// STORE 296 TO REG#36990
		process_ATABLE(296, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 58->running10 = false
		Q4T(task)->currentStep = (void *)&currentLine[465]; lineYield(task,465);
		// STORE 297 TO REG#36990
		process_ATABLE(297, task);
		// GOTO __0286
		goto __0286;
// [0295]
__0286:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0287
		goto __0287;
// [0296]
__0287:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 61->if ((R600_Empty3Commands)==6 | (R600_Empty3Commands)==7) then 
		Q4T(task)->currentStep = (void *)&currentLine[466]; lineYield(task,466);
		// STORE 104 TO REG#36991
		R36991 = 104;
		// IF REG#36991<>0 GOTO __0288
		if (process_CTABLE(R36991, task) != 0) goto __0288;
		// GOTO __0289
		goto __0289;
// [0297]
__0288:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 62->EmptyAxis3.command = R600_Empty3Commands
		Q4T(task)->currentStep = (void *)&currentLine[467]; lineYield(task,467);
		// STORE 298 TO REG#36990
		process_ATABLE(298, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 63->R600_Empty3Commands = 0
		Q4T(task)->currentStep = (void *)&currentLine[468]; lineYield(task,468);
		// STORE 299 TO REG#36990
		process_ATABLE(299, task);
		// GOTO __0289
		goto __0289;
// [0298]
__0289:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// GOTO __0290
		goto __0290;
// [0299]
__0290:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 65->if (R600_Empty3Commands)==8 then 
		Q4T(task)->currentStep = (void *)&currentLine[469]; lineYield(task,469);
		// STORE 105 TO REG#36991
		R36991 = 105;
		// IF REG#36991<>0 GOTO __0291
		if (process_CTABLE(R36991, task) != 0) goto __0291;
		// GOTO __0292
		goto __0292;
// [0300]
__0291:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 66->EmptyAxis3.command = R600_Empty3Commands
		Q4T(task)->currentStep = (void *)&currentLine[470]; lineYield(task,470);
		// STORE 300 TO REG#36990
		process_ATABLE(300, task);
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 67->delay = 10
		Q4T(task)->currentStep = (void *)&currentLine[471];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 301 TO REG#36990
		process_ATABLE(301, task); start_of_step_timeout_flag = 0;
		// GOTO __0293
		goto __0293;
// [0301]
__0293:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 67->delay = 10
		Q4T(task)->currentStep = (void *)&currentLine[472]; lineYield(task,472);
		// STORE 106 TO REG#36991
		R36991 = 106;
		// IF REG#36991=0 GOTO __0294
		if (process_CTABLE(R36991, task) == 0) goto __0294;
		// GOTO __0293
		goto __0293;
// [0302]
__0294:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 68->R600_Empty3Commands = 0
		Q4T(task)->currentStep = (void *)&currentLine[473]; lineYield(task,473);
		// STORE 302 TO REG#36990
		process_ATABLE(302, task);
		// GOTO __0292
		goto __0292;
// [0303]
__0292:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(AxisEmpty3):STEP(Empty3Control):LINE 72->goto Empty3Control
		Q4T(task)->currentStep = (void *)&currentLine[474]; lineYield(task,474);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO AxisEmpty3_Empty3Control
		goto AxisEmpty3_Empty3Control;
// [0304]
FastUpdates:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
FastUpdates_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(FastUpdates):LINE 1->R9_Dwell = 0
		Q4T(task)->currentStep = (void *)&currentLine[475]; lineYield(task,475);
		// STORE 303 TO REG#36990
		process_ATABLE(303, task);
		// MODULE(FastUpdates):LINE 2->goto Update
		Q4T(task)->currentStep = (void *)&currentLine[476]; lineYield(task,476);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO FastUpdates_Update
		goto FastUpdates_Update;
// [0305]
FastUpdates_Update:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
FastUpdates_Update_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(FastUpdates):STEP(Update):LINE 5->R36711_Ax1Fpos = XAxis.fpos*1000
		Q4T(task)->currentStep = (void *)&currentLine[477]; lineYield(task,477);
		// STORE 304 TO REG#36990
		process_ATABLE(304, task);
		// MODULE(FastUpdates):STEP(Update):LINE 6->R36712_Ax1Fpos = YAxis.fpos*1000
		Q4T(task)->currentStep = (void *)&currentLine[478]; lineYield(task,478);
		// STORE 305 TO REG#36990
		process_ATABLE(305, task);
		// MODULE(FastUpdates):STEP(Update):LINE 7->R36713_Ax1Fpos = ZAxis.fpos*1000
		Q4T(task)->currentStep = (void *)&currentLine[479]; lineYield(task,479);
		// STORE 306 TO REG#36990
		process_ATABLE(306, task);
		// MODULE(FastUpdates):STEP(Update):LINE 8->R36714_Ax1Fpos = ThetaAxis.fpos*1000
		Q4T(task)->currentStep = (void *)&currentLine[480]; lineYield(task,480);
		// STORE 307 TO REG#36990
		process_ATABLE(307, task);
		// MODULE(FastUpdates):STEP(Update):LINE 10->R509_X_fpos = R36711_Ax1Fpos
		Q4T(task)->currentStep = (void *)&currentLine[481]; lineYield(task,481);
		// STORE 308 TO REG#36990
		process_ATABLE(308, task);
		// MODULE(FastUpdates):STEP(Update):LINE 11->R519_Y_fpos = R36712_Ax1Fpos
		Q4T(task)->currentStep = (void *)&currentLine[482]; lineYield(task,482);
		// STORE 309 TO REG#36990
		process_ATABLE(309, task);
		// MODULE(FastUpdates):STEP(Update):LINE 12->R529_Z_fpos = R36713_Ax1Fpos
		Q4T(task)->currentStep = (void *)&currentLine[483]; lineYield(task,483);
		// STORE 310 TO REG#36990
		process_ATABLE(310, task);
		// MODULE(FastUpdates):STEP(Update):LINE 13->R539_fpos = R36714_Ax1Fpos
		Q4T(task)->currentStep = (void *)&currentLine[484]; lineYield(task,484);
		// STORE 311 TO REG#36990
		process_ATABLE(311, task);
		// MODULE(FastUpdates):STEP(Update):LINE 15->XAxis.Maxspeed = R501_Speed
		Q4T(task)->currentStep = (void *)&currentLine[485]; lineYield(task,485);
		// STORE 312 TO REG#36990
		process_ATABLE(312, task);
		// MODULE(FastUpdates):STEP(Update):LINE 16->XAxis.Accel = R502_Accel
		Q4T(task)->currentStep = (void *)&currentLine[486]; lineYield(task,486);
		// STORE 313 TO REG#36990
		process_ATABLE(313, task);
		// MODULE(FastUpdates):STEP(Update):LINE 17->XAxis.Decel = R503_Decel
		Q4T(task)->currentStep = (void *)&currentLine[487]; lineYield(task,487);
		// STORE 314 TO REG#36990
		process_ATABLE(314, task);
		// MODULE(FastUpdates):STEP(Update):LINE 18->XAxis.Target = R504_Target
		Q4T(task)->currentStep = (void *)&currentLine[488]; lineYield(task,488);
		// STORE 315 TO REG#36990
		process_ATABLE(315, task);
		// MODULE(FastUpdates):STEP(Update):LINE 20->YAxis.Maxspeed = R511_Speed
		Q4T(task)->currentStep = (void *)&currentLine[489]; lineYield(task,489);
		// STORE 316 TO REG#36990
		process_ATABLE(316, task);
		// MODULE(FastUpdates):STEP(Update):LINE 21->YAxis.Accel = R512_Accel
		Q4T(task)->currentStep = (void *)&currentLine[490]; lineYield(task,490);
		// STORE 317 TO REG#36990
		process_ATABLE(317, task);
		// MODULE(FastUpdates):STEP(Update):LINE 22->YAxis.Decel = R513_Decel
		Q4T(task)->currentStep = (void *)&currentLine[491]; lineYield(task,491);
		// STORE 318 TO REG#36990
		process_ATABLE(318, task);
		// MODULE(FastUpdates):STEP(Update):LINE 23->YAxis.Target = R514_Target
		Q4T(task)->currentStep = (void *)&currentLine[492]; lineYield(task,492);
		// STORE 319 TO REG#36990
		process_ATABLE(319, task);
		// MODULE(FastUpdates):STEP(Update):LINE 25->ZAxis.Maxspeed = R521_Speed
		Q4T(task)->currentStep = (void *)&currentLine[493]; lineYield(task,493);
		// STORE 320 TO REG#36990
		process_ATABLE(320, task);
		// MODULE(FastUpdates):STEP(Update):LINE 26->ZAxis.Accel = R522_Accel
		Q4T(task)->currentStep = (void *)&currentLine[494]; lineYield(task,494);
		// STORE 321 TO REG#36990
		process_ATABLE(321, task);
		// MODULE(FastUpdates):STEP(Update):LINE 27->ZAxis.Decel = R523_Decel
		Q4T(task)->currentStep = (void *)&currentLine[495]; lineYield(task,495);
		// STORE 322 TO REG#36990
		process_ATABLE(322, task);
		// MODULE(FastUpdates):STEP(Update):LINE 28->ZAxis.Target = R524_Target
		Q4T(task)->currentStep = (void *)&currentLine[496]; lineYield(task,496);
		// STORE 323 TO REG#36990
		process_ATABLE(323, task);
		// MODULE(FastUpdates):STEP(Update):LINE 30->ThetaAxis.Maxspeed = R531_Speed
		Q4T(task)->currentStep = (void *)&currentLine[497]; lineYield(task,497);
		// STORE 324 TO REG#36990
		process_ATABLE(324, task);
		// MODULE(FastUpdates):STEP(Update):LINE 31->ThetaAxis.Accel = R532_Accel
		Q4T(task)->currentStep = (void *)&currentLine[498]; lineYield(task,498);
		// STORE 325 TO REG#36990
		process_ATABLE(325, task);
		// MODULE(FastUpdates):STEP(Update):LINE 32->ThetaAxis.Decel = R533_Decel
		Q4T(task)->currentStep = (void *)&currentLine[499]; lineYield(task,499);
		// STORE 326 TO REG#36990
		process_ATABLE(326, task);
		// MODULE(FastUpdates):STEP(Update):LINE 33->ThetaAxis.Target = R534_Target
		Q4T(task)->currentStep = (void *)&currentLine[500]; lineYield(task,500);
		// STORE 327 TO REG#36990
		process_ATABLE(327, task);
		// MODULE(FastUpdates):STEP(Update):LINE 36->R9_Dwell = $REGISTERS[13002]
		Q4T(task)->currentStep = (void *)&currentLine[501]; lineYield(task,501);
		// STORE 328 TO REG#36990
		process_ATABLE(328, task);
		// MODULE(FastUpdates):STEP(Update):LINE 39->goto Update
		Q4T(task)->currentStep = (void *)&currentLine[502]; lineYield(task,502);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO FastUpdates_Update
		goto FastUpdates_Update;
// [0306]
Updates:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
Updates_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(Updates):LINE 2->goto Update
		Q4T(task)->currentStep = (void *)&currentLine[503]; lineYield(task,503);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO Updates_Update
		goto Updates_Update;
// [0307]
Updates_Update:
		// *** START NEW STEP ***
		stepUnlocked = 1; Q4T(task)->firstPass = 1; start_of_step_timeout_flag = 0;
Updates_Update_ctc_01:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(Updates):STEP(Update):LINE 2->R36101_Temp = ThetaAxis.fpos*1000
		Q4T(task)->currentStep = (void *)&currentLine[504]; lineYield(task,504);
		// STORE 329 TO REG#36990
		process_ATABLE(329, task);
		// MODULE(Updates):STEP(Update):LINE 3->R539_fpos = R36101_Temp
		Q4T(task)->currentStep = (void *)&currentLine[505]; lineYield(task,505);
		// STORE 330 TO REG#36990
		process_ATABLE(330, task);
		// MODULE(Updates):STEP(Update):LINE 5->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[506];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 331 TO REG#36990
		process_ATABLE(331, task); start_of_step_timeout_flag = 0;
		// GOTO __0295
		goto __0295;
// [0308]
__0295:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(Updates):STEP(Update):LINE 5->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[507]; lineYield(task,507);
		// STORE 107 TO REG#36991
		R36991 = 107;
		// IF REG#36991=0 GOTO __0296
		if (process_CTABLE(R36991, task) == 0) goto __0296;
		// GOTO __0295
		goto __0295;
// [0309]
__0296:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(Updates):STEP(Update):LINE 7->R36101_Temp = Gripper.fpos*1000
		Q4T(task)->currentStep = (void *)&currentLine[508]; lineYield(task,508);
		// STORE 332 TO REG#36990
		process_ATABLE(332, task);
		// MODULE(Updates):STEP(Update):LINE 8->R549_fpos = R36101_Temp
		Q4T(task)->currentStep = (void *)&currentLine[509]; lineYield(task,509);
		// STORE 333 TO REG#36990
		process_ATABLE(333, task);
		// MODULE(Updates):STEP(Update):LINE 10->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[510];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 334 TO REG#36990
		process_ATABLE(334, task); start_of_step_timeout_flag = 0;
		// GOTO __0297
		goto __0297;
// [0310]
__0297:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(Updates):STEP(Update):LINE 10->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[511]; lineYield(task,511);
		// STORE 108 TO REG#36991
		R36991 = 108;
		// IF REG#36991=0 GOTO __0298
		if (process_CTABLE(R36991, task) == 0) goto __0298;
		// GOTO __0297
		goto __0297;
// [0311]
__0298:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(Updates):STEP(Update):LINE 16->R36101_Temp = EmptyAxis1.fpos*1000
		Q4T(task)->currentStep = (void *)&currentLine[512]; lineYield(task,512);
		// STORE 335 TO REG#36990
		process_ATABLE(335, task);
		// MODULE(Updates):STEP(Update):LINE 17->R569_fpos = R36101_Temp
		Q4T(task)->currentStep = (void *)&currentLine[513]; lineYield(task,513);
		// STORE 336 TO REG#36990
		process_ATABLE(336, task);
		// MODULE(Updates):STEP(Update):LINE 19->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[514];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 337 TO REG#36990
		process_ATABLE(337, task); start_of_step_timeout_flag = 0;
		// GOTO __0299
		goto __0299;
// [0312]
__0299:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(Updates):STEP(Update):LINE 19->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[515]; lineYield(task,515);
		// STORE 109 TO REG#36991
		R36991 = 109;
		// IF REG#36991=0 GOTO __0300
		if (process_CTABLE(R36991, task) == 0) goto __0300;
		// GOTO __0299
		goto __0299;
// [0313]
__0300:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(Updates):STEP(Update):LINE 21->R36101_Temp = EmptyAxis2.fpos*1000
		Q4T(task)->currentStep = (void *)&currentLine[516]; lineYield(task,516);
		// STORE 338 TO REG#36990
		process_ATABLE(338, task);
		// MODULE(Updates):STEP(Update):LINE 22->R579_fpos = R36101_Temp
		Q4T(task)->currentStep = (void *)&currentLine[517]; lineYield(task,517);
		// STORE 339 TO REG#36990
		process_ATABLE(339, task);
		// MODULE(Updates):STEP(Update):LINE 24->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[518];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 340 TO REG#36990
		process_ATABLE(340, task); start_of_step_timeout_flag = 0;
		// GOTO __0301
		goto __0301;
// [0314]
__0301:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(Updates):STEP(Update):LINE 24->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[519]; lineYield(task,519);
		// STORE 110 TO REG#36991
		R36991 = 110;
		// IF REG#36991=0 GOTO __0302
		if (process_CTABLE(R36991, task) == 0) goto __0302;
		// GOTO __0301
		goto __0301;
// [0315]
__0302:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(Updates):STEP(Update):LINE 26->R36101_Temp = TransferStation.fpos*1000
		Q4T(task)->currentStep = (void *)&currentLine[520]; lineYield(task,520);
		// STORE 341 TO REG#36990
		process_ATABLE(341, task);
		// MODULE(Updates):STEP(Update):LINE 27->R589_fpos = R36101_Temp
		Q4T(task)->currentStep = (void *)&currentLine[521]; lineYield(task,521);
		// STORE 342 TO REG#36990
		process_ATABLE(342, task);
		// MODULE(Updates):STEP(Update):LINE 29->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[522];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 343 TO REG#36990
		process_ATABLE(343, task); start_of_step_timeout_flag = 0;
		// GOTO __0303
		goto __0303;
// [0316]
__0303:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(Updates):STEP(Update):LINE 29->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[523]; lineYield(task,523);
		// STORE 111 TO REG#36991
		R36991 = 111;
		// IF REG#36991=0 GOTO __0304
		if (process_CTABLE(R36991, task) == 0) goto __0304;
		// GOTO __0303
		goto __0303;
// [0317]
__0304:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(Updates):STEP(Update):LINE 31->R36101_Temp = EmptyAxis3.fpos*1000
		Q4T(task)->currentStep = (void *)&currentLine[524]; lineYield(task,524);
		// STORE 344 TO REG#36990
		process_ATABLE(344, task);
		// MODULE(Updates):STEP(Update):LINE 32->R599_fpos = R36101_Temp
		Q4T(task)->currentStep = (void *)&currentLine[525]; lineYield(task,525);
		// STORE 345 TO REG#36990
		process_ATABLE(345, task);
		// MODULE(Updates):STEP(Update):LINE 34->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[526];
		// STORE 0 TO REG#36996
		stepUnlocked = 0; /* Lock step execution */
		// STORE 346 TO REG#36990
		process_ATABLE(346, task); start_of_step_timeout_flag = 0;
		// GOTO __0305
		goto __0305;
// [0318]
__0305:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(Updates):STEP(Update):LINE 34->delay = 2
		Q4T(task)->currentStep = (void *)&currentLine[527]; lineYield(task,527);
		// STORE 112 TO REG#36991
		R36991 = 112;
		// IF REG#36991=0 GOTO __0306
		if (process_CTABLE(R36991, task) == 0) goto __0306;
		// GOTO __0305
		goto __0305;
// [0319]
__0306:
		if (stepUnlocked) {
			if (task->state != TASK_LL_RUN) { if (stepYield(task)) { /* kill thread */ goto ___exitThread; } } 
		}
		else { /* release lock */ stepUnlocked = 1; }
		/*-----------------------------------------------------------------*/
		/*-----------------------------------------------------------------*/
		// MODULE(Updates):STEP(Update):LINE 36->goto Update
		Q4T(task)->currentStep = (void *)&currentLine[528]; lineYield(task,528);
		// STORE 1 TO REG#36996
		stepUnlocked = 1; /* unlock step execution */
		// GOTO Updates_Update
		goto Updates_Update;
___exitThread:
		//TASK_THREADS[parameter].task = NULL;
		return;
}

OPTIMIZED_LINE_ENTRY currentLine[] = {

{1,"MODULE(kickoff):LINE 2->goto Init1"},
{1,"MODULE(kickoff):STEP(Init1):LINE 4->R20099_ModBusTCPWordSwap = 1"},
{1,"MODULE(kickoff):STEP(Init1):LINE 6->$REGISTERS[12305] = 2"},
{0,"MODULE(kickoff):STEP(Init1):LINE 9->delay = 1000"},
{1,"MODULE(kickoff):STEP(Init1):LINE 9->delay = 1000"},
{0,"MODULE(kickoff):STEP(Init1):LINE 14->while R13464_EtherCATStatus!=1 repeat"},
{1,"MODULE(kickoff):STEP(Init1):LINE 14->while R13464_EtherCATStatus!=1 repeat"},
{1,"MODULE(kickoff):STEP(Init1):LINE 15->R10_Mode = 0"},
{1,"MODULE(kickoff):STEP(Init1):LINE 17->begin (System.String[]) tasks to StageTasks"},
{1,"MODULE(kickoff):STEP(Init1):LINE 19->begin (Updates)"},
{0,"MODULE(kickoff):STEP(Init1):LINE 22->delay = 1000"},
{1,"MODULE(kickoff):STEP(Init1):LINE 22->delay = 1000"},
{1,"MODULE(kickoff):STEP(Init1):LINE 24->start XAxis axis_X0"},
{1,"MODULE(kickoff):STEP(Init1):LINE 25->start YAxis axis_Y0"},
{1,"MODULE(kickoff):STEP(Init1):LINE 26->start ZAxis axis_Z0"},
{1,"MODULE(kickoff):STEP(Init1):LINE 28->goto Stops"},
{1,"MODULE(StageControl):LINE 2->goto Mode_Select"},
{1,"MODULE(StageControl):STEP(Mode_Select):LINE 2->R510_XAxisCommands = 0"},
{1,"MODULE(StageControl):STEP(Mode_Select):LINE 5->goto StageAuto"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 3->repeat ( "},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 6->R520_YAxisCommands = 0"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 7->R530_ZAxisCommands = 0"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 8->R540_ThetaCommands = 0"},
{0,"MODULE(StageControl):STEP(StageAuto):LINE 10->delay = 2"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 10->delay = 2"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 12->R36701_Speed = R501_Speed"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 13->R36702_Accel = R502_Accel"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 14->R36703_Decel = R503_Decel"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 16->R36704_XTarget = R504_Target"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 17->R36705_YTarget = R514_Target"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 18->R36706_ZTarget = R524_Target"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 21->XAxis.speed = R36701_Speed/1000"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 22->XAxis.Accel = R36702_Accel/1000"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 23->XAxis.Decel = R36703_Decel/1000"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 25->XAxis.XTarget = R36704_XTarget/1000"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 26->XAxis.YTarget = R36705_YTarget/1000"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 27->XAxis.ZTarget = R36706_ZTarget/1000"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 29->XAxis.command = 10"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 31->repeat ( "},
{0,"MODULE(StageControl):STEP(StageAuto):LINE 32->delay = 20"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 32->delay = 20"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 31->repeat ( "},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 34->F1_Trigger = false"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 35->R510_XAxisCommands = 0"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 37->goto StageAuto"},
{1,"MODULE(StageControl):STEP(StageAuto):LINE 39->goto StageAuto"},
{1,"MODULE(kickoff):STEP(Stops):LINE 4->if R500_RestartProgram==1 then "},
{1,"MODULE(kickoff):STEP(Stops):LINE 5->R500_RestartProgram = 0"},
{1,"MODULE(kickoff):STEP(Stops):LINE 7->cancel other tasks"},
{1,"MODULE(kickoff):STEP(Stops):LINE 8->stop XAxis 0"},
{1,"MODULE(kickoff):STEP(Stops):LINE 9->stop YAxis 0"},
{1,"MODULE(kickoff):STEP(Stops):LINE 10->stop ZAxis 0"},
{1,"MODULE(kickoff):STEP(Stops):LINE 11->stop ThetaAxis 0"},
{1,"MODULE(kickoff):STEP(Stops):LINE 12->stop Gripper 0"},
{1,"MODULE(kickoff):STEP(Stops):LINE 14->stop EmptyAxis1 0"},
{1,"MODULE(kickoff):STEP(Stops):LINE 15->stop EmptyAxis2 0"},
{1,"MODULE(kickoff):STEP(Stops):LINE 16->stop TransferStation 0"},
{1,"MODULE(kickoff):STEP(Stops):LINE 17->stop EmptyAxis3 0"},
{0,"MODULE(kickoff):STEP(Stops):LINE 18->delay = 3000"},
{1,"MODULE(kickoff):STEP(Stops):LINE 18->delay = 3000"},
{1,"MODULE(kickoff):STEP(Stops):LINE 21->$REGISTERS[10101] = 0"},
{1,"MODULE(kickoff):STEP(Stops):LINE 30->i = 0"},
{1,"MODULE(kickoff):STEP(Stops):LINE 33->R12333_RestartEtherCAT = 1"},
{1,"MODULE(kickoff):STEP(Stops):LINE 34->R13464_EtherCATStatus = 21930"},
{0,"MODULE(kickoff):STEP(Stops):LINE 35->delay = 2000"},
{1,"MODULE(kickoff):STEP(Stops):LINE 35->delay = 2000"},
{1,"MODULE(kickoff):STEP(Stops):LINE 36->goto Init1"},
{1,"MODULE(kickoff):STEP(Stops):LINE 41->goto Stops"},
{1,"MODULE(AxisX):STEP(Init):LINE 3->start XAxis Motion0"},
{1,"MODULE(AxisX):STEP(Init):LINE 4->XAxis.command = 0"},
{1,"MODULE(AxisX):STEP(Init):LINE 5->R510_XAxisCommands = 0"},
{1,"MODULE(AxisX):STEP(Init):LINE 9->goto AxisXControl"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 9->if (R510_XAxisCommands)==1 | (R510_XAxisCommands)==11 then "},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 10->XAxis.Maxspeed = R501_Speed"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 11->XAxis.Accel = R502_Accel"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 12->XAxis.Decel = R503_Decel"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 13->XAxis.Target = R504_Target"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 15->XAxis.command = (R510_XAxisCommands)"},
{0,"MODULE(AxisX):STEP(AxisXControl):LINE 17->delay = 2"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 17->delay = 2"},
{0,"MODULE(AxisX):STEP(AxisXControl):LINE 20->while (XAxis.command==1 | XAxis.command==11) & (R510_XAxisCommands==1 | R510_XAxisCommands==11) repeat"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 20->while (XAxis.command==1 | XAxis.command==11) & (R510_XAxisCommands==1 | R510_XAxisCommands==11) repeat"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 21->running1 = true"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 27->if (R510_XAxisCommands)==3 | (R510_XAxisCommands)==4 then "},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 28->XAxis.Maxspeed = R501_Speed"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 29->XAxis.Accel = R502_Accel"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 30->XAxis.Decel = R503_Decel"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 32->XAxis.command = (R510_XAxisCommands)"},
{0,"MODULE(AxisX):STEP(AxisXControl):LINE 34->delay = 2"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 34->delay = 2"},
{0,"MODULE(AxisX):STEP(AxisXControl):LINE 35->while XAxis.command==(R510_XAxisCommands) repeat"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 35->while XAxis.command==(R510_XAxisCommands) repeat"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 36->running1 = true"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 41->if (R510_XAxisCommands)==5 then "},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 42->XAxis.Maxspeed = R501_Speed"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 43->XAxis.Accel = R502_Accel"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 44->XAxis.Decel = R503_Decel"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 47->XAxis.Target = R504_Target"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 48->XAxis.OffsetHome = R505_HomeOffset"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 49->XAxis.command = 5"},
{0,"MODULE(AxisX):STEP(AxisXControl):LINE 51->while XAxis.command==5 & (R510_XAxisCommands)==5 repeat"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 51->while XAxis.command==5 & (R510_XAxisCommands)==5 repeat"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 52->running1 = true"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 58->if ((R510_XAxisCommands)==0 & running1==true) then "},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 59->XAxis.command = 0"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 60->running1 = false"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 64->if ((R510_XAxisCommands)==6 | (R510_XAxisCommands)==7) then "},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 65->XAxis.command = R510_XAxisCommands"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 66->R510_XAxisCommands = 0"},
{1,"MODULE(AxisX):STEP(AxisXControl):LINE 73->goto AxisXControl"},
{1,"MODULE(AxisX):LINE 2->goto Init"},
{1,"MODULE(AxisY):STEP(Init):LINE 3->start YAxis Motion0"},
{1,"MODULE(AxisY):STEP(Init):LINE 4->YAxis.command = 0"},
{1,"MODULE(AxisY):STEP(Init):LINE 5->R520_YAxisCommands = 0"},
{1,"MODULE(AxisY):STEP(Init):LINE 8->goto AxisYControl"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 8->if (R520_YAxisCommands)==1 | (R520_YAxisCommands)==11 then "},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 9->YAxis.Maxspeed = R511_Speed"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 10->YAxis.Accel = R512_Accel"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 11->YAxis.Decel = R513_Decel"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 12->YAxis.Target = R514_Target"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 14->YAxis.command = (R520_YAxisCommands)"},
{0,"MODULE(AxisY):STEP(AxisYControl):LINE 16->delay = 2"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 16->delay = 2"},
{0,"MODULE(AxisY):STEP(AxisYControl):LINE 17->while (YAxis.command==1 | YAxis.command==11) & (R520_YAxisCommands==1 | R520_YAxisCommands==11) repeat"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 17->while (YAxis.command==1 | YAxis.command==11) & (R520_YAxisCommands==1 | R520_YAxisCommands==11) repeat"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 18->running2 = true"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 24->if (R520_YAxisCommands)==3 | (R520_YAxisCommands)==4 then "},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 25->YAxis.Maxspeed = R511_Speed"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 26->YAxis.Accel = R512_Accel"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 27->YAxis.Decel = R513_Decel"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 28->YAxis.command = (R520_YAxisCommands)"},
{0,"MODULE(AxisY):STEP(AxisYControl):LINE 31->delay = 2"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 31->delay = 2"},
{0,"MODULE(AxisY):STEP(AxisYControl):LINE 32->while YAxis.command==(R520_YAxisCommands) repeat"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 32->while YAxis.command==(R520_YAxisCommands) repeat"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 33->running2 = true"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 38->if (R520_YAxisCommands)==5 then "},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 39->YAxis.Maxspeed = R511_Speed"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 40->YAxis.Accel = R512_Accel"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 41->YAxis.Decel = R513_Decel"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 42->YAxis.Target = R514_Target"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 43->YAxis.OffsetHome = R515_HomeOffset"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 44->YAxis.command = 5"},
{0,"MODULE(AxisY):STEP(AxisYControl):LINE 46->while YAxis.command==5 & (R520_YAxisCommands)==5 repeat"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 46->while YAxis.command==5 & (R520_YAxisCommands)==5 repeat"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 47->running2 = true"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 53->if ((R520_YAxisCommands)==0 & running2==true) then "},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 54->YAxis.command = 0"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 55->running2 = false"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 60->if ((R520_YAxisCommands)==6 | (R520_YAxisCommands)==7) then "},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 61->YAxis.command = R520_YAxisCommands"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 62->R520_YAxisCommands = 0"},
{1,"MODULE(AxisY):STEP(AxisYControl):LINE 68->goto AxisYControl"},
{1,"MODULE(AxisY):LINE 2->goto Init"},
{1,"MODULE(AxisZ):STEP(Init):LINE 2->start ZAxis Motion0"},
{1,"MODULE(AxisZ):STEP(Init):LINE 3->ZAxis.command = 0"},
{1,"MODULE(AxisZ):STEP(Init):LINE 4->R530_ZAxisCommands = 0"},
{1,"MODULE(AxisZ):STEP(Init):LINE 8->goto AxisZControl"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 10->if (R530_ZAxisCommands)==1 | (R530_ZAxisCommands)==11 then "},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 13->ZAxis.Maxspeed = R521_Speed"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 14->ZAxis.Accel = R522_Accel"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 15->ZAxis.Decel = R523_Decel"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 16->ZAxis.Target = R524_Target"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 18->ZAxis.command = (R530_ZAxisCommands)"},
{0,"MODULE(AxisZ):STEP(AxisZControl):LINE 20->delay = 2"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 20->delay = 2"},
{0,"MODULE(AxisZ):STEP(AxisZControl):LINE 21->while (ZAxis.command==1 | ZAxis.command==11) & (R530_ZAxisCommands==1 | R530_ZAxisCommands==11) repeat"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 21->while (ZAxis.command==1 | ZAxis.command==11) & (R530_ZAxisCommands==1 | R530_ZAxisCommands==11) repeat"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 22->running3 = true"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 28->if (R530_ZAxisCommands)==3 | (R530_ZAxisCommands)==4 then "},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 30->ZAxis.Maxspeed = R521_Speed"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 31->ZAxis.Accel = R522_Accel"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 32->ZAxis.Decel = R523_Decel"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 34->ZAxis.command = (R530_ZAxisCommands)"},
{0,"MODULE(AxisZ):STEP(AxisZControl):LINE 36->delay = 2"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 36->delay = 2"},
{0,"MODULE(AxisZ):STEP(AxisZControl):LINE 37->while ZAxis.command==(R530_ZAxisCommands) repeat"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 37->while ZAxis.command==(R530_ZAxisCommands) repeat"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 38->running3 = true"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 43->if (R530_ZAxisCommands)==5 then "},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 44->ZAxis.Maxspeed = R521_Speed"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 45->ZAxis.Accel = R522_Accel"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 46->ZAxis.Decel = R523_Decel"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 47->ZAxis.Target = R524_Target"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 48->ZAxis.OffsetHome = R525_HomeOffset"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 49->ZAxis.command = 5"},
{0,"MODULE(AxisZ):STEP(AxisZControl):LINE 51->while ZAxis.command==5 & (R530_ZAxisCommands)==5 repeat"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 51->while ZAxis.command==5 & (R530_ZAxisCommands)==5 repeat"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 52->running3 = true"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 58->if ((R530_ZAxisCommands)==0 & running3==true) then "},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 59->ZAxis.command = 0"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 60->running3 = false"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 64->if ((R530_ZAxisCommands)==6 | (R530_ZAxisCommands)==7) then "},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 65->ZAxis.command = R530_ZAxisCommands"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 66->R530_ZAxisCommands = 0"},
{1,"MODULE(AxisZ):STEP(AxisZControl):LINE 71->goto AxisZControl"},
{1,"MODULE(AxisZ):LINE 2->goto Init"},
{1,"MODULE(AxisTheta):LINE 2->goto Init"},
{1,"MODULE(AxisTheta):STEP(Init):LINE 2->start ThetaAxis Motion0"},
{1,"MODULE(AxisTheta):STEP(Init):LINE 3->ThetaAxis.command = 0"},
{1,"MODULE(AxisTheta):STEP(Init):LINE 4->R540_ThetaCommands = 0"},
{1,"MODULE(AxisTheta):STEP(Init):LINE 8->goto ThetaControl"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 10->if (R540_ThetaCommands)==1 | (R540_ThetaCommands)==11 then "},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 13->ThetaAxis.Maxspeed = R531_Speed"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 14->ThetaAxis.Accel = R532_Accel"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 15->ThetaAxis.Decel = R533_Decel"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 16->ThetaAxis.Target = R534_Target"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 18->ThetaAxis.command = (R540_ThetaCommands)"},
{0,"MODULE(AxisTheta):STEP(ThetaControl):LINE 20->delay = 2"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 20->delay = 2"},
{0,"MODULE(AxisTheta):STEP(ThetaControl):LINE 21->while (ThetaAxis.command==1 | ThetaAxis.command==11) & (R540_ThetaCommands==1 | R540_ThetaCommands==11) repeat"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 21->while (ThetaAxis.command==1 | ThetaAxis.command==11) & (R540_ThetaCommands==1 | R540_ThetaCommands==11) repeat"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 22->running4 = true"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 28->if (R540_ThetaCommands)==3 | (R540_ThetaCommands)==4 then "},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 30->ThetaAxis.Maxspeed = R531_Speed"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 31->ThetaAxis.Accel = R532_Accel"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 32->ThetaAxis.Decel = R533_Decel"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 34->ThetaAxis.command = (R540_ThetaCommands)"},
{0,"MODULE(AxisTheta):STEP(ThetaControl):LINE 36->delay = 2"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 36->delay = 2"},
{0,"MODULE(AxisTheta):STEP(ThetaControl):LINE 37->while ThetaAxis.command==(R540_ThetaCommands) repeat"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 37->while ThetaAxis.command==(R540_ThetaCommands) repeat"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 38->running4 = true"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 43->if (R540_ThetaCommands)==5 then "},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 44->ThetaAxis.Maxspeed = R531_Speed"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 45->ThetaAxis.Accel = R532_Accel"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 46->ThetaAxis.Decel = R533_Decel"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 47->ThetaAxis.Target = R534_Target"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 48->ThetaAxis.OffsetHome = R535_HomeOffset"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 49->ThetaAxis.command = 5"},
{0,"MODULE(AxisTheta):STEP(ThetaControl):LINE 51->while ThetaAxis.command==5 & (R540_ThetaCommands)==5 repeat"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 51->while ThetaAxis.command==5 & (R540_ThetaCommands)==5 repeat"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 52->running4 = true"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 58->if ((R540_ThetaCommands)==0 & running4==true) then "},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 59->ThetaAxis.command = 0"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 60->running4 = false"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 65->if ((R540_ThetaCommands)==6 | (R540_ThetaCommands)==7) then "},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 66->ThetaAxis.command = R540_ThetaCommands"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 67->R540_ThetaCommands = 0"},
{1,"MODULE(AxisTheta):STEP(ThetaControl):LINE 72->goto ThetaControl"},
{1,"MODULE(AxisGripper):LINE 2->goto Init"},
{1,"MODULE(AxisGripper):STEP(Init):LINE 2->start Gripper MaxonMotion0"},
{1,"MODULE(AxisGripper):STEP(Init):LINE 4->Gripper.command = 0"},
{1,"MODULE(AxisGripper):STEP(Init):LINE 5->R550_GripperCommands = 0"},
{1,"MODULE(AxisGripper):STEP(Init):LINE 9->goto GripperControl"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 10->if (R550_GripperCommands)==1 then "},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 12->Gripper.Maxspeed = R541_Speed"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 13->Gripper.Accel = R542_Accel"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 14->Gripper.Decel = R543_Decel"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 15->Gripper.Target = R544_Target"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 17->Gripper.command = (R550_GripperCommands)"},
{0,"MODULE(AxisGripper):STEP(GripperControl):LINE 19->delay = 2"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 19->delay = 2"},
{0,"MODULE(AxisGripper):STEP(GripperControl):LINE 20->while (Gripper.command==1) & (R550_GripperCommands==1) repeat"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 20->while (Gripper.command==1) & (R550_GripperCommands==1) repeat"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 21->running5 = true"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 27->if (R550_GripperCommands)==3 | (R550_GripperCommands)==4 then "},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 29->Gripper.Maxspeed = R541_Speed"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 30->Gripper.Accel = R542_Accel"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 31->Gripper.Decel = R543_Decel"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 33->Gripper.command = (R550_GripperCommands)"},
{0,"MODULE(AxisGripper):STEP(GripperControl):LINE 35->delay = 2"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 35->delay = 2"},
{0,"MODULE(AxisGripper):STEP(GripperControl):LINE 36->while Gripper.command==(R550_GripperCommands) repeat"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 36->while Gripper.command==(R550_GripperCommands) repeat"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 37->running5 = true"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 42->if (R550_GripperCommands)==5 then "},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 43->Gripper.Maxspeed = R541_Speed"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 44->Gripper.Accel = R542_Accel"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 45->Gripper.Decel = R533_Decel"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 46->Gripper.Target = R544_Target"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 47->Gripper.OffsetHome = R545_HomeOffset"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 48->Gripper.command = 5"},
{0,"MODULE(AxisGripper):STEP(GripperControl):LINE 50->while Gripper.command==5 & (R550_GripperCommands)==5 repeat"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 50->while Gripper.command==5 & (R550_GripperCommands)==5 repeat"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 51->running5 = true"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 57->if ((R550_GripperCommands)==0 & running5==true) then "},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 58->Gripper.command = 0"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 59->running5 = false"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 62->if ((R550_GripperCommands)==6 | (R550_GripperCommands)==7) then "},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 63->Gripper.command = R550_GripperCommands"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 64->R550_GripperCommands = 0"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 68->if (R550_GripperCommands)==9 then "},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 69->Gripper.NewPosition = 0"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 70->Gripper.command = R550_GripperCommands"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 71->R550_GripperCommands = 0"},
{1,"MODULE(AxisGripper):STEP(GripperControl):LINE 73->goto GripperControl"},
{1,"MODULE(AxisEmpty1):LINE 2->goto Init"},
{1,"MODULE(AxisEmpty1):STEP(Init):LINE 2->start EmptyAxis1 MaxonMotion0"},
{1,"MODULE(AxisEmpty1):STEP(Init):LINE 4->EmptyAxis1.command = 0"},
{1,"MODULE(AxisEmpty1):STEP(Init):LINE 5->R570_Empty1Commands = 0"},
{1,"MODULE(AxisEmpty1):STEP(Init):LINE 9->goto Empty1Control"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 10->if (R570_Empty1Commands)==1 then "},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 12->EmptyAxis1.Maxspeed = R561_Speed"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 13->EmptyAxis1.Accel = R562_Accel"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 14->EmptyAxis1.Decel = R563_Decel"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 15->EmptyAxis1.Target = R564_Target"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 17->EmptyAxis1.command = (R570_Empty1Commands)"},
{0,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 19->delay = 2"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 19->delay = 2"},
{0,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 20->while (EmptyAxis1.command==1) & (R570_Empty1Commands==1) repeat"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 20->while (EmptyAxis1.command==1) & (R570_Empty1Commands==1) repeat"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 21->running7 = true"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 27->if (R570_Empty1Commands)==3 | (R570_Empty1Commands)==4 then "},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 29->EmptyAxis1.Maxspeed = R561_Speed"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 30->EmptyAxis1.Accel = R562_Accel"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 31->EmptyAxis1.Decel = R563_Decel"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 33->EmptyAxis1.command = (R570_Empty1Commands)"},
{0,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 35->delay = 2"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 35->delay = 2"},
{0,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 36->while EmptyAxis1.command==(R570_Empty1Commands) repeat"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 36->while EmptyAxis1.command==(R570_Empty1Commands) repeat"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 37->running7 = true"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 42->if (R570_Empty1Commands)==5 then "},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 43->EmptyAxis1.Maxspeed = R561_Speed"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 44->EmptyAxis1.Accel = R562_Accel"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 45->EmptyAxis1.Decel = R563_Decel"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 46->EmptyAxis1.Target = R564_Target"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 47->EmptyAxis1.OffsetHome = R565_HomeOffset"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 48->EmptyAxis1.command = 5"},
{0,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 50->while EmptyAxis1.command==5 & (R570_Empty1Commands)==5 repeat"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 50->while EmptyAxis1.command==5 & (R570_Empty1Commands)==5 repeat"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 51->running7 = true"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 57->if ((R570_Empty1Commands)==0 & running7==true) then "},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 58->EmptyAxis1.command = 0"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 59->running7 = false"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 62->if ((R570_Empty1Commands)==6 | (R570_Empty1Commands)==7) then "},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 63->EmptyAxis1.command = R570_Empty1Commands"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 64->R570_Empty1Commands = 0"},
{1,"MODULE(AxisEmpty1):STEP(Empty1Control):LINE 69->goto Empty1Control"},
{1,"MODULE(AxisEmpty2):LINE 2->goto Init"},
{1,"MODULE(AxisEmpty2):STEP(Init):LINE 2->start EmptyAxis2 MaxonMotion0"},
{1,"MODULE(AxisEmpty2):STEP(Init):LINE 4->EmptyAxis2.command = 0"},
{1,"MODULE(AxisEmpty2):STEP(Init):LINE 5->R580_Empty2Commands = 0"},
{1,"MODULE(AxisEmpty2):STEP(Init):LINE 9->goto Empty2Control"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 10->if (R580_Empty2Commands)==1 then "},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 12->EmptyAxis2.Maxspeed = R571_Speed"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 13->EmptyAxis2.Accel = R572_Accel"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 14->EmptyAxis2.Decel = R573_Decel"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 15->EmptyAxis2.Target = R574_Target"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 17->EmptyAxis2.command = (R580_Empty2Commands)"},
{0,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 19->delay = 2"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 19->delay = 2"},
{0,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 20->while (EmptyAxis2.command==1) & (R580_Empty2Commands==1) repeat"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 20->while (EmptyAxis2.command==1) & (R580_Empty2Commands==1) repeat"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 21->running8 = true"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 27->if (R580_Empty2Commands)==3 | (R580_Empty2Commands)==4 then "},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 29->EmptyAxis2.Maxspeed = R571_Speed"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 30->EmptyAxis2.Accel = R572_Accel"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 31->EmptyAxis2.Decel = R573_Decel"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 33->EmptyAxis2.command = (R580_Empty2Commands)"},
{0,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 35->delay = 2"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 35->delay = 2"},
{0,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 36->while EmptyAxis2.command==(R580_Empty2Commands) repeat"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 36->while EmptyAxis2.command==(R580_Empty2Commands) repeat"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 37->running8 = true"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 42->if (R580_Empty2Commands)==5 then "},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 43->EmptyAxis2.Maxspeed = R571_Speed"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 44->EmptyAxis2.Accel = R572_Accel"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 45->EmptyAxis2.Decel = R573_Decel"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 46->EmptyAxis2.Target = R574_Target"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 47->EmptyAxis2.OffsetHome = R575_HomeOffset"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 48->EmptyAxis2.command = 5"},
{0,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 50->while EmptyAxis2.command==5 & (R580_Empty2Commands)==5 repeat"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 50->while EmptyAxis2.command==5 & (R580_Empty2Commands)==5 repeat"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 51->running8 = true"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 57->if ((R580_Empty2Commands)==0 & running8==true) then "},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 58->EmptyAxis2.command = 0"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 59->running8 = false"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 62->if ((R580_Empty2Commands)==6 | (R580_Empty2Commands)==7) then "},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 63->EmptyAxis2.command = R580_Empty2Commands"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 64->R580_Empty2Commands = 0"},
{1,"MODULE(AxisEmpty2):STEP(Empty2Control):LINE 69->goto Empty2Control"},
{1,"MODULE(AxisTransferStation):LINE 2->goto Init"},
{1,"MODULE(AxisTransferStation):STEP(Init):LINE 2->start TransferStation StepperMotion0"},
{0,"MODULE(AxisTransferStation):STEP(Init):LINE 3->delay = 100"},
{1,"MODULE(AxisTransferStation):STEP(Init):LINE 3->delay = 100"},
{1,"MODULE(AxisTransferStation):STEP(Init):LINE 5->TransferStation.command = 0"},
{1,"MODULE(AxisTransferStation):STEP(Init):LINE 6->TransferStation.Axisnum = 9"},
{1,"MODULE(AxisTransferStation):STEP(Init):LINE 8->R590_TransferStationCommands = 0"},
{1,"MODULE(AxisTransferStation):STEP(Init):LINE 12->goto CableElevfControl"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 10->if (R590_TransferStationCommands)==1 then "},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 12->TransferStation.Maxspeed = R581_Speed"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 13->TransferStation.Accel = R582_Accel"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 14->TransferStation.Decel = R583_Decel"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 15->TransferStation.Target = R584_Target"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 17->TransferStation.command = (R590_TransferStationCommands)"},
{0,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 19->delay = 2"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 19->delay = 2"},
{0,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 20->while (TransferStation.command==1) & (R590_TransferStationCommands==1) repeat"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 20->while (TransferStation.command==1) & (R590_TransferStationCommands==1) repeat"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 21->running9 = true"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 27->if (R590_TransferStationCommands)==3 | (R590_TransferStationCommands)==4 then "},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 29->TransferStation.Maxspeed = R581_Speed"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 30->TransferStation.Accel = R582_Accel"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 31->TransferStation.Decel = R583_Decel"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 33->TransferStation.command = (R590_TransferStationCommands)"},
{0,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 35->delay = 2"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 35->delay = 2"},
{0,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 36->while TransferStation.command==(R590_TransferStationCommands) repeat"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 36->while TransferStation.command==(R590_TransferStationCommands) repeat"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 37->running9 = true"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 42->if (R590_TransferStationCommands)==5 then "},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 43->TransferStation.Maxspeed = R581_Speed"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 44->TransferStation.Accel = R582_Accel"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 45->TransferStation.Decel = R583_Decel"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 46->TransferStation.Target = R584_Target"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 47->TransferStation.OffsetHome = R585_HomeOffset"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 48->TransferStation.command = 5"},
{0,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 50->while TransferStation.command==5 & (R590_TransferStationCommands)==5 repeat"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 50->while TransferStation.command==5 & (R590_TransferStationCommands)==5 repeat"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 51->running9 = true"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 57->if ((R590_TransferStationCommands)==0 & running9==true) then "},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 58->TransferStation.command = 0"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 59->running9 = false"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 62->if ((R590_TransferStationCommands)==6 | (R590_TransferStationCommands)==7) then "},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 63->TransferStation.command = R590_TransferStationCommands"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 64->R590_TransferStationCommands = 0"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 66->if (R590_TransferStationCommands)==8 then "},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 67->TransferStation.command = R590_TransferStationCommands"},
{0,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 68->delay = 10"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 68->delay = 10"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 69->R590_TransferStationCommands = 0"},
{1,"MODULE(AxisTransferStation):STEP(CableElevfControl):LINE 73->goto CableElevfControl"},
{1,"MODULE(AxisEmpty3):LINE 2->goto Init"},
{1,"MODULE(AxisEmpty3):STEP(Init):LINE 2->start EmptyAxis3 StepperMotion0"},
{0,"MODULE(AxisEmpty3):STEP(Init):LINE 3->delay = 100"},
{1,"MODULE(AxisEmpty3):STEP(Init):LINE 3->delay = 100"},
{1,"MODULE(AxisEmpty3):STEP(Init):LINE 5->EmptyAxis3.command = 0"},
{1,"MODULE(AxisEmpty3):STEP(Init):LINE 6->EmptyAxis3.Axisnum = 10"},
{1,"MODULE(AxisEmpty3):STEP(Init):LINE 8->R600_Empty3Commands = 0"},
{1,"MODULE(AxisEmpty3):STEP(Init):LINE 12->goto Empty3Control"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 11->if (R600_Empty3Commands)==1 then "},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 13->EmptyAxis3.Maxspeed = R591_Speed"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 14->EmptyAxis3.Accel = R592_Accel"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 15->EmptyAxis3.Decel = R593_Decel"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 16->EmptyAxis3.Target = R594_Target"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 18->EmptyAxis3.command = (R600_Empty3Commands)"},
{0,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 19->delay = 20"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 19->delay = 20"},
{0,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 20->while (EmptyAxis3.command==1) & (R600_Empty3Commands==1) repeat"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 20->while (EmptyAxis3.command==1) & (R600_Empty3Commands==1) repeat"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 21->running10 = true"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 27->if (R600_Empty3Commands)==3 | (R600_Empty3Commands)==4 then "},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 29->EmptyAxis3.Maxspeed = R591_Speed"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 30->EmptyAxis3.Accel = R592_Accel"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 31->EmptyAxis3.Decel = R593_Decel"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 33->EmptyAxis3.command = (R600_Empty3Commands)"},
{0,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 34->delay = 20"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 34->delay = 20"},
{0,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 35->while EmptyAxis3.command==(R600_Empty3Commands) repeat"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 35->while EmptyAxis3.command==(R600_Empty3Commands) repeat"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 36->running10 = true"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 41->if (R600_Empty3Commands)==5 then "},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 42->EmptyAxis3.Maxspeed = R591_Speed"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 43->EmptyAxis3.Accel = R592_Accel"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 44->EmptyAxis3.Decel = R593_Decel"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 45->EmptyAxis3.Target = R594_Target"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 46->EmptyAxis3.OffsetHome = R595_HomeOffset"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 47->EmptyAxis3.command = 5"},
{0,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 49->while EmptyAxis3.command==5 & (R600_Empty3Commands)==5 repeat"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 49->while EmptyAxis3.command==5 & (R600_Empty3Commands)==5 repeat"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 50->running10 = true"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 56->if ((R600_Empty3Commands)==0 & running10==true) then "},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 57->EmptyAxis3.command = 0"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 58->running10 = false"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 61->if ((R600_Empty3Commands)==6 | (R600_Empty3Commands)==7) then "},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 62->EmptyAxis3.command = R600_Empty3Commands"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 63->R600_Empty3Commands = 0"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 65->if (R600_Empty3Commands)==8 then "},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 66->EmptyAxis3.command = R600_Empty3Commands"},
{0,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 67->delay = 10"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 67->delay = 10"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 68->R600_Empty3Commands = 0"},
{1,"MODULE(AxisEmpty3):STEP(Empty3Control):LINE 72->goto Empty3Control"},
{1,"MODULE(FastUpdates):LINE 1->R9_Dwell = 0"},
{1,"MODULE(FastUpdates):LINE 2->goto Update"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 5->R36711_Ax1Fpos = XAxis.fpos*1000"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 6->R36712_Ax1Fpos = YAxis.fpos*1000"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 7->R36713_Ax1Fpos = ZAxis.fpos*1000"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 8->R36714_Ax1Fpos = ThetaAxis.fpos*1000"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 10->R509_X_fpos = R36711_Ax1Fpos"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 11->R519_Y_fpos = R36712_Ax1Fpos"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 12->R529_Z_fpos = R36713_Ax1Fpos"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 13->R539_fpos = R36714_Ax1Fpos"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 15->XAxis.Maxspeed = R501_Speed"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 16->XAxis.Accel = R502_Accel"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 17->XAxis.Decel = R503_Decel"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 18->XAxis.Target = R504_Target"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 20->YAxis.Maxspeed = R511_Speed"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 21->YAxis.Accel = R512_Accel"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 22->YAxis.Decel = R513_Decel"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 23->YAxis.Target = R514_Target"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 25->ZAxis.Maxspeed = R521_Speed"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 26->ZAxis.Accel = R522_Accel"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 27->ZAxis.Decel = R523_Decel"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 28->ZAxis.Target = R524_Target"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 30->ThetaAxis.Maxspeed = R531_Speed"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 31->ThetaAxis.Accel = R532_Accel"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 32->ThetaAxis.Decel = R533_Decel"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 33->ThetaAxis.Target = R534_Target"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 36->R9_Dwell = $REGISTERS[13002]"},
{1,"MODULE(FastUpdates):STEP(Update):LINE 39->goto Update"},
{1,"MODULE(Updates):LINE 2->goto Update"},
{1,"MODULE(Updates):STEP(Update):LINE 2->R36101_Temp = ThetaAxis.fpos*1000"},
{1,"MODULE(Updates):STEP(Update):LINE 3->R539_fpos = R36101_Temp"},
{0,"MODULE(Updates):STEP(Update):LINE 5->delay = 2"},
{1,"MODULE(Updates):STEP(Update):LINE 5->delay = 2"},
{1,"MODULE(Updates):STEP(Update):LINE 7->R36101_Temp = Gripper.fpos*1000"},
{1,"MODULE(Updates):STEP(Update):LINE 8->R549_fpos = R36101_Temp"},
{0,"MODULE(Updates):STEP(Update):LINE 10->delay = 2"},
{1,"MODULE(Updates):STEP(Update):LINE 10->delay = 2"},
{1,"MODULE(Updates):STEP(Update):LINE 16->R36101_Temp = EmptyAxis1.fpos*1000"},
{1,"MODULE(Updates):STEP(Update):LINE 17->R569_fpos = R36101_Temp"},
{0,"MODULE(Updates):STEP(Update):LINE 19->delay = 2"},
{1,"MODULE(Updates):STEP(Update):LINE 19->delay = 2"},
{1,"MODULE(Updates):STEP(Update):LINE 21->R36101_Temp = EmptyAxis2.fpos*1000"},
{1,"MODULE(Updates):STEP(Update):LINE 22->R579_fpos = R36101_Temp"},
{0,"MODULE(Updates):STEP(Update):LINE 24->delay = 2"},
{1,"MODULE(Updates):STEP(Update):LINE 24->delay = 2"},
{1,"MODULE(Updates):STEP(Update):LINE 26->R36101_Temp = TransferStation.fpos*1000"},
{1,"MODULE(Updates):STEP(Update):LINE 27->R589_fpos = R36101_Temp"},
{0,"MODULE(Updates):STEP(Update):LINE 29->delay = 2"},
{1,"MODULE(Updates):STEP(Update):LINE 29->delay = 2"},
{1,"MODULE(Updates):STEP(Update):LINE 31->R36101_Temp = EmptyAxis3.fpos*1000"},
{1,"MODULE(Updates):STEP(Update):LINE 32->R599_fpos = R36101_Temp"},
{0,"MODULE(Updates):STEP(Update):LINE 34->delay = 2"},
{1,"MODULE(Updates):STEP(Update):LINE 34->delay = 2"},
{1,"MODULE(Updates):STEP(Update):LINE 36->goto Update"},
{0,"MODULE(++++++):LINE 1->*** STARTING ****"},
{0,""}
};
